[
{
  "model": "admin.logentry",
  "pk": 1,
  "fields": {
    "action_time": "2024-09-12T01:42:58.973Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 2,
  "fields": {
    "action_time": "2024-09-12T02:08:16.304Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 3,
  "fields": {
    "action_time": "2024-09-12T02:11:01.354Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 4,
  "fields": {
    "action_time": "2024-09-12T02:11:24.017Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 5,
  "fields": {
    "action_time": "2024-09-12T02:11:50.419Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 6,
  "fields": {
    "action_time": "2024-09-12T02:13:34.776Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 7,
  "fields": {
    "action_time": "2024-09-12T02:14:18.906Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 8,
  "fields": {
    "action_time": "2024-09-12T02:15:08.460Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 9,
  "fields": {
    "action_time": "2024-09-12T02:16:11.076Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 10,
  "fields": {
    "action_time": "2024-09-12T22:57:15.682Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 11,
  "fields": {
    "action_time": "2024-09-12T23:04:22.457Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 12,
  "fields": {
    "action_time": "2024-09-12T23:05:35.196Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 13,
  "fields": {
    "action_time": "2024-09-12T23:06:17.878Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 14,
  "fields": {
    "action_time": "2024-09-12T23:09:55.114Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 15,
  "fields": {
    "action_time": "2024-09-12T23:12:39.245Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 16,
  "fields": {
    "action_time": "2024-09-12T23:14:10.201Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 17,
  "fields": {
    "action_time": "2024-09-12T23:15:12.742Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 18,
  "fields": {
    "action_time": "2024-09-12T23:15:49.558Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 19,
  "fields": {
    "action_time": "2024-09-12T23:16:10.659Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 20,
  "fields": {
    "action_time": "2024-09-12T23:17:07.162Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 21,
  "fields": {
    "action_time": "2024-09-12T23:17:29.927Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 22,
  "fields": {
    "action_time": "2024-09-12T23:18:09.432Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 23,
  "fields": {
    "action_time": "2024-09-12T23:18:48.624Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 24,
  "fields": {
    "action_time": "2024-09-12T23:20:30.580Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 25,
  "fields": {
    "action_time": "2024-09-12T23:21:46.821Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 26,
  "fields": {
    "action_time": "2024-09-12T23:22:38.384Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 27,
  "fields": {
    "action_time": "2024-09-12T23:23:24.330Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 28,
  "fields": {
    "action_time": "2024-09-12T23:24:19.527Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Content\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 29,
  "fields": {
    "action_time": "2024-09-15T22:49:09.228Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 30,
  "fields": {
    "action_time": "2024-09-15T22:56:38.878Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 31,
  "fields": {
    "action_time": "2024-09-15T22:57:23.393Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 32,
  "fields": {
    "action_time": "2024-09-15T22:57:58.656Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 33,
  "fields": {
    "action_time": "2024-09-15T23:04:32.001Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 34,
  "fields": {
    "action_time": "2024-09-15T23:05:29.650Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 35,
  "fields": {
    "action_time": "2024-09-15T23:08:09.041Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 36,
  "fields": {
    "action_time": "2024-09-15T23:08:37.118Z",
    "user": 1,
    "content_type": 7,
    "object_id": "1",
    "object_repr": "If-Else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 37,
  "fields": {
    "action_time": "2024-09-15T23:23:48.299Z",
    "user": 1,
    "content_type": 11,
    "object_id": "1",
    "object_repr": "Логические операции",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 38,
  "fields": {
    "action_time": "2024-09-15T23:25:25.436Z",
    "user": 1,
    "content_type": 11,
    "object_id": "1",
    "object_repr": "Логические операции",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 39,
  "fields": {
    "action_time": "2024-09-15T23:26:46.365Z",
    "user": 1,
    "content_type": 11,
    "object_id": "2",
    "object_repr": "Каскадные условия",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u041f\\u043e\\u0434\\u0442\\u0435\\u043c\\u0430\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 40,
  "fields": {
    "action_time": "2024-09-15T23:27:19.088Z",
    "user": 1,
    "content_type": 11,
    "object_id": "2",
    "object_repr": "Каскадные условия",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0421\\u043b\\u0430\\u0433\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 41,
  "fields": {
    "action_time": "2024-09-15T23:37:34.284Z",
    "user": 1,
    "content_type": 11,
    "object_id": "2",
    "object_repr": "Каскадные условия",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 42,
  "fields": {
    "action_time": "2024-09-15T23:38:57.252Z",
    "user": 1,
    "content_type": 11,
    "object_id": "2",
    "object_repr": "Каскадные условия",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 43,
  "fields": {
    "action_time": "2024-09-15T23:39:40.565Z",
    "user": 1,
    "content_type": 11,
    "object_id": "2",
    "object_repr": "Каскадные условия",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 44,
  "fields": {
    "action_time": "2024-09-15T23:40:16.813Z",
    "user": 1,
    "content_type": 11,
    "object_id": "2",
    "object_repr": "Каскадные условия",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 45,
  "fields": {
    "action_time": "2024-09-15T23:41:39.769Z",
    "user": 1,
    "content_type": 11,
    "object_id": "2",
    "object_repr": "Каскадные условия",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 46,
  "fields": {
    "action_time": "2024-09-15T23:42:46.422Z",
    "user": 1,
    "content_type": 11,
    "object_id": "2",
    "object_repr": "Каскадные условия",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 47,
  "fields": {
    "action_time": "2024-09-15T23:43:41.053Z",
    "user": 1,
    "content_type": 11,
    "object_id": "2",
    "object_repr": "Каскадные условия",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 48,
  "fields": {
    "action_time": "2024-09-15T23:46:13.498Z",
    "user": 1,
    "content_type": 7,
    "object_id": "2",
    "object_repr": "For",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 49,
  "fields": {
    "action_time": "2024-09-15T23:55:32.538Z",
    "user": 1,
    "content_type": 7,
    "object_id": "2",
    "object_repr": "For",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 50,
  "fields": {
    "action_time": "2024-09-15T23:56:08.159Z",
    "user": 1,
    "content_type": 7,
    "object_id": "2",
    "object_repr": "For",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 51,
  "fields": {
    "action_time": "2024-09-15T23:57:36.176Z",
    "user": 1,
    "content_type": 7,
    "object_id": "2",
    "object_repr": "For",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 52,
  "fields": {
    "action_time": "2024-09-15T23:58:07.756Z",
    "user": 1,
    "content_type": 7,
    "object_id": "2",
    "object_repr": "For",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 53,
  "fields": {
    "action_time": "2024-09-15T23:58:58.393Z",
    "user": 1,
    "content_type": 7,
    "object_id": "2",
    "object_repr": "For",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 54,
  "fields": {
    "action_time": "2024-09-15T23:59:28.963Z",
    "user": 1,
    "content_type": 7,
    "object_id": "2",
    "object_repr": "For",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 55,
  "fields": {
    "action_time": "2024-09-15T23:59:53.058Z",
    "user": 1,
    "content_type": 7,
    "object_id": "2",
    "object_repr": "For",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 56,
  "fields": {
    "action_time": "2024-09-16T00:00:59.410Z",
    "user": 1,
    "content_type": 7,
    "object_id": "2",
    "object_repr": "For",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 57,
  "fields": {
    "action_time": "2024-09-16T00:12:54.696Z",
    "user": 1,
    "content_type": 7,
    "object_id": "2",
    "object_repr": "For",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 58,
  "fields": {
    "action_time": "2024-09-16T00:14:10.229Z",
    "user": 1,
    "content_type": 7,
    "object_id": "2",
    "object_repr": "For",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 59,
  "fields": {
    "action_time": "2024-09-16T00:27:24.499Z",
    "user": 1,
    "content_type": 11,
    "object_id": "4",
    "object_repr": "Цикл for: функция range",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 60,
  "fields": {
    "action_time": "2024-09-16T00:29:14.562Z",
    "user": 1,
    "content_type": 11,
    "object_id": "5",
    "object_repr": "частые сценарии",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 61,
  "fields": {
    "action_time": "2024-09-16T00:47:19.535Z",
    "user": 1,
    "content_type": 11,
    "object_id": "4",
    "object_repr": "Цикл for: функция range",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 62,
  "fields": {
    "action_time": "2024-09-16T00:48:42.628Z",
    "user": 1,
    "content_type": 11,
    "object_id": "4",
    "object_repr": "Цикл for: функция range",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 63,
  "fields": {
    "action_time": "2024-09-16T00:49:54.556Z",
    "user": 1,
    "content_type": 11,
    "object_id": "4",
    "object_repr": "Цикл for: функция range",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 64,
  "fields": {
    "action_time": "2024-09-16T00:50:20.599Z",
    "user": 1,
    "content_type": 11,
    "object_id": "4",
    "object_repr": "Цикл for: функция range",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 65,
  "fields": {
    "action_time": "2024-09-16T00:51:22.570Z",
    "user": 1,
    "content_type": 11,
    "object_id": "4",
    "object_repr": "Цикл for: функция range",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 66,
  "fields": {
    "action_time": "2024-09-16T00:51:51.437Z",
    "user": 1,
    "content_type": 11,
    "object_id": "4",
    "object_repr": "Цикл for: функция range",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 67,
  "fields": {
    "action_time": "2024-09-16T00:53:04.604Z",
    "user": 1,
    "content_type": 11,
    "object_id": "4",
    "object_repr": "Цикл for: функция range",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 68,
  "fields": {
    "action_time": "2024-09-16T01:08:11.184Z",
    "user": 1,
    "content_type": 11,
    "object_id": "5",
    "object_repr": "Частые сценарии",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 69,
  "fields": {
    "action_time": "2024-09-16T01:09:07.087Z",
    "user": 1,
    "content_type": 11,
    "object_id": "5",
    "object_repr": "Частые сценарии",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 70,
  "fields": {
    "action_time": "2024-09-16T01:09:51.330Z",
    "user": 1,
    "content_type": 11,
    "object_id": "5",
    "object_repr": "Частые сценарии",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 71,
  "fields": {
    "action_time": "2024-09-16T01:19:55.475Z",
    "user": 1,
    "content_type": 11,
    "object_id": "3",
    "object_repr": "Вложенные циклы",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 72,
  "fields": {
    "action_time": "2024-09-16T01:20:42.377Z",
    "user": 1,
    "content_type": 11,
    "object_id": "3",
    "object_repr": "Вложенные циклы",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 73,
  "fields": {
    "action_time": "2024-09-16T01:21:12.995Z",
    "user": 1,
    "content_type": 11,
    "object_id": "3",
    "object_repr": "Вложенные циклы",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 74,
  "fields": {
    "action_time": "2024-09-16T01:22:27.312Z",
    "user": 1,
    "content_type": 11,
    "object_id": "5",
    "object_repr": "Частые сценарии",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 75,
  "fields": {
    "action_time": "2024-09-16T01:23:32.772Z",
    "user": 1,
    "content_type": 11,
    "object_id": "5",
    "object_repr": "Частые сценарии",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 76,
  "fields": {
    "action_time": "2024-09-16T01:37:13.379Z",
    "user": 1,
    "content_type": 7,
    "object_id": "3",
    "object_repr": "While",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 77,
  "fields": {
    "action_time": "2024-09-16T01:37:29.608Z",
    "user": 1,
    "content_type": 7,
    "object_id": "3",
    "object_repr": "While",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 78,
  "fields": {
    "action_time": "2024-09-16T01:38:06.856Z",
    "user": 1,
    "content_type": 7,
    "object_id": "3",
    "object_repr": "While",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 79,
  "fields": {
    "action_time": "2024-09-16T01:40:13.057Z",
    "user": 1,
    "content_type": 11,
    "object_id": "6",
    "object_repr": "Цикл while: обработка цифр числа",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 80,
  "fields": {
    "action_time": "2024-09-16T01:42:18.984Z",
    "user": 1,
    "content_type": 11,
    "object_id": "7",
    "object_repr": "Break, continue и else",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 81,
  "fields": {
    "action_time": "2024-09-16T01:43:11.265Z",
    "user": 1,
    "content_type": 11,
    "object_id": "8",
    "object_repr": "Блок else в циклах",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 82,
  "fields": {
    "action_time": "2024-09-16T02:01:39.241Z",
    "user": 1,
    "content_type": 11,
    "object_id": "6",
    "object_repr": "Цикл while: обработка цифр числа",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 83,
  "fields": {
    "action_time": "2024-09-16T02:01:54.365Z",
    "user": 1,
    "content_type": 11,
    "object_id": "6",
    "object_repr": "Цикл while: обработка цифр числа",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 84,
  "fields": {
    "action_time": "2024-09-16T02:07:16.114Z",
    "user": 1,
    "content_type": 11,
    "object_id": "7",
    "object_repr": "Break, continue и else",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 85,
  "fields": {
    "action_time": "2024-09-16T02:12:02.765Z",
    "user": 1,
    "content_type": 11,
    "object_id": "8",
    "object_repr": "Блок else в циклах",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 86,
  "fields": {
    "action_time": "2024-09-16T02:15:39.846Z",
    "user": 1,
    "content_type": 11,
    "object_id": "9",
    "object_repr": "Числовые типы данных",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 87,
  "fields": {
    "action_time": "2024-09-16T02:17:26.094Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 88,
  "fields": {
    "action_time": "2024-09-16T02:18:09.091Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 89,
  "fields": {
    "action_time": "2024-09-16T02:18:45.927Z",
    "user": 1,
    "content_type": 11,
    "object_id": "12",
    "object_repr": "Словари",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 90,
  "fields": {
    "action_time": "2024-09-16T02:19:18.153Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 91,
  "fields": {
    "action_time": "2024-09-16T02:19:45.563Z",
    "user": 1,
    "content_type": 11,
    "object_id": "14",
    "object_repr": "Кортежи",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 92,
  "fields": {
    "action_time": "2024-09-16T02:20:32.159Z",
    "user": 1,
    "content_type": 11,
    "object_id": "15",
    "object_repr": "NoneType",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 93,
  "fields": {
    "action_time": "2024-09-16T02:21:43.252Z",
    "user": 1,
    "content_type": 11,
    "object_id": "16",
    "object_repr": "Bool",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 94,
  "fields": {
    "action_time": "2024-09-16T02:22:23.730Z",
    "user": 1,
    "content_type": 7,
    "object_id": "4",
    "object_repr": "Типы данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Sub lesson\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 95,
  "fields": {
    "action_time": "2024-09-16T02:26:23.421Z",
    "user": 1,
    "content_type": 11,
    "object_id": "17",
    "object_repr": "Встроенные функции",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 96,
  "fields": {
    "action_time": "2024-09-16T02:27:28.730Z",
    "user": 1,
    "content_type": 11,
    "object_id": "18",
    "object_repr": "Функции высшего порядка",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 97,
  "fields": {
    "action_time": "2024-09-16T02:28:06.498Z",
    "user": 1,
    "content_type": 11,
    "object_id": "19",
    "object_repr": "Lamda функции",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 98,
  "fields": {
    "action_time": "2024-09-16T02:28:46.394Z",
    "user": 1,
    "content_type": 11,
    "object_id": "20",
    "object_repr": "Функции как объекты",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 99,
  "fields": {
    "action_time": "2024-09-16T02:29:41.285Z",
    "user": 1,
    "content_type": 11,
    "object_id": "21",
    "object_repr": "Вложенные функции, замыкания",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 100,
  "fields": {
    "action_time": "2024-09-16T02:30:30.352Z",
    "user": 1,
    "content_type": 11,
    "object_id": "22",
    "object_repr": "Аннотации типов",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 101,
  "fields": {
    "action_time": "2024-09-16T02:31:13.582Z",
    "user": 1,
    "content_type": 11,
    "object_id": "23",
    "object_repr": "Декораторы",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 102,
  "fields": {
    "action_time": "2024-09-16T02:31:43.326Z",
    "user": 1,
    "content_type": 7,
    "object_id": "5",
    "object_repr": "Функции",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Sub lesson\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 103,
  "fields": {
    "action_time": "2024-09-18T03:03:01.977Z",
    "user": 1,
    "content_type": 11,
    "object_id": "9",
    "object_repr": "Числовые типы данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 104,
  "fields": {
    "action_time": "2024-09-18T03:04:16.878Z",
    "user": 1,
    "content_type": 11,
    "object_id": "9",
    "object_repr": "Числовые типы данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 105,
  "fields": {
    "action_time": "2024-09-18T03:12:26.927Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 106,
  "fields": {
    "action_time": "2024-09-18T03:12:52.816Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 107,
  "fields": {
    "action_time": "2024-09-18T03:13:42.018Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 108,
  "fields": {
    "action_time": "2024-09-18T03:14:02.682Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 109,
  "fields": {
    "action_time": "2024-09-18T03:18:01.668Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 110,
  "fields": {
    "action_time": "2024-09-18T03:18:33.972Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 111,
  "fields": {
    "action_time": "2024-09-18T03:19:24.413Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 112,
  "fields": {
    "action_time": "2024-09-18T03:20:21.848Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 113,
  "fields": {
    "action_time": "2024-09-18T03:20:59.699Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 114,
  "fields": {
    "action_time": "2024-09-18T03:24:41.611Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 115,
  "fields": {
    "action_time": "2024-09-18T03:25:08.109Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 116,
  "fields": {
    "action_time": "2024-09-18T03:27:12.279Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 117,
  "fields": {
    "action_time": "2024-09-18T03:27:53.457Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 118,
  "fields": {
    "action_time": "2024-09-18T03:29:05.205Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 119,
  "fields": {
    "action_time": "2024-09-18T03:33:21.594Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 120,
  "fields": {
    "action_time": "2024-09-18T03:39:32.665Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 121,
  "fields": {
    "action_time": "2024-09-18T03:40:43.853Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 122,
  "fields": {
    "action_time": "2024-09-18T03:44:01.239Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 123,
  "fields": {
    "action_time": "2024-09-18T03:44:48.750Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 124,
  "fields": {
    "action_time": "2024-09-18T03:48:08.985Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 125,
  "fields": {
    "action_time": "2024-09-18T03:49:39.759Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 126,
  "fields": {
    "action_time": "2024-09-18T03:53:32.813Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 127,
  "fields": {
    "action_time": "2024-09-18T03:55:15.369Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 128,
  "fields": {
    "action_time": "2024-09-18T03:57:35.489Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 129,
  "fields": {
    "action_time": "2024-09-18T04:00:45.342Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 130,
  "fields": {
    "action_time": "2024-09-18T04:01:14.094Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 131,
  "fields": {
    "action_time": "2024-09-18T04:03:47.019Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 132,
  "fields": {
    "action_time": "2024-09-18T04:06:08.374Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 133,
  "fields": {
    "action_time": "2024-09-18T04:07:14.440Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 134,
  "fields": {
    "action_time": "2024-09-18T04:08:24.808Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 135,
  "fields": {
    "action_time": "2024-09-18T04:10:06.686Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 136,
  "fields": {
    "action_time": "2024-09-18T04:11:25.372Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 137,
  "fields": {
    "action_time": "2024-09-18T04:13:03.218Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 138,
  "fields": {
    "action_time": "2024-09-18T04:16:11.463Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 139,
  "fields": {
    "action_time": "2024-09-18T04:26:35.684Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 140,
  "fields": {
    "action_time": "2024-09-18T04:28:48.930Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 141,
  "fields": {
    "action_time": "2024-09-18T04:29:33.497Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 142,
  "fields": {
    "action_time": "2024-09-18T04:40:43.002Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 143,
  "fields": {
    "action_time": "2024-09-18T04:41:53.927Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 144,
  "fields": {
    "action_time": "2024-09-18T04:44:05.365Z",
    "user": 1,
    "content_type": 11,
    "object_id": "10",
    "object_repr": "Строковый тип данных",
    "action_flag": 2,
    "change_message": "[]"
  }
},
{
  "model": "admin.logentry",
  "pk": 145,
  "fields": {
    "action_time": "2024-09-18T04:47:59.932Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 146,
  "fields": {
    "action_time": "2024-09-18T04:49:53.284Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 147,
  "fields": {
    "action_time": "2024-09-18T04:50:16.645Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 148,
  "fields": {
    "action_time": "2024-09-18T04:52:15.532Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 149,
  "fields": {
    "action_time": "2024-09-18T04:53:26.628Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 150,
  "fields": {
    "action_time": "2024-09-18T04:57:23.719Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 151,
  "fields": {
    "action_time": "2024-09-18T05:00:14.958Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 152,
  "fields": {
    "action_time": "2024-09-18T05:02:42.862Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 153,
  "fields": {
    "action_time": "2024-09-18T05:04:22.604Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 154,
  "fields": {
    "action_time": "2024-09-18T05:07:23.098Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 155,
  "fields": {
    "action_time": "2024-09-18T05:09:07.960Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 156,
  "fields": {
    "action_time": "2024-09-18T05:09:24.651Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 157,
  "fields": {
    "action_time": "2024-09-18T06:07:51.800Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 158,
  "fields": {
    "action_time": "2024-09-18T06:08:07.982Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 159,
  "fields": {
    "action_time": "2024-09-18T06:11:18.244Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 160,
  "fields": {
    "action_time": "2024-09-18T06:11:44.957Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 161,
  "fields": {
    "action_time": "2024-09-18T06:13:54.939Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 162,
  "fields": {
    "action_time": "2024-09-18T06:17:05.415Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 163,
  "fields": {
    "action_time": "2024-09-18T06:17:37.037Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 164,
  "fields": {
    "action_time": "2024-09-18T06:19:19.302Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 165,
  "fields": {
    "action_time": "2024-09-18T06:20:49.900Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 166,
  "fields": {
    "action_time": "2024-09-18T06:21:57.683Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 167,
  "fields": {
    "action_time": "2024-09-18T06:23:33.854Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 168,
  "fields": {
    "action_time": "2024-09-18T06:24:42.579Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 169,
  "fields": {
    "action_time": "2024-09-18T06:25:37.054Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 170,
  "fields": {
    "action_time": "2024-09-18T06:26:49.445Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 171,
  "fields": {
    "action_time": "2024-09-18T06:28:56.129Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 172,
  "fields": {
    "action_time": "2024-09-18T06:29:21.592Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 173,
  "fields": {
    "action_time": "2024-09-18T06:30:11.474Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 174,
  "fields": {
    "action_time": "2024-09-18T06:32:43.014Z",
    "user": 1,
    "content_type": 11,
    "object_id": "11",
    "object_repr": "Списки",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 175,
  "fields": {
    "action_time": "2024-09-18T06:49:31.631Z",
    "user": 1,
    "content_type": 11,
    "object_id": "16",
    "object_repr": "Bool",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 176,
  "fields": {
    "action_time": "2024-09-18T06:57:24.518Z",
    "user": 1,
    "content_type": 11,
    "object_id": "15",
    "object_repr": "NoneType",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 177,
  "fields": {
    "action_time": "2024-09-18T06:58:05.524Z",
    "user": 1,
    "content_type": 11,
    "object_id": "15",
    "object_repr": "NoneType",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 178,
  "fields": {
    "action_time": "2024-09-18T22:37:38.489Z",
    "user": 1,
    "content_type": 11,
    "object_id": "12",
    "object_repr": "Словари",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 179,
  "fields": {
    "action_time": "2024-09-18T22:38:39.905Z",
    "user": 1,
    "content_type": 11,
    "object_id": "12",
    "object_repr": "Словари",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 180,
  "fields": {
    "action_time": "2024-09-18T22:45:21.923Z",
    "user": 1,
    "content_type": 11,
    "object_id": "12",
    "object_repr": "Словари",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 181,
  "fields": {
    "action_time": "2024-09-18T22:46:06.625Z",
    "user": 1,
    "content_type": 11,
    "object_id": "12",
    "object_repr": "Словари",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 182,
  "fields": {
    "action_time": "2024-09-18T22:47:45.381Z",
    "user": 1,
    "content_type": 11,
    "object_id": "12",
    "object_repr": "Словари",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 183,
  "fields": {
    "action_time": "2024-09-18T22:49:04.408Z",
    "user": 1,
    "content_type": 11,
    "object_id": "12",
    "object_repr": "Словари",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 184,
  "fields": {
    "action_time": "2024-09-18T22:49:30.663Z",
    "user": 1,
    "content_type": 11,
    "object_id": "12",
    "object_repr": "Словари",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 185,
  "fields": {
    "action_time": "2024-09-18T22:53:45.242Z",
    "user": 1,
    "content_type": 11,
    "object_id": "12",
    "object_repr": "Словари",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 186,
  "fields": {
    "action_time": "2024-09-18T22:56:27.721Z",
    "user": 1,
    "content_type": 11,
    "object_id": "12",
    "object_repr": "Словари",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 187,
  "fields": {
    "action_time": "2024-09-18T22:57:34.977Z",
    "user": 1,
    "content_type": 11,
    "object_id": "12",
    "object_repr": "Словари",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 188,
  "fields": {
    "action_time": "2024-09-18T22:59:09.114Z",
    "user": 1,
    "content_type": 11,
    "object_id": "12",
    "object_repr": "Словари",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 189,
  "fields": {
    "action_time": "2024-09-18T23:03:14.353Z",
    "user": 1,
    "content_type": 11,
    "object_id": "12",
    "object_repr": "Словари",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 190,
  "fields": {
    "action_time": "2024-09-18T23:04:35.284Z",
    "user": 1,
    "content_type": 11,
    "object_id": "12",
    "object_repr": "Словари",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 191,
  "fields": {
    "action_time": "2024-09-18T23:06:10.179Z",
    "user": 1,
    "content_type": 11,
    "object_id": "12",
    "object_repr": "Словари",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 192,
  "fields": {
    "action_time": "2024-09-18T23:07:31.900Z",
    "user": 1,
    "content_type": 11,
    "object_id": "12",
    "object_repr": "Словари",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 193,
  "fields": {
    "action_time": "2024-09-18T23:07:53.508Z",
    "user": 1,
    "content_type": 11,
    "object_id": "12",
    "object_repr": "Словари",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 194,
  "fields": {
    "action_time": "2024-09-18T23:08:53.638Z",
    "user": 1,
    "content_type": 11,
    "object_id": "12",
    "object_repr": "Словари",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 195,
  "fields": {
    "action_time": "2024-09-18T23:10:06.446Z",
    "user": 1,
    "content_type": 11,
    "object_id": "12",
    "object_repr": "Словари",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 196,
  "fields": {
    "action_time": "2024-09-18T23:13:42.920Z",
    "user": 1,
    "content_type": 11,
    "object_id": "12",
    "object_repr": "Словари",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 197,
  "fields": {
    "action_time": "2024-09-18T23:20:18.242Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 198,
  "fields": {
    "action_time": "2024-09-18T23:22:26.458Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 199,
  "fields": {
    "action_time": "2024-09-18T23:22:39.431Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 200,
  "fields": {
    "action_time": "2024-09-18T23:23:39.699Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 201,
  "fields": {
    "action_time": "2024-09-18T23:23:58.566Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 202,
  "fields": {
    "action_time": "2024-09-18T23:25:44.512Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 203,
  "fields": {
    "action_time": "2024-09-18T23:27:32.755Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 204,
  "fields": {
    "action_time": "2024-09-18T23:28:53.725Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 205,
  "fields": {
    "action_time": "2024-09-18T23:30:23.976Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 206,
  "fields": {
    "action_time": "2024-09-18T23:30:49.361Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 207,
  "fields": {
    "action_time": "2024-09-18T23:32:26.793Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 208,
  "fields": {
    "action_time": "2024-09-18T23:33:28.317Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 209,
  "fields": {
    "action_time": "2024-09-18T23:33:51.467Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 210,
  "fields": {
    "action_time": "2024-09-18T23:35:22.957Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 211,
  "fields": {
    "action_time": "2024-09-18T23:38:17.608Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 212,
  "fields": {
    "action_time": "2024-09-18T23:39:48.407Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 213,
  "fields": {
    "action_time": "2024-09-18T23:41:03.008Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 214,
  "fields": {
    "action_time": "2024-09-18T23:42:25.196Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 215,
  "fields": {
    "action_time": "2024-09-18T23:44:01.744Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 216,
  "fields": {
    "action_time": "2024-09-18T23:46:06.296Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 217,
  "fields": {
    "action_time": "2024-09-18T23:47:04.108Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 218,
  "fields": {
    "action_time": "2024-09-18T23:48:42.061Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 219,
  "fields": {
    "action_time": "2024-09-18T23:49:40.517Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 220,
  "fields": {
    "action_time": "2024-09-18T23:51:41.416Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 221,
  "fields": {
    "action_time": "2024-09-18T23:52:25.645Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 222,
  "fields": {
    "action_time": "2024-09-19T00:05:18.829Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 223,
  "fields": {
    "action_time": "2024-09-19T00:06:33.923Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 224,
  "fields": {
    "action_time": "2024-09-19T00:09:10.877Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 225,
  "fields": {
    "action_time": "2024-09-19T00:10:52.203Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 226,
  "fields": {
    "action_time": "2024-09-19T00:12:09.582Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 227,
  "fields": {
    "action_time": "2024-09-19T00:12:39.759Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 228,
  "fields": {
    "action_time": "2024-09-19T00:15:13.215Z",
    "user": 1,
    "content_type": 11,
    "object_id": "13",
    "object_repr": "Множества",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 229,
  "fields": {
    "action_time": "2024-09-19T00:19:18.235Z",
    "user": 1,
    "content_type": 11,
    "object_id": "14",
    "object_repr": "Кортежи",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 230,
  "fields": {
    "action_time": "2024-09-19T00:21:00.411Z",
    "user": 1,
    "content_type": 11,
    "object_id": "14",
    "object_repr": "Кортежи",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 231,
  "fields": {
    "action_time": "2024-09-19T00:22:30.088Z",
    "user": 1,
    "content_type": 11,
    "object_id": "14",
    "object_repr": "Кортежи",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 232,
  "fields": {
    "action_time": "2024-09-19T00:22:50.513Z",
    "user": 1,
    "content_type": 11,
    "object_id": "14",
    "object_repr": "Кортежи",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 233,
  "fields": {
    "action_time": "2024-09-19T00:24:26.570Z",
    "user": 1,
    "content_type": 11,
    "object_id": "14",
    "object_repr": "Кортежи",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 234,
  "fields": {
    "action_time": "2024-09-19T00:27:23.207Z",
    "user": 1,
    "content_type": 11,
    "object_id": "14",
    "object_repr": "Кортежи",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 235,
  "fields": {
    "action_time": "2024-09-19T00:29:41.224Z",
    "user": 1,
    "content_type": 11,
    "object_id": "14",
    "object_repr": "Кортежи",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 236,
  "fields": {
    "action_time": "2024-09-19T00:34:20.461Z",
    "user": 1,
    "content_type": 11,
    "object_id": "14",
    "object_repr": "Кортежи",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 237,
  "fields": {
    "action_time": "2024-09-19T00:37:22.055Z",
    "user": 1,
    "content_type": 11,
    "object_id": "14",
    "object_repr": "Кортежи",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 238,
  "fields": {
    "action_time": "2024-09-19T00:38:03.717Z",
    "user": 1,
    "content_type": 11,
    "object_id": "14",
    "object_repr": "Кортежи",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 239,
  "fields": {
    "action_time": "2024-09-19T00:39:43.469Z",
    "user": 1,
    "content_type": 11,
    "object_id": "14",
    "object_repr": "Кортежи",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 240,
  "fields": {
    "action_time": "2024-09-19T00:42:31.262Z",
    "user": 1,
    "content_type": 11,
    "object_id": "14",
    "object_repr": "Кортежи",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 241,
  "fields": {
    "action_time": "2024-09-19T00:45:39.535Z",
    "user": 1,
    "content_type": 11,
    "object_id": "14",
    "object_repr": "Кортежи",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 242,
  "fields": {
    "action_time": "2024-09-19T00:47:48.591Z",
    "user": 1,
    "content_type": 11,
    "object_id": "14",
    "object_repr": "Кортежи",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 243,
  "fields": {
    "action_time": "2024-09-19T01:07:14.728Z",
    "user": 1,
    "content_type": 11,
    "object_id": "17",
    "object_repr": "Встроенные функции",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 244,
  "fields": {
    "action_time": "2024-09-19T01:08:06.166Z",
    "user": 1,
    "content_type": 11,
    "object_id": "17",
    "object_repr": "Встроенные функции",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 245,
  "fields": {
    "action_time": "2024-09-23T21:47:10.422Z",
    "user": 1,
    "content_type": 7,
    "object_id": "4",
    "object_repr": "Типы данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 246,
  "fields": {
    "action_time": "2024-09-23T21:48:55.322Z",
    "user": 1,
    "content_type": 7,
    "object_id": "4",
    "object_repr": "Типы данных",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 247,
  "fields": {
    "action_time": "2024-09-23T22:12:35.110Z",
    "user": 1,
    "content_type": 11,
    "object_id": "17",
    "object_repr": "Встроенные функции",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 248,
  "fields": {
    "action_time": "2024-09-23T22:16:32.385Z",
    "user": 1,
    "content_type": 11,
    "object_id": "17",
    "object_repr": "Встроенные функции",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 249,
  "fields": {
    "action_time": "2024-09-23T22:22:29.257Z",
    "user": 1,
    "content_type": 7,
    "object_id": "5",
    "object_repr": "Функции",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 250,
  "fields": {
    "action_time": "2024-09-23T22:27:41.594Z",
    "user": 1,
    "content_type": 11,
    "object_id": "19",
    "object_repr": "Lamda функции",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 251,
  "fields": {
    "action_time": "2024-09-23T22:36:56.391Z",
    "user": 1,
    "content_type": 11,
    "object_id": "18",
    "object_repr": "Функции высшего порядка",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 252,
  "fields": {
    "action_time": "2024-09-23T22:45:35.154Z",
    "user": 1,
    "content_type": 11,
    "object_id": "20",
    "object_repr": "Функции как объекты",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 253,
  "fields": {
    "action_time": "2024-09-23T22:49:09.628Z",
    "user": 1,
    "content_type": 11,
    "object_id": "20",
    "object_repr": "Функции как объекты",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 254,
  "fields": {
    "action_time": "2024-09-23T22:52:10.553Z",
    "user": 1,
    "content_type": 11,
    "object_id": "20",
    "object_repr": "Функции как объекты",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 255,
  "fields": {
    "action_time": "2024-09-23T23:10:22.875Z",
    "user": 1,
    "content_type": 11,
    "object_id": "21",
    "object_repr": "Вложенные функции, замыкания",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 256,
  "fields": {
    "action_time": "2024-09-23T23:31:15.095Z",
    "user": 1,
    "content_type": 11,
    "object_id": "21",
    "object_repr": "Вложенные функции, замыкания",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 257,
  "fields": {
    "action_time": "2024-09-23T23:45:15.156Z",
    "user": 1,
    "content_type": 11,
    "object_id": "22",
    "object_repr": "Аннотации типов",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 258,
  "fields": {
    "action_time": "2024-09-24T00:00:24.252Z",
    "user": 1,
    "content_type": 11,
    "object_id": "23",
    "object_repr": "Декораторы",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 259,
  "fields": {
    "action_time": "2024-09-24T00:05:53.001Z",
    "user": 1,
    "content_type": 11,
    "object_id": "23",
    "object_repr": "Декораторы",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 260,
  "fields": {
    "action_time": "2024-09-24T00:11:45.786Z",
    "user": 1,
    "content_type": 7,
    "object_id": "8",
    "object_repr": "Дата и Время",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 261,
  "fields": {
    "action_time": "2024-09-24T00:12:33.120Z",
    "user": 1,
    "content_type": 7,
    "object_id": "8",
    "object_repr": "Дата и Время",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 262,
  "fields": {
    "action_time": "2024-09-24T00:14:03.801Z",
    "user": 1,
    "content_type": 7,
    "object_id": "8",
    "object_repr": "Дата и Время",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 263,
  "fields": {
    "action_time": "2024-09-24T00:16:34.994Z",
    "user": 1,
    "content_type": 11,
    "object_id": "24",
    "object_repr": "Типы данных date и time",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 264,
  "fields": {
    "action_time": "2024-09-24T00:16:51.119Z",
    "user": 1,
    "content_type": 7,
    "object_id": "8",
    "object_repr": "Дата и Время",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Sub lesson\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 265,
  "fields": {
    "action_time": "2024-09-24T00:17:37.703Z",
    "user": 1,
    "content_type": 11,
    "object_id": "25",
    "object_repr": "Форматирование даты и времени",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 266,
  "fields": {
    "action_time": "2024-09-24T00:18:20.443Z",
    "user": 1,
    "content_type": 11,
    "object_id": "26",
    "object_repr": "Тип данных datetime",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 267,
  "fields": {
    "action_time": "2024-09-24T00:18:43.881Z",
    "user": 1,
    "content_type": 11,
    "object_id": "27",
    "object_repr": "Тип данных timedelta",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 268,
  "fields": {
    "action_time": "2024-09-24T00:19:19.830Z",
    "user": 1,
    "content_type": 11,
    "object_id": "28",
    "object_repr": "Модуль time",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 269,
  "fields": {
    "action_time": "2024-09-24T00:19:43.941Z",
    "user": 1,
    "content_type": 11,
    "object_id": "29",
    "object_repr": "Модуль calendar",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 270,
  "fields": {
    "action_time": "2024-09-24T00:20:03.365Z",
    "user": 1,
    "content_type": 7,
    "object_id": "8",
    "object_repr": "Дата и Время",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Sub lesson\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 271,
  "fields": {
    "action_time": "2024-09-24T00:30:01.735Z",
    "user": 1,
    "content_type": 7,
    "object_id": "7",
    "object_repr": "Файлы",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 272,
  "fields": {
    "action_time": "2024-09-24T00:30:30.165Z",
    "user": 1,
    "content_type": 7,
    "object_id": "7",
    "object_repr": "Файлы",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 273,
  "fields": {
    "action_time": "2024-09-24T00:31:08.909Z",
    "user": 1,
    "content_type": 7,
    "object_id": "7",
    "object_repr": "Файлы",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 274,
  "fields": {
    "action_time": "2024-09-24T00:32:52.433Z",
    "user": 1,
    "content_type": 11,
    "object_id": "30",
    "object_repr": "Работа с файлами",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 275,
  "fields": {
    "action_time": "2024-09-24T00:33:46.108Z",
    "user": 1,
    "content_type": 11,
    "object_id": "31",
    "object_repr": "Потоковый ввод stdin и вывод stdout",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 276,
  "fields": {
    "action_time": "2024-09-24T00:34:13.237Z",
    "user": 1,
    "content_type": 11,
    "object_id": "32",
    "object_repr": "Работа с csv файлами",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 277,
  "fields": {
    "action_time": "2024-09-24T00:34:37.629Z",
    "user": 1,
    "content_type": 11,
    "object_id": "33",
    "object_repr": "Работа с json файлами",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 278,
  "fields": {
    "action_time": "2024-09-24T00:34:59.767Z",
    "user": 1,
    "content_type": 11,
    "object_id": "34",
    "object_repr": "Работа с zip файлами",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 279,
  "fields": {
    "action_time": "2024-09-24T00:35:29.231Z",
    "user": 1,
    "content_type": 11,
    "object_id": "35",
    "object_repr": "Работа с pickle файлами",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 280,
  "fields": {
    "action_time": "2024-09-24T00:36:10.022Z",
    "user": 1,
    "content_type": 11,
    "object_id": "36",
    "object_repr": "Модуль Os",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 281,
  "fields": {
    "action_time": "2024-09-24T00:36:38.891Z",
    "user": 1,
    "content_type": 7,
    "object_id": "7",
    "object_repr": "Файлы",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Sub lesson\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 282,
  "fields": {
    "action_time": "2024-09-24T00:45:43.627Z",
    "user": 1,
    "content_type": 7,
    "object_id": "9",
    "object_repr": "Устройство памяти",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 283,
  "fields": {
    "action_time": "2024-09-24T00:46:21.060Z",
    "user": 1,
    "content_type": 7,
    "object_id": "9",
    "object_repr": "Устройство памяти",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 284,
  "fields": {
    "action_time": "2024-09-24T00:47:30.885Z",
    "user": 1,
    "content_type": 11,
    "object_id": "37",
    "object_repr": "Механизм памяти в Python",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 285,
  "fields": {
    "action_time": "2024-09-24T00:48:31.552Z",
    "user": 1,
    "content_type": 11,
    "object_id": "38",
    "object_repr": "Работа переменных в Python",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 286,
  "fields": {
    "action_time": "2024-09-24T00:49:14.721Z",
    "user": 1,
    "content_type": 11,
    "object_id": "39",
    "object_repr": "изменяемые и неизменяемые типы",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 287,
  "fields": {
    "action_time": "2024-09-24T00:50:02.575Z",
    "user": 1,
    "content_type": 11,
    "object_id": "40",
    "object_repr": "Поверхностное и глубокое копирование",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 288,
  "fields": {
    "action_time": "2024-09-24T00:50:10.434Z",
    "user": 1,
    "content_type": 11,
    "object_id": "39",
    "object_repr": "Изменяемые и неизменяемые типы",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u041f\\u043e\\u0434\\u0442\\u0435\\u043c\\u0430\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 289,
  "fields": {
    "action_time": "2024-09-24T00:50:50.964Z",
    "user": 1,
    "content_type": 11,
    "object_id": "41",
    "object_repr": "Механизмы очистки памяти",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 290,
  "fields": {
    "action_time": "2024-09-24T00:51:41.943Z",
    "user": 1,
    "content_type": 7,
    "object_id": "9",
    "object_repr": "Устройство памяти",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Sub lesson\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 291,
  "fields": {
    "action_time": "2024-09-24T01:00:06.586Z",
    "user": 1,
    "content_type": 7,
    "object_id": "10",
    "object_repr": "Обработка исключений",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 292,
  "fields": {
    "action_time": "2024-09-24T01:00:38.426Z",
    "user": 1,
    "content_type": 7,
    "object_id": "10",
    "object_repr": "Обработка исключений",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 293,
  "fields": {
    "action_time": "2024-09-24T01:01:42.536Z",
    "user": 1,
    "content_type": 11,
    "object_id": "42",
    "object_repr": "Конструкция try-except",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 294,
  "fields": {
    "action_time": "2024-09-24T01:02:30.983Z",
    "user": 1,
    "content_type": 11,
    "object_id": "43",
    "object_repr": "Необязательный блок else, finally",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 295,
  "fields": {
    "action_time": "2024-09-24T01:03:20.094Z",
    "user": 1,
    "content_type": 11,
    "object_id": "44",
    "object_repr": "Возбуждение исключений",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 296,
  "fields": {
    "action_time": "2024-09-24T01:04:21.605Z",
    "user": 1,
    "content_type": 11,
    "object_id": "45",
    "object_repr": "Пользовательские исключения",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 297,
  "fields": {
    "action_time": "2024-09-24T01:04:48.544Z",
    "user": 1,
    "content_type": 11,
    "object_id": "46",
    "object_repr": "Оператор assert",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 298,
  "fields": {
    "action_time": "2024-09-24T01:05:46.142Z",
    "user": 1,
    "content_type": 7,
    "object_id": "10",
    "object_repr": "Обработка исключений",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Sub lesson\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 299,
  "fields": {
    "action_time": "2024-09-24T01:25:04.429Z",
    "user": 1,
    "content_type": 7,
    "object_id": "11",
    "object_repr": "Рекурсия",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 300,
  "fields": {
    "action_time": "2024-09-24T01:26:15.553Z",
    "user": 1,
    "content_type": 11,
    "object_id": "47",
    "object_repr": "Рекурсивный обход коллекций",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 301,
  "fields": {
    "action_time": "2024-09-24T01:26:38.596Z",
    "user": 1,
    "content_type": 7,
    "object_id": "11",
    "object_repr": "Рекурсия",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Sub lesson\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 302,
  "fields": {
    "action_time": "2024-09-24T01:42:48.990Z",
    "user": 1,
    "content_type": 7,
    "object_id": "12",
    "object_repr": "Итераторы",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 303,
  "fields": {
    "action_time": "2024-09-24T01:43:39.362Z",
    "user": 1,
    "content_type": 7,
    "object_id": "12",
    "object_repr": "Итераторы",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 304,
  "fields": {
    "action_time": "2024-09-24T01:44:23.658Z",
    "user": 1,
    "content_type": 11,
    "object_id": "48",
    "object_repr": "Особенности итераторов",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 305,
  "fields": {
    "action_time": "2024-09-24T01:45:26.414Z",
    "user": 1,
    "content_type": 11,
    "object_id": "49",
    "object_repr": "Протокол итерируемых объектов и итераторов",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 306,
  "fields": {
    "action_time": "2024-09-24T01:46:07.136Z",
    "user": 1,
    "content_type": 7,
    "object_id": "12",
    "object_repr": "Итераторы",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Sub lesson\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 307,
  "fields": {
    "action_time": "2024-09-24T01:47:11.929Z",
    "user": 1,
    "content_type": 11,
    "object_id": "50",
    "object_repr": "Модуль itertools",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 308,
  "fields": {
    "action_time": "2024-09-24T01:47:24.934Z",
    "user": 1,
    "content_type": 7,
    "object_id": "12",
    "object_repr": "Итераторы",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Sub lesson\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 309,
  "fields": {
    "action_time": "2024-09-24T01:58:37.067Z",
    "user": 1,
    "content_type": 7,
    "object_id": "13",
    "object_repr": "Генераторы",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 310,
  "fields": {
    "action_time": "2024-09-24T01:59:40.167Z",
    "user": 1,
    "content_type": 11,
    "object_id": "51",
    "object_repr": "Конструкция yield from",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 311,
  "fields": {
    "action_time": "2024-09-24T02:00:13.649Z",
    "user": 1,
    "content_type": 11,
    "object_id": "52",
    "object_repr": "Генераторные выражения",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 312,
  "fields": {
    "action_time": "2024-09-24T02:00:45.749Z",
    "user": 1,
    "content_type": 11,
    "object_id": "53",
    "object_repr": "Конвейеры генераторов",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 313,
  "fields": {
    "action_time": "2024-09-24T02:01:07.481Z",
    "user": 1,
    "content_type": 7,
    "object_id": "13",
    "object_repr": "Генераторы",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Sub lesson\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 314,
  "fields": {
    "action_time": "2024-09-24T02:04:51.310Z",
    "user": 1,
    "content_type": 7,
    "object_id": "14",
    "object_repr": "Регулярные выражения",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 315,
  "fields": {
    "action_time": "2024-09-24T02:06:28.417Z",
    "user": 1,
    "content_type": 11,
    "object_id": "54",
    "object_repr": "Поиск символов",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 316,
  "fields": {
    "action_time": "2024-09-24T02:07:28.494Z",
    "user": 1,
    "content_type": 11,
    "object_id": "55",
    "object_repr": "Соответствие одному из нескольких символов",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 317,
  "fields": {
    "action_time": "2024-09-24T02:07:57.798Z",
    "user": 1,
    "content_type": 11,
    "object_id": "56",
    "object_repr": "Повторение совпадений",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 318,
  "fields": {
    "action_time": "2024-09-24T02:08:26.472Z",
    "user": 1,
    "content_type": 11,
    "object_id": "57",
    "object_repr": "Использование границ",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 319,
  "fields": {
    "action_time": "2024-09-24T02:08:56.723Z",
    "user": 1,
    "content_type": 11,
    "object_id": "58",
    "object_repr": "Подвыражения",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 320,
  "fields": {
    "action_time": "2024-09-24T02:09:20.132Z",
    "user": 1,
    "content_type": 11,
    "object_id": "59",
    "object_repr": "Ссылки назад",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 321,
  "fields": {
    "action_time": "2024-09-24T02:09:51.218Z",
    "user": 1,
    "content_type": 11,
    "object_id": "60",
    "object_repr": "Модуль re",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 322,
  "fields": {
    "action_time": "2024-09-24T02:10:11.891Z",
    "user": 1,
    "content_type": 7,
    "object_id": "14",
    "object_repr": "Регулярные выражения",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Sub lesson\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 323,
  "fields": {
    "action_time": "2024-09-24T02:13:03.201Z",
    "user": 1,
    "content_type": 7,
    "object_id": "6",
    "object_repr": "Модули",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 324,
  "fields": {
    "action_time": "2024-09-24T02:14:27.072Z",
    "user": 1,
    "content_type": 11,
    "object_id": "61",
    "object_repr": "Модуль decimal",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 325,
  "fields": {
    "action_time": "2024-09-24T02:14:51.422Z",
    "user": 1,
    "content_type": 11,
    "object_id": "62",
    "object_repr": "Модуль math",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 326,
  "fields": {
    "action_time": "2024-09-24T02:15:20.964Z",
    "user": 1,
    "content_type": 11,
    "object_id": "63",
    "object_repr": "Модуль fractions",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 327,
  "fields": {
    "action_time": "2024-09-24T02:15:45.783Z",
    "user": 1,
    "content_type": 11,
    "object_id": "64",
    "object_repr": "Модуль random",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 328,
  "fields": {
    "action_time": "2024-09-24T02:16:28.176Z",
    "user": 1,
    "content_type": 7,
    "object_id": "6",
    "object_repr": "Модули",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Sub lesson\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 329,
  "fields": {
    "action_time": "2024-09-25T01:21:16.200Z",
    "user": 1,
    "content_type": 11,
    "object_id": "30",
    "object_repr": "Работа с файлами",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 330,
  "fields": {
    "action_time": "2024-09-25T01:23:42.382Z",
    "user": 1,
    "content_type": 11,
    "object_id": "30",
    "object_repr": "Работа с файлами",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 331,
  "fields": {
    "action_time": "2024-09-25T01:26:55.666Z",
    "user": 1,
    "content_type": 11,
    "object_id": "30",
    "object_repr": "Работа с файлами",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 332,
  "fields": {
    "action_time": "2024-09-25T01:29:06.218Z",
    "user": 1,
    "content_type": 11,
    "object_id": "30",
    "object_repr": "Работа с файлами",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 333,
  "fields": {
    "action_time": "2024-09-25T01:31:22.415Z",
    "user": 1,
    "content_type": 11,
    "object_id": "30",
    "object_repr": "Работа с файлами",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 334,
  "fields": {
    "action_time": "2024-09-25T01:37:18.442Z",
    "user": 1,
    "content_type": 11,
    "object_id": "30",
    "object_repr": "Работа с файлами",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 335,
  "fields": {
    "action_time": "2024-09-25T01:37:50.447Z",
    "user": 1,
    "content_type": 11,
    "object_id": "30",
    "object_repr": "Работа с файлами",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 336,
  "fields": {
    "action_time": "2024-09-25T01:41:05.261Z",
    "user": 1,
    "content_type": 11,
    "object_id": "30",
    "object_repr": "Работа с файлами",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 337,
  "fields": {
    "action_time": "2024-09-25T01:48:19.493Z",
    "user": 1,
    "content_type": 11,
    "object_id": "31",
    "object_repr": "Потоковый ввод stdin и вывод stdout",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 338,
  "fields": {
    "action_time": "2024-09-25T01:50:02.275Z",
    "user": 1,
    "content_type": 11,
    "object_id": "31",
    "object_repr": "Потоковый ввод stdin и вывод stdout",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 339,
  "fields": {
    "action_time": "2024-09-25T01:52:08.587Z",
    "user": 1,
    "content_type": 11,
    "object_id": "31",
    "object_repr": "Потоковый ввод stdin и вывод stdout",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 340,
  "fields": {
    "action_time": "2024-09-25T01:53:30.573Z",
    "user": 1,
    "content_type": 11,
    "object_id": "31",
    "object_repr": "Потоковый ввод stdin и вывод stdout",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 341,
  "fields": {
    "action_time": "2024-09-25T02:09:41.163Z",
    "user": 1,
    "content_type": 11,
    "object_id": "32",
    "object_repr": "Работа с csv файлами",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 342,
  "fields": {
    "action_time": "2024-09-25T02:40:02.136Z",
    "user": 1,
    "content_type": 11,
    "object_id": "33",
    "object_repr": "Работа с json файлами",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 343,
  "fields": {
    "action_time": "2024-09-25T02:43:24.409Z",
    "user": 1,
    "content_type": 11,
    "object_id": "34",
    "object_repr": "Работа с zip файлами",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 344,
  "fields": {
    "action_time": "2024-09-25T02:45:10.842Z",
    "user": 1,
    "content_type": 11,
    "object_id": "34",
    "object_repr": "Работа с zip файлами",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 345,
  "fields": {
    "action_time": "2024-09-25T02:50:54.613Z",
    "user": 1,
    "content_type": 11,
    "object_id": "34",
    "object_repr": "Работа с zip файлами",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 346,
  "fields": {
    "action_time": "2024-09-25T02:52:55.748Z",
    "user": 1,
    "content_type": 11,
    "object_id": "34",
    "object_repr": "Работа с zip файлами",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 347,
  "fields": {
    "action_time": "2024-09-25T02:54:41.407Z",
    "user": 1,
    "content_type": 11,
    "object_id": "34",
    "object_repr": "Работа с zip файлами",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 348,
  "fields": {
    "action_time": "2024-09-25T02:56:55.547Z",
    "user": 1,
    "content_type": 11,
    "object_id": "34",
    "object_repr": "Работа с zip файлами",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 349,
  "fields": {
    "action_time": "2024-09-25T02:58:21.952Z",
    "user": 1,
    "content_type": 11,
    "object_id": "34",
    "object_repr": "Работа с zip файлами",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 350,
  "fields": {
    "action_time": "2024-09-25T03:00:25.417Z",
    "user": 1,
    "content_type": 11,
    "object_id": "35",
    "object_repr": "Работа с pickle файлами",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 351,
  "fields": {
    "action_time": "2024-09-25T03:01:53.995Z",
    "user": 1,
    "content_type": 11,
    "object_id": "35",
    "object_repr": "Работа с pickle файлами",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 352,
  "fields": {
    "action_time": "2024-09-25T03:03:42.616Z",
    "user": 1,
    "content_type": 11,
    "object_id": "35",
    "object_repr": "Работа с pickle файлами",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 353,
  "fields": {
    "action_time": "2024-09-25T03:07:08.583Z",
    "user": 1,
    "content_type": 11,
    "object_id": "35",
    "object_repr": "Работа с pickle файлами",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 354,
  "fields": {
    "action_time": "2024-09-25T03:20:02.706Z",
    "user": 1,
    "content_type": 11,
    "object_id": "36",
    "object_repr": "Модуль Os",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 355,
  "fields": {
    "action_time": "2024-09-25T03:47:10.137Z",
    "user": 1,
    "content_type": 11,
    "object_id": "24",
    "object_repr": "Типы данных date и time",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 356,
  "fields": {
    "action_time": "2024-09-25T03:51:00.983Z",
    "user": 1,
    "content_type": 11,
    "object_id": "24",
    "object_repr": "Типы данных date и time",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 357,
  "fields": {
    "action_time": "2024-09-25T03:51:49.493Z",
    "user": 1,
    "content_type": 11,
    "object_id": "24",
    "object_repr": "Типы данных date и time",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 358,
  "fields": {
    "action_time": "2024-09-25T03:55:28.686Z",
    "user": 1,
    "content_type": 11,
    "object_id": "24",
    "object_repr": "Типы данных date и time",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 359,
  "fields": {
    "action_time": "2024-09-25T04:00:18.253Z",
    "user": 1,
    "content_type": 11,
    "object_id": "25",
    "object_repr": "Форматирование даты и времени",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 360,
  "fields": {
    "action_time": "2024-09-25T04:01:57.896Z",
    "user": 1,
    "content_type": 11,
    "object_id": "25",
    "object_repr": "Форматирование даты и времени",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 361,
  "fields": {
    "action_time": "2024-09-25T04:04:11.229Z",
    "user": 1,
    "content_type": 11,
    "object_id": "25",
    "object_repr": "Форматирование даты и времени",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 362,
  "fields": {
    "action_time": "2024-09-25T04:08:54.617Z",
    "user": 1,
    "content_type": 11,
    "object_id": "26",
    "object_repr": "Тип данных datetime",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 363,
  "fields": {
    "action_time": "2024-09-25T04:10:38.434Z",
    "user": 1,
    "content_type": 11,
    "object_id": "26",
    "object_repr": "Тип данных datetime",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 364,
  "fields": {
    "action_time": "2024-09-25T04:11:09.616Z",
    "user": 1,
    "content_type": 11,
    "object_id": "26",
    "object_repr": "Тип данных datetime",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 365,
  "fields": {
    "action_time": "2024-09-25T04:11:26.443Z",
    "user": 1,
    "content_type": 11,
    "object_id": "26",
    "object_repr": "Тип данных datetime",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 366,
  "fields": {
    "action_time": "2024-09-25T04:13:48.525Z",
    "user": 1,
    "content_type": 11,
    "object_id": "26",
    "object_repr": "Тип данных datetime",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 367,
  "fields": {
    "action_time": "2024-09-25T04:17:17.110Z",
    "user": 1,
    "content_type": 11,
    "object_id": "26",
    "object_repr": "Тип данных datetime",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 368,
  "fields": {
    "action_time": "2024-09-25T04:22:37.923Z",
    "user": 1,
    "content_type": 11,
    "object_id": "26",
    "object_repr": "Тип данных datetime",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 369,
  "fields": {
    "action_time": "2024-09-25T04:31:51.514Z",
    "user": 1,
    "content_type": 11,
    "object_id": "27",
    "object_repr": "Тип данных timedelta",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 370,
  "fields": {
    "action_time": "2024-09-25T04:37:14.667Z",
    "user": 1,
    "content_type": 11,
    "object_id": "27",
    "object_repr": "Тип данных timedelta",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 371,
  "fields": {
    "action_time": "2024-09-25T04:38:50.597Z",
    "user": 1,
    "content_type": 11,
    "object_id": "27",
    "object_repr": "Тип данных timedelta",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 372,
  "fields": {
    "action_time": "2024-09-25T04:47:19.941Z",
    "user": 1,
    "content_type": 11,
    "object_id": "28",
    "object_repr": "Модуль time",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 373,
  "fields": {
    "action_time": "2024-09-25T04:51:27.034Z",
    "user": 1,
    "content_type": 11,
    "object_id": "28",
    "object_repr": "Модуль time",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 374,
  "fields": {
    "action_time": "2024-09-26T02:13:58.708Z",
    "user": 1,
    "content_type": 11,
    "object_id": "29",
    "object_repr": "Модуль calendar",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 375,
  "fields": {
    "action_time": "2024-09-26T02:29:15.078Z",
    "user": 1,
    "content_type": 11,
    "object_id": "29",
    "object_repr": "Модуль calendar",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 376,
  "fields": {
    "action_time": "2024-09-26T02:29:54.495Z",
    "user": 1,
    "content_type": 11,
    "object_id": "29",
    "object_repr": "Модуль calendar",
    "action_flag": 2,
    "change_message": "[]"
  }
},
{
  "model": "admin.logentry",
  "pk": 377,
  "fields": {
    "action_time": "2024-09-26T02:31:20.719Z",
    "user": 1,
    "content_type": 11,
    "object_id": "29",
    "object_repr": "Модуль calendar",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 378,
  "fields": {
    "action_time": "2024-09-26T02:42:20.441Z",
    "user": 1,
    "content_type": 11,
    "object_id": "37",
    "object_repr": "Механизм памяти в Python",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 379,
  "fields": {
    "action_time": "2024-09-26T02:50:28.238Z",
    "user": 1,
    "content_type": 11,
    "object_id": "38",
    "object_repr": "Работа переменных в Python",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 380,
  "fields": {
    "action_time": "2024-09-26T02:50:47.994Z",
    "user": 1,
    "content_type": 11,
    "object_id": "38",
    "object_repr": "Работа переменных в Python",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 381,
  "fields": {
    "action_time": "2024-09-26T02:54:52.647Z",
    "user": 1,
    "content_type": 11,
    "object_id": "38",
    "object_repr": "Работа переменных в Python",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 382,
  "fields": {
    "action_time": "2024-09-26T02:55:30.226Z",
    "user": 1,
    "content_type": 11,
    "object_id": "38",
    "object_repr": "Работа переменных в Python",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 383,
  "fields": {
    "action_time": "2024-09-26T02:57:28.962Z",
    "user": 1,
    "content_type": 11,
    "object_id": "65",
    "object_repr": "Интернирование объектов",
    "action_flag": 1,
    "change_message": "[{\"added\": {}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 384,
  "fields": {
    "action_time": "2024-09-26T02:57:51.042Z",
    "user": 1,
    "content_type": 7,
    "object_id": "9",
    "object_repr": "Устройство памяти",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"Sub lesson\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 385,
  "fields": {
    "action_time": "2024-09-26T03:03:56.262Z",
    "user": 1,
    "content_type": 11,
    "object_id": "65",
    "object_repr": "Интернирование объектов",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 386,
  "fields": {
    "action_time": "2024-09-26T03:08:41.573Z",
    "user": 1,
    "content_type": 11,
    "object_id": "39",
    "object_repr": "Изменяемые и неизменяемые типы",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 387,
  "fields": {
    "action_time": "2024-09-26T03:15:05.686Z",
    "user": 1,
    "content_type": 11,
    "object_id": "40",
    "object_repr": "Поверхностное и глубокое копирование",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "admin.logentry",
  "pk": 388,
  "fields": {
    "action_time": "2024-09-26T03:24:16.901Z",
    "user": 1,
    "content_type": 11,
    "object_id": "41",
    "object_repr": "Механизмы очистки памяти",
    "action_flag": 2,
    "change_message": "[{\"changed\": {\"fields\": [\"\\u0418\\u043d\\u0444\\u043e\\u0440\\u043c\\u0430\\u0446\\u0438\\u044f\"]}}]"
  }
},
{
  "model": "auth.permission",
  "pk": 1,
  "fields": {
    "name": "Can add log entry",
    "content_type": 1,
    "codename": "add_logentry"
  }
},
{
  "model": "auth.permission",
  "pk": 2,
  "fields": {
    "name": "Can change log entry",
    "content_type": 1,
    "codename": "change_logentry"
  }
},
{
  "model": "auth.permission",
  "pk": 3,
  "fields": {
    "name": "Can delete log entry",
    "content_type": 1,
    "codename": "delete_logentry"
  }
},
{
  "model": "auth.permission",
  "pk": 4,
  "fields": {
    "name": "Can view log entry",
    "content_type": 1,
    "codename": "view_logentry"
  }
},
{
  "model": "auth.permission",
  "pk": 5,
  "fields": {
    "name": "Can add permission",
    "content_type": 2,
    "codename": "add_permission"
  }
},
{
  "model": "auth.permission",
  "pk": 6,
  "fields": {
    "name": "Can change permission",
    "content_type": 2,
    "codename": "change_permission"
  }
},
{
  "model": "auth.permission",
  "pk": 7,
  "fields": {
    "name": "Can delete permission",
    "content_type": 2,
    "codename": "delete_permission"
  }
},
{
  "model": "auth.permission",
  "pk": 8,
  "fields": {
    "name": "Can view permission",
    "content_type": 2,
    "codename": "view_permission"
  }
},
{
  "model": "auth.permission",
  "pk": 9,
  "fields": {
    "name": "Can add group",
    "content_type": 3,
    "codename": "add_group"
  }
},
{
  "model": "auth.permission",
  "pk": 10,
  "fields": {
    "name": "Can change group",
    "content_type": 3,
    "codename": "change_group"
  }
},
{
  "model": "auth.permission",
  "pk": 11,
  "fields": {
    "name": "Can delete group",
    "content_type": 3,
    "codename": "delete_group"
  }
},
{
  "model": "auth.permission",
  "pk": 12,
  "fields": {
    "name": "Can view group",
    "content_type": 3,
    "codename": "view_group"
  }
},
{
  "model": "auth.permission",
  "pk": 13,
  "fields": {
    "name": "Can add user",
    "content_type": 4,
    "codename": "add_user"
  }
},
{
  "model": "auth.permission",
  "pk": 14,
  "fields": {
    "name": "Can change user",
    "content_type": 4,
    "codename": "change_user"
  }
},
{
  "model": "auth.permission",
  "pk": 15,
  "fields": {
    "name": "Can delete user",
    "content_type": 4,
    "codename": "delete_user"
  }
},
{
  "model": "auth.permission",
  "pk": 16,
  "fields": {
    "name": "Can view user",
    "content_type": 4,
    "codename": "view_user"
  }
},
{
  "model": "auth.permission",
  "pk": 17,
  "fields": {
    "name": "Can add content type",
    "content_type": 5,
    "codename": "add_contenttype"
  }
},
{
  "model": "auth.permission",
  "pk": 18,
  "fields": {
    "name": "Can change content type",
    "content_type": 5,
    "codename": "change_contenttype"
  }
},
{
  "model": "auth.permission",
  "pk": 19,
  "fields": {
    "name": "Can delete content type",
    "content_type": 5,
    "codename": "delete_contenttype"
  }
},
{
  "model": "auth.permission",
  "pk": 20,
  "fields": {
    "name": "Can view content type",
    "content_type": 5,
    "codename": "view_contenttype"
  }
},
{
  "model": "auth.permission",
  "pk": 21,
  "fields": {
    "name": "Can add session",
    "content_type": 6,
    "codename": "add_session"
  }
},
{
  "model": "auth.permission",
  "pk": 22,
  "fields": {
    "name": "Can change session",
    "content_type": 6,
    "codename": "change_session"
  }
},
{
  "model": "auth.permission",
  "pk": 23,
  "fields": {
    "name": "Can delete session",
    "content_type": 6,
    "codename": "delete_session"
  }
},
{
  "model": "auth.permission",
  "pk": 24,
  "fields": {
    "name": "Can view session",
    "content_type": 6,
    "codename": "view_session"
  }
},
{
  "model": "auth.permission",
  "pk": 25,
  "fields": {
    "name": "Can add developer",
    "content_type": 7,
    "codename": "add_developer"
  }
},
{
  "model": "auth.permission",
  "pk": 26,
  "fields": {
    "name": "Can change developer",
    "content_type": 7,
    "codename": "change_developer"
  }
},
{
  "model": "auth.permission",
  "pk": 27,
  "fields": {
    "name": "Can delete developer",
    "content_type": 7,
    "codename": "delete_developer"
  }
},
{
  "model": "auth.permission",
  "pk": 28,
  "fields": {
    "name": "Can view developer",
    "content_type": 7,
    "codename": "view_developer"
  }
},
{
  "model": "auth.permission",
  "pk": 29,
  "fields": {
    "name": "Can add category",
    "content_type": 8,
    "codename": "add_category"
  }
},
{
  "model": "auth.permission",
  "pk": 30,
  "fields": {
    "name": "Can change category",
    "content_type": 8,
    "codename": "change_category"
  }
},
{
  "model": "auth.permission",
  "pk": 31,
  "fields": {
    "name": "Can delete category",
    "content_type": 8,
    "codename": "delete_category"
  }
},
{
  "model": "auth.permission",
  "pk": 32,
  "fields": {
    "name": "Can view category",
    "content_type": 8,
    "codename": "view_category"
  }
},
{
  "model": "auth.permission",
  "pk": 33,
  "fields": {
    "name": "Can add category oop",
    "content_type": 9,
    "codename": "add_categoryoop"
  }
},
{
  "model": "auth.permission",
  "pk": 34,
  "fields": {
    "name": "Can change category oop",
    "content_type": 9,
    "codename": "change_categoryoop"
  }
},
{
  "model": "auth.permission",
  "pk": 35,
  "fields": {
    "name": "Can delete category oop",
    "content_type": 9,
    "codename": "delete_categoryoop"
  }
},
{
  "model": "auth.permission",
  "pk": 36,
  "fields": {
    "name": "Can view category oop",
    "content_type": 9,
    "codename": "view_categoryoop"
  }
},
{
  "model": "auth.permission",
  "pk": 37,
  "fields": {
    "name": "Can add subcategory",
    "content_type": 10,
    "codename": "add_subcategory"
  }
},
{
  "model": "auth.permission",
  "pk": 38,
  "fields": {
    "name": "Can change subcategory",
    "content_type": 10,
    "codename": "change_subcategory"
  }
},
{
  "model": "auth.permission",
  "pk": 39,
  "fields": {
    "name": "Can delete subcategory",
    "content_type": 10,
    "codename": "delete_subcategory"
  }
},
{
  "model": "auth.permission",
  "pk": 40,
  "fields": {
    "name": "Can view subcategory",
    "content_type": 10,
    "codename": "view_subcategory"
  }
},
{
  "model": "auth.permission",
  "pk": 41,
  "fields": {
    "name": "Can add sub developer",
    "content_type": 11,
    "codename": "add_subdeveloper"
  }
},
{
  "model": "auth.permission",
  "pk": 42,
  "fields": {
    "name": "Can change sub developer",
    "content_type": 11,
    "codename": "change_subdeveloper"
  }
},
{
  "model": "auth.permission",
  "pk": 43,
  "fields": {
    "name": "Can delete sub developer",
    "content_type": 11,
    "codename": "delete_subdeveloper"
  }
},
{
  "model": "auth.permission",
  "pk": 44,
  "fields": {
    "name": "Can view sub developer",
    "content_type": 11,
    "codename": "view_subdeveloper"
  }
},
{
  "model": "auth.user",
  "pk": 1,
  "fields": {
    "password": "pbkdf2_sha256$600000$69f2MRaK3R1aF4t0fuQvBu$Z1sehxI37RynmRKPR+g/3976+vGep7VME9qLpPQ8mCw=",
    "last_login": "2024-09-26T02:09:53.289Z",
    "is_superuser": true,
    "username": "NobodyNi",
    "first_name": "",
    "last_name": "",
    "email": "nobodyni@icloud.com",
    "is_staff": true,
    "is_active": true,
    "date_joined": "2024-09-12T01:28:55.967Z",
    "groups": [],
    "user_permissions": []
  }
},
{
  "model": "contenttypes.contenttype",
  "pk": 1,
  "fields": {
    "app_label": "admin",
    "model": "logentry"
  }
},
{
  "model": "contenttypes.contenttype",
  "pk": 2,
  "fields": {
    "app_label": "auth",
    "model": "permission"
  }
},
{
  "model": "contenttypes.contenttype",
  "pk": 3,
  "fields": {
    "app_label": "auth",
    "model": "group"
  }
},
{
  "model": "contenttypes.contenttype",
  "pk": 4,
  "fields": {
    "app_label": "auth",
    "model": "user"
  }
},
{
  "model": "contenttypes.contenttype",
  "pk": 5,
  "fields": {
    "app_label": "contenttypes",
    "model": "contenttype"
  }
},
{
  "model": "contenttypes.contenttype",
  "pk": 6,
  "fields": {
    "app_label": "sessions",
    "model": "session"
  }
},
{
  "model": "contenttypes.contenttype",
  "pk": 7,
  "fields": {
    "app_label": "developer",
    "model": "developer"
  }
},
{
  "model": "contenttypes.contenttype",
  "pk": 8,
  "fields": {
    "app_label": "developer",
    "model": "category"
  }
},
{
  "model": "contenttypes.contenttype",
  "pk": 9,
  "fields": {
    "app_label": "developer",
    "model": "categoryoop"
  }
},
{
  "model": "contenttypes.contenttype",
  "pk": 10,
  "fields": {
    "app_label": "developer",
    "model": "subcategory"
  }
},
{
  "model": "contenttypes.contenttype",
  "pk": 11,
  "fields": {
    "app_label": "developer",
    "model": "subdeveloper"
  }
},
{
  "model": "sessions.session",
  "pk": "qzrf7aj492y8gzbtnn7jytzj16i4pp4a",
  "fields": {
    "session_data": ".eJxVjMsOwiAQRf-FtSFQHgMu3fsNZIaHVA0kpV0Z_12bdKHbe865LxZwW2vYRl7CnNiZSXb63QjjI7cdpDu2W-ext3WZie8KP-jg157y83K4fwcVR_3W1jsoUk3Gx2hAaos0ReepSK0FZEqovSeFIITMVqvi0BoDxkMCJUpk7w_GQzcn:1soYhP:LyDspCTCdy6-SdC8-TbsljO8LAuw5flIsf8GfS-ac0w",
    "expire_date": "2024-09-26T01:32:43.056Z"
  }
},
{
  "model": "sessions.session",
  "pk": "sdcok712culpj2jotg8ntj4gjuohip3k",
  "fields": {
    "session_data": ".eJxVjMsOwiAQRf-FtSFQHgMu3fsNZIaHVA0kpV0Z_12bdKHbe865LxZwW2vYRl7CnNiZSXb63QjjI7cdpDu2W-ext3WZie8KP-jg157y83K4fwcVR_3W1jsoUk3Gx2hAaos0ReepSK0FZEqovSeFIITMVqvi0BoDxkMCJUpk7w_GQzcn:1stdx3:t04EH2mclc34ARwUhasSct71PuZqUUNFCaWHOHc_mpY",
    "expire_date": "2024-10-10T02:09:53.292Z"
  }
},
{
  "model": "developer.developer",
  "pk": 1,
  "fields": {
    "lesson": "If-Else",
    "content": "Программы должны уметь выполнять разные действия в зависимости от введенных данных. Для принятия решения программа проверяет, истинно или ложно определенное условие. <br><br>\r\n\r\nВ Python существует несколько способов проверки, и в каждом случае возможны два исхода: истина (True) или ложь (False). Проверка условий и принятие решений по результатам этой проверки называется ветвлением (branching). Программа таким способом выбирает, по какой из возможных ветвей ей двигаться дальше. <br><br>\r\n\r\nВ Python проверка условия осуществляется при помощи ключевого слова if. <br><br>\r\n\r\nРассмотрим следующую программу:\r\n<pre>\r\n<strong>\r\nanswer = input('Какой язык программирования мы изучаем?')\r\n    if answer == 'Python':\r\n        print('Верно! Мы ботаем Python =)')\r\n        print('Python - отличный язык!') \r\n</strong>\r\n</pre>\r\n\r\nПрограмма просит пользователя ввести текст и проверяет результат ввода. Если введенный текст равен строке «Python», то выводит пользователю текст: <br><br>\r\n<pre>\r\n<strong>\r\nВерно! Мы ботаем Python =)\r\nPython - отличный язык!\r\n</strong>\r\n</pre>\r\nДвоеточие (:) в конце строки с инструкцией if сообщает интерпретатору Python, что дальше находится блок команд. В блок команд входят все строки с отступом под строкой с инструкцией if, вплоть до следующей строки без отступа. Если условие истинно, выполняется весь расположенный ниже блок. В предыдущем примере блок инструкций составляет третья и четвертая строки программы. <br><br>\r\n\r\nБлоком кода называют объединенные друг с другом строки. Они всегда связаны с определенной частью программы (например, с инструкцией if). В Python блоки кода формируются при помощи отступов. <br><br>\r\n\r\nПредыдущая программа выводит текст в случае, если условие истинно. Но если условие ложно, то программа ничего не выводит. Для того чтобы обеспечить возможность выполнять что-либо в случае, если условие оказалось ложным, мы используем ключевое слово else. <br><br>\r\n\r\n<pre>\r\n<strong>\r\nanswer = input('Какой язык программирования мы изучаем?')\r\n    if answer == 'Python':\r\n        print('Верно! Мы ботаем Python =)')\r\n        print('Python - отличный язык!')\r\n    else:\r\n        print('Не совсем так!') \r\n</strong>\r\n </pre>\r\nВ новой программе мы обрабатываем сразу два случая: если условие истинно (пользователь ввел «Python»), и если условие ложно (пользователь ввел что угодно, кроме «Python»). <br><br>\r\n\r\n<strong>Отступы</strong><br><br>\r\nВ некоторых языках программирования отступы — дело личного вкуса, и можно вообще обходиться без них. Однако в Python они – неотъемлемая часть кода. Именно отступ сообщает интерпретатору Python, где начинается и где заканчивается блок кода. <br><br>\r\n\r\n<strong>Отступ</strong> — небольшое смещение строки кода вправо. В начале такой строки находятся пробелы, и поэтому она на несколько символов отстоит от левого края. Некоторым инструкциям в Python (например, инструкции if) именно блок кода сообщает, какие действия следует предпринять. После if блок кода информирует интерпретатор Python, как действовать, если условие истинно, и как — если оно ложно. По соглашению PEP 8, для отступа блоков кода используются 4 пробела.<br><br>\r\n\r\n<strong>Цепочки сравнений</strong><br><br>\r\n\r\nОператоры сравнения в Python можно объединять в цепочки (в отличие от большинства других языков программирования, где для этого нужно использовать логические связки), например, a == b == c или 1 <= x <= 10. Следующий код проверяет, находится ли значение переменной age в диапазоне от 3 до 6:\r\n\r\n<pre>\r\n<strong>\r\nage = int(input())\r\nif 3 <= age <= 6:\r\n    print('Вы ребёнок')\r\n</strong>\r\n</pre>\r\nКод, проверяющий равенство трех переменных, может выглядеть так:\r\n<pre>\r\n<strong>\r\nif a == b == c:\r\n    print('числа равны')\r\nelse:\r\n    print('числа не равны')\r\n</strong>\r\n</pre>\r\n\r\n<strong>Транзитивность</strong><br><br>\r\nОперация равенства является транзитивной. Это означает, что если a == b и b == c, то из этого следует, что a == c. Именно поэтому предыдущий код, проверяющий равенство трех переменных, работает, как полагается. \r\n\r\nИз курса математики вам могут быть знакомы другие примеры транзитивных операций:<br><br>\r\n\r\n<strong>Отношение порядка:</strong> если a > b и b > c, то a > c;<br>\r\n<strong>Параллельность прямых:</strong> если a ∥ b и b ∥ c, то a ∥ c;<br>\r\n<strong>Делимость:</strong> если a делится на b и b делится на c, то a делится на c.<br><br>\r\n\r\nНаглядно транзитивность отношения порядка можно понять на таком примере: если сосед слева старше вас (a>b), а вы старше соседа справа (b>c), то сосед слева точно старше соседа справа \r\n(a>c).<br><br>\r\n\r\nОперация неравенства (!=), в отличие от операции равенства (==), является <strong>нетранзитивной</strong>. То есть из того, что a != b и b != c вовсе не следует, что a != c. Действительно, если вас зовут не так, как соседа слева и не так, как соседа справа, то нет гарантии, что у обоих соседей не окажутся одинаковые имена.<br><br>\r\n\r\nТаким образом, следующий код вовсе не проверяет тот факт, что все три переменные различны:\r\n<pre>\r\n<strong>\r\nif a != b != c:\r\n    print('числа не равны')\r\nelse:\r\n    print('числа равны')\r\n</strong>\r\n</pre>",
    "time_create": "2024-09-09T22:15:51.685Z",
    "time_update": "2024-09-15T23:08:37.118Z",
    "is_published": true,
    "slug": "if-elif-else",
    "direct": 1,
    "sub_lesson": [
      1,
      2
    ]
  }
},
{
  "model": "developer.developer",
  "pk": 2,
  "fields": {
    "lesson": "For",
    "content": "Одно из преимуществ компьютеров перед людьми - способность повторять одни и те же действия многократно, быстро и совсем не утомляясь 💻.<br><br>\r\n\r\nВ Python существует две основных разновидности циклов:<br><br>\r\n\r\nциклы, <strong>повторяющиеся определенное количество раз</strong> (for, счетные циклы, counting loops);<br>\r\nциклы, <strong>повторяющиеся до наступления определенного события </strong>(while, условные циклы, conditional loops).<br><br>\r\nЦикл for замечательно работает, если мы заранее знаем, сколько повторений (итераций) нам требуется сделать.<br><br>\r\n\r\nРассмотрим код, который распечатает 10 раз слово \"Привет\":\r\n<pre>\r\n<strong>\r\nfor i in range(10):\r\n    print('Привет')\r\n</strong>\r\n</pre>\r\nСтруктура цикла for в Python выглядит так:\r\n<pre>\r\n<strong>\r\nfor название_переменной_цикла in range(количество_повторений):\r\n    блок кода\r\n</strong>\r\n</pre>\r\nДвоеточие (:) в конце строки с инструкцией for сообщает интерпретатору Python, что дальше находится блок команд. В блок команд входят все строки, расположенные с отступом от строки с инструкцией for, вплоть до следующей строки без отступа.\r\n\r\n<strong>Блок команд, который выполняется в цикле for, называется телом цикла</strong>.<br><br>\r\n\r\nС помощью цикла for можно считывать и обрабатывать сколько угодно чисел.\r\n\r\nРассмотрим следующий программный код:\r\n<pre>\r\n<strong>\r\nfor i in range(5):\r\n    num = int(input())\r\n    print(\"Квадрат вашего числа равен:\", num * num)\r\n\r\nprint(\"Цикл завершен\")\r\n</strong>\r\n</pre>\r\nТакая программа считывает 5 чисел и выводит на экран их квадраты вместе с поясняющей надписью. Поскольку вторая и третья строки выделены отступом, Python считает, что это тело цикла, которое выполняется 5 раз. Четвертая строка не содержит отступа, поэтому не является частью цикла и будет выполнена всего один раз, после того как цикл завершится.\r\n\r\n<strong>Примеры использования цикла for</strong><br><br>\r\nРассмотрим следующий программный код:\r\n<pre>\r\n<strong>\r\nprint(\"A\")\r\nprint(\"B\")\r\n\r\nfor i in range(5):\r\n    print(\"C\")\r\n    print(\"D\")\r\n\r\nprint(\"E\")\r\n</strong>\r\n</pre>\r\nРезультатом выполнения такой программы будут строки\r\n<pre>\r\n<strong>\r\nA\r\nB\r\nC\r\nD\r\nC\r\nD\r\nC\r\nD\r\nC\r\nD\r\nC\r\nD\r\nE\r\n</strong>\r\n</pre>\r\nТо есть сначала программа распечатает символы А и В, затем символы C и D пять раз, а затем распечатает символ Е один раз. Тело цикла состоит из двух строк: пятой и шестой; именно они и будут повторяться.<br><br>\r\n\r\nВ программе может быть сколько угодно циклов. Например, если мы хотим, чтобы сначала 5 раз был распечатан символ С, а затем 5 раз символ D, мы можем использовать 2 цикла:\r\n<pre>\r\n<strong>\r\nprint('A')\r\nprint('B')\r\n\r\nfor i in range(5):\r\n    print('C')\r\n\r\nfor i in range(5):\r\n    print('D')\r\n\r\nprint('E')\r\n</strong>\r\n</pre>\r\nРезультатом выполнения такой программы будут строки:\r\n<pre>\r\n<strong>\r\nA\r\nB\r\nC\r\nC\r\nC\r\nC\r\nC\r\nD\r\nD\r\nD\r\nD\r\nD\r\nE\r\n</strong>\r\n</pre>\r\n<li>Однократное выполнение тела цикла называется итерацией цикла.</li><br>\r\n<li>Блоком кода называют объединенные друг с другом строки. Они всегда связаны с определенной частью программы (например, с инструкцией if или for). В Python блоки кода формируются при помощи отступов</li><br>\r\n<li>Слово for пишется маленькими буквами, первая строка должна заканчиваться двоеточием, а тело цикла должно быть выделено отступом.</li>\r\n</li><br><br>\r\n\r\n<strong>Переменная цикла</strong><br><br>\r\nДавайте еще раз взглянем на базовую структуру цикла for:\r\n<pre>\r\n<strong>\r\nfor название_переменной_цикла in range(количество_повторений):\r\n    блок кода\r\n</strong>\r\n</pre>\r\nНе совсем понятно, для чего нужна и как работает переменная цикла.<br><br>\r\n\r\nРассмотрим следующий код:\r\n<pre>\r\n<strong>\r\nfor i in range(10):\r\n    print(i)\r\n</strong>\r\n</pre>\r\nРезультатом выполнения такого кода будет:\r\n<pre>\r\n<strong>\r\n0\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n</strong>\r\n</pre>\r\nКогда цикл впервые начинает работу, Python устанавливает значение переменной цикла i = 0. Каждый раз, когда мы повторяем тело цикла, Python увеличивает значение переменной на 1.<br><br>\r\n\r\nПочему большинство программистов начинают цикл с 0, а не с 1? Раньше некоторые начинали цикл с 1, а некоторые с 0. Те и другие приводили весьма изощренные аргументы, споря о том, какой способ лучше. Но в конце концов победили сторонники второго варианта. С тех пор большинство начинает циклы с 0. В частности, в Python цикл for начинается с 0.<br><br>\r\n\r\nПоскольку переменная цикла i увеличивается на 1 каждый раз, то ее можно использовать для отслеживания номера итерации, на которой мы находимся в циклическом процессе.<br><br>\r\n\r\nРассмотрим следующий код:\r\n<pre>\r\n<strong>\r\nfor i in range(10):\r\n    print(i, '-- Привет')\r\n</strong>\r\n</pre>\r\nРезультатом выполнения такого кода будет:\r\n<pre>\r\n<strong>\r\n0 -- Привет\r\n1 -- Привет\r\n2 -- Привет\r\n3 -- Привет\r\n4 -- Привет\r\n5 -- Привет\r\n6 -- Привет\r\n7 -- Привет\r\n8 -- Привет\r\n9 -- Привет\r\n</strong>\r\n</pre>\r\nЕсли мы хотим начать с 1, то можем написать код:\r\n<pre>\r\n<strong>\r\nfor i in range(10):\r\n    print(i + 1, '-- Привет')\r\n</strong>\r\n</pre>\r\nРезультатом выполнения такого кода будет:\r\n<pre>\r\n<strong>\r\n1 -- Привет\r\n2 -- Привет\r\n3 -- Привет\r\n4 -- Привет\r\n5 -- Привет\r\n6 -- Привет\r\n7 -- Привет\r\n8 -- Привет\r\n9 -- Привет\r\n10 -- Привет\r\n</strong>\r\n</pre>\r\nОбратите внимание, за счет выражения i + 1, мы начинаем вывод с 1, а не с 0.<br><br>\r\n\r\n<strong>Имена переменных цикла</strong><br><br>\r\nРанее говорилось, что имена переменных должны носить осмысленный характер и описывать их назначение. Однако для переменных цикла иногда делаются исключения. В программировании для переменных цикла обычно используют буквы <strong>i, j, k</strong>.<br><br>\r\n\r\nСледующие две программы абсолютно одинаковые: в первой программе переменная цикла имеет название i, во второй программе – number:\r\n<pre>\r\n<strong>\r\nfor i in range(10):\r\n    print(i)\r\nfor number in range(10):\r\n    print(number)\r\n</strong>\r\n</pre>\r\nРезультатом выполнения обеих программ будет:\r\n<pre>\r\n<strong>\r\n0\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n</strong>\r\n</pre>\r\n<strong>Почему для переменной циклов зарезервированы буквы i, j, k?</strong> Дело в том, что раньше программы использовались для математических расчетов, а в математике буквы a, b, c и x, y, z уже зарезервированы для других целей. Поэтому программисты выбрали для этой цели переменные i, j, k, и это стало общепринятой практикой.<br><br>\r\n\r\nБывают ситуации, когда переменная цикла не используется в теле цикла. В таком случае, вместо того, чтобы давать ей имя, мы можем указать символ нижнего подчеркивания _:\r\n<pre>\r\n<strong>\r\nfor _ in range(5):\r\n    print('Python - awesome!')\r\n</strong>\r\n</pre>\r\nРезультатом выполнения такого кода будет:\r\n<pre>\r\n<strong>\r\nPython - awesome!\r\nPython - awesome!\r\nPython - awesome!\r\nPython - awesome!\r\nPython - awesome!\r\n</strong>\r\n</pre>\r\n\r\n<strong>Следует помнить</strong>, что правая граница цикла в Python всегда не включительна. Таким образом следующий код:\r\n<pre>\r\n<strong>\r\nfor i in range(5):\r\n    print(i)\r\n</strong>\r\n</pre>\r\nраспечатает числа от 0 до 4:\r\n<pre>\r\n<strong>\r\n0\r\n1\r\n2\r\n3\r\n4\r\n</strong>\r\n</pre>\r\nЕсли требуется распечатать числа от 1 до 5, то мы пишем код:\r\n<pre>\r\n<strong>\r\nfor i in range(5):\r\n    print(i + 1)\r\n</strong>\r\n</pre>",
    "time_create": "2024-09-10T00:15:01.304Z",
    "time_update": "2024-09-16T00:14:10.229Z",
    "is_published": true,
    "slug": "cycle-for",
    "direct": 1,
    "sub_lesson": [
      4,
      3,
      5
    ]
  }
},
{
  "model": "developer.developer",
  "pk": 3,
  "fields": {
    "lesson": "While",
    "content": "<strong>Цикл while</strong><br><br>\r\nCуществуют две основные разновидности цикла:<br><br>\r\n\r\n<li>циклы, <strong>повторяющиеся определенное количество раз</strong> (for, счетные циклы, counting loops);</li>\r\n<li>циклы, <strong>повторяющиеся до наступления определенного события </strong>(while, условные циклы, conditional loops)</li><br><br>\r\nЦикл for замечательно работает, если мы заранее знаем, сколько повторений (итераций) нам потребуется сделать. Но иногда нужно, чтобы цикл выполнялся до наступления некоторого события, и количество итераций в этом случае заранее оценить просто невозможно. И здесь на помощь приходит цикл while.<br><br>\r\n\r\nСтруктура цикла while в Python выглядит так:\r\n<pre>\r\n<strong>\r\nwhile условие:\r\n    блок кода\r\n</strong>\r\n</pre>\r\nДвоеточие (:) в конце строки с инструкцией while сообщает Python, что дальше находится блок команд. В блок входят все строки, расположенные с отступом от строки с инструкцией while, вплоть до следующей строки без отступа.<br><br>\r\n\r\n<strong>Блок команд, который выполняется в цикле while, называется телом цикла.</strong><br><br>\r\n\r\nРассмотрим код, использующий цикл while, который распечатает 10 раз слово Привет:\r\n<pre>\r\n<strong>\r\ni = 0\r\nwhile i < 10:\r\n    print('Привет')\r\n    i += 1\r\n</strong>\r\n</pre>\r\nТакой код можно легко заменить циклом for, поскольку мы заранее знаем, сколько раз нужно выполнить тело цикла. Однако так бывает не всегда.\r\n\r\nНапишем программу, которая считывает числа и выводит их квадраты, пока не будет введено −1. При такой постановке задачи мы не можем воспользоваться циклом for, так как не знаем, сколько чисел будет предшествовать числу −1.\r\n<pre>\r\n<strong>\r\nnum = int(input())\r\nwhile num != -1:\r\n    print('Квадрат вашего числа равен:', num * num)\r\n    num = int(input())\r\n</strong>\r\n</pre>\r\nВ качестве начального значения переменной num, мы используем первое из чисел. Далее, пока выполняется условие цикла, а именно пока введенное число не равно −1, мы исполняем тело цикла. В тело цикла входит две команды:<br><br>\r\n\r\n<li>напечатать квадрат введенного числа;</li>\r\n<li>считать следующее число.</li><br><br>\r\nВажным являются два момента:\r\n\r\n<li>правильная инициализация переменной num;</li>\r\n<li>изменение переменной num внутри цикла while.</li><br><br>\r\n<strong>Важно: если не изменять переменную num внутри цикла, то можно получить так называемый бесконечный цикл, который будет выполняться бесконечно много раз.</strong><br><br>\r\n\r\nЦикл while очень похож на условный оператор if. Разница заключается в том, что в случае с условным оператором соответствующий блок кода будет выполняться только один раз, тогда как с циклом while блок кода будет выполнен многократно.<br><br>\r\n\r\n<strong>Цикл for VS цикл while</strong><br><br>\r\nМы всегда можем заменить цикл for с помощью цикла while. Следующие две программы выводят числа от 0 до 100:\r\n<pre>\r\n<strong>\r\n# используем for\r\nfor i in range(101):\r\n    print(i)\r\n\r\n# используем while\r\ni = 0\r\nwhile i < 101:\r\n    print(i)\r\n    i += 1\r\n</strong>\r\n</pre>\r\nВ первом цикле переменная i последовательно принимает значения от 0 до 100. Для цикла while нам пришлось завести самостоятельно переменную i и придать ей начальное значение. Тело цикла while содержит аналогичную инструкцию вывода print(i), однако помимо этого мы самостоятельно увеличиваем значение переменной i на 1, что делается автоматически в случае с циклом for.<br><br>\r\n\r\nНапишем программу, выводящую все числа, кратные 3, используя цикл for и while:\r\n<pre>\r\n<strong>\r\n# используем for\r\nfor i in range(0, 100, 3):\r\n    print(i)\r\n\r\n# используем while\r\ni = 0\r\nwhile i < 100:\r\n    print(i)\r\n    i += 3\r\n</strong>\r\n</pre>\r\nНе всегда, однако, удается заменить цикл while с помощью цикла for. Если заранее не известно количество итераций, то необходимо использовать цикл while и только его.<br><br>\r\n\r\n<strong>Считывание данных до стоп значения</strong><br><br>\r\nЧасто при решении задач на цикл while мы считываем данные до тех пор, пока пользователь не введет некоторое значение, которое называют стоп значением. Напишем программу, которая считывает числа и находит их сумму до тех пор, пока пользователь не введет слово stop:\r\n<pre>\r\n<strong>\r\ntext = input()\r\ntotal = 0\r\nwhile text != 'stop':\r\n    total += int(text)\r\n    text = input()\r\n\r\nprint('Сумма чисел равна', total)\r\n</strong>\r\n</pre>\r\nТакой код будет часто использоваться при решении задач.<br><br>\r\n\r\n<strong>Бесконечный цикл</strong><br><br>\r\nВсегда кроме редких случаев цикл while должен содержать возможность завершиться. То есть в цикле что-то должно сделать проверяемое условие ложным. Если цикл не имеет возможности завершиться, то он называется бесконечным циклом. Бесконечный цикл продолжает повторяться до тех пор, пока программа не будет прервана. Бесконечные циклы обычно появляются, когда программист забывает написать программный код внутри цикла, который делает проверяемое условие ложным. В большинстве случаев следует избегать применения бесконечных циклов.<br><br>\r\n\r\nПример бесконечного цикла:\r\n<pre>\r\n<strong>\r\ni = 0\r\ntotal = 0\r\nwhile i < 10:\r\n    total += i\r\n</strong>\r\n</pre>\r\nТак как в теле цикла не происходит изменения переменной i, то условие i < 10 остается истинным и цикл выполняется бесконечно много раз.<br><br>\r\n\r\nБесконечные циклы можно использовать в связке с оператором прерывания break.<br><br>\r\n\r\nЦикл while получил свое название из-за характера своей работы: он выполняет некую задачу до тех пор, пока условие является истинным. Слово while на английском означает как раз \"пока\".<br><br>\r\n\r\nЦикл while называют циклом с предусловием, поскольку выполнению тела цикла предшествует проверка условия (сначала проверяется условие, а уже затем выполняется тело цикла).<br><br>\r\n\r\nОднократное выполнение тела цикла называется итерацией цикла.<br><br>\r\n\r\nЦикл while может не выполниться ни одного раза. Например, следующий код:\r\n<pre>\r\n<strong>\r\ni = -1\r\nwhile i > 0:\r\n    print('Hello world!')\r\n</strong>\r\n</pre>\r\nне выведет текст, поскольку условие i > 0 ложно с самого начала.<br><br>\r\n\r\nУсловие в цикле while, как и в условном операторе if, может содержать логические операции or, and, not.",
    "time_create": "2024-09-10T00:15:15.594Z",
    "time_update": "2024-09-16T01:38:06.849Z",
    "is_published": true,
    "slug": "cycle-while",
    "direct": 1,
    "sub_lesson": [
      6,
      7,
      8
    ]
  }
},
{
  "model": "developer.developer",
  "pk": 4,
  "fields": {
    "lesson": "Типы данных",
    "content": "<strong>Python</strong> — объектно-ориентированный язык программирования, его основу составляют объекты и классы. Объект — это область памяти компьютера, которая описывается типом (он же класс) и значением. При этом от типа зависит область значений объекта, операции и методы, которые к нему можно применять.<br><br>\r\n\r\nPython предоставляет богатый набор встроенных типов данных. Поэтому при решении стандартных задач питонист реже пишет собственные классы, чем, например, разработчик на Java.<br><br>\r\n\r\n<strong>Изменяемые и неизменяемые типы данных</strong><br><br>\r\nТипы данных в Python можно разделить на изменяемые и неизменяемые. К неизменяемым объектам относятся числа, строки, кортежи, NoneType объект, bool и frozenset, а к изменяемым — списки, словари и множества. Это свойство нужно учитывать при передаче объектов в функцию.",
    "time_create": "2024-09-10T00:26:42.148Z",
    "time_update": "2024-09-23T21:48:55.322Z",
    "is_published": true,
    "slug": "types-of-data",
    "direct": 1,
    "sub_lesson": [
      16,
      9,
      12,
      15,
      13,
      10,
      11,
      14
    ]
  }
},
{
  "model": "developer.developer",
  "pk": 5,
  "fields": {
    "lesson": "Функции",
    "content": "<strong>Функции</strong><br><br>\r\n<strong>Функция</strong> – отдельная, функционально независимая часть программы, выполняющая определенную задачу.<br><br>\r\n\r\nФункции объявляются с помощью ключевого слова def (от англ. define – определять). За ключевым словом def следуют название функции, круглые скобки () и двоеточие :.\r\n<pre>\r\n<strong>\r\ndef название_функции():\r\n    блок кода\r\n</strong>\r\n</pre>\r\nПервая строка объявления функции называется заголовком функции.\r\n\r\nСо следующей строки идет <strong>блок кода</strong> – тело функции. Это набор инструкций, составляющих одно целое и выполняющихся каждый раз, когда вызывается функция. Каждая строка в теле функции выделена отступом. Для выделения строк блока кода отступом программисты Python обычно используют четыре пробела в соответствии со стандартом PEP 8.\r\n\r\nРассмотрим объявление функции: \r\n<pre>\r\n<strong>\r\ndef print_message():\r\n    print('Я - Артур,')\r\n    print('король британцев. ')\r\n</strong>\r\n</pre>\r\nЭтот фрагмент кода определяет функцию с именем print_message(). Тело ее состоит из двух инструкций, и вызов приведет к их исполнению.",
    "time_create": "2024-09-10T00:27:12.756Z",
    "time_update": "2024-09-23T22:22:29.235Z",
    "is_published": true,
    "slug": "function",
    "direct": 1,
    "sub_lesson": [
      18,
      23,
      17,
      20,
      21,
      22,
      19
    ]
  }
},
{
  "model": "developer.developer",
  "pk": 6,
  "fields": {
    "lesson": "Модули",
    "content": "<strong>Модули в Python</strong><br><br>\r\n<strong>Модуль</strong> — файл, содержащий определения функций, классов и переменных, а также исполняемый код. Модули в Python обычно имеют расширение .py. Они позволяют структурировать код и делить его на мелкие, легко управляемые части.<br><br>\r\n\r\nЧтобы использовать модуль, его нужно импортировать с помощью инструкции import. Например, импортируем модуль math, который предоставляет математические функции:\r\n<pre>\r\n<strong>\r\nimport math\r\n \r\nresult = math.sqrt(16)\r\nprint(result)  # Выведет 4.0\r\n</strong>\r\n</pre>",
    "time_create": "2024-09-10T00:29:29.962Z",
    "time_update": "2024-09-24T02:16:28.176Z",
    "is_published": true,
    "slug": "modules",
    "direct": 1,
    "sub_lesson": [
      64,
      61,
      62,
      63
    ]
  }
},
{
  "model": "developer.developer",
  "pk": 7,
  "fields": {
    "lesson": "Файлы",
    "content": "<strong>Файловый ввод и вывод</strong><br><br>\r\nПрограммы, которые мы писали до сих пор, требовали повторного ввода данных при каждом запуске, потому что, как только программа заканчивает свою работу, данные для переменных исчезают из оперативной памяти. Если их нужно сберечь между выполнениями программы, требуется запись. Данные записываются в файл, обычно сохраняющийся на диске компьютера.<br><br>\r\n\r\n<strong>Файл (англ. file) — именованная область данных на носителе информации.</strong><br><br>\r\n\r\nСохраненные в файле данные обычно остаются в нем после завершения работы программы, их можно позже извлечь и использовать.<br><br>\r\n\r\nКогда программе нужно сохранить данные для дальнейшего использования, она пишет их в файл. Из файла записанные данные можно считать.<br><br>\r\n\r\nПрограммисты называют такой процесс сохранения данных — запись данных в файл. Когда часть данных пишется в файл, она копируется из переменной, находящейся в оперативной памяти. Файл, куда сохраняются данные, называется файл вывода, потому что программа помещает в него выходные данные.<br><br>\r\n\r\nПроцесс извлечения данных из файла называется чтением данных из файла. Данные считываются из файла ввода. Программа извлекает входные данные из этого файла. Когда порция данных считывается из файла, она копируется в оперативную память, где на нее ссылается переменная.\r\n<br><br>\r\n\r\n<strong>Работа с файлами</strong><br><br>\r\nКогда в программе используется файл, как правило требуется выполнить три шага:<br><br>\r\n\r\n<li>Открыть файл. В процессе открытия файла создается связь между файлом и программой. </li><li>Открытие файла вывода обычно создает файл на диске и позволяет программе записать в него данные. Открытие файла ввода позволяет программе прочитать данные из файла.</li>\r\n<li>Обработать файл. На этом шаге данные либо записываются в файл (если это файл вывода), либо считываются из файла (если это файл ввода).</li>\r\n<li>Закрыть файл. После использования файла программой его нужно закрыть, тем самым освободить ресурс и разорвать связь файла с программой.</li><br><br>\r\n<strong>Типы файлов</strong><br><br>\r\nСуществует два типа файлов: текстовые и двоичные (бинарные). Текстовый файл содержит данные, которые были закодированы в виде текста при помощи такой схемы кодирования, как ASCII или Юникод. Даже если файл содержит числа, эти числа в файле хранятся как набор символов. В результате файл можно открыть и просмотреть в текстовом редакторе, таком как Блокнот.<br><br>\r\n\r\nДвоичный файл содержит данные, которые не были преобразованы в текст. Данные, которые помещены в двоичный файл, предназначены только для чтения программой, и такой файл невозможно просмотреть в текстовом редакторе.<br><br>\r\n\r\n<strong>Разделение файлов</strong> на текстовые и бинарные искусственное, так как любой текстовый файл бинарен.<br><br>\r\n\r\n<strong>Методы доступа к файлам</strong><br><br>\r\nБольшинство языков программирования обеспечивает два способа получения доступа к данным в файле:<br><br>\r\n\r\n<li>последовательный,</li>\r\n<li>прямой или произвольный.</li><br>\r\n<strong>Последовательный</strong>, как при проигрывании кассет с записью на пленке, выдает порции информации одну за другой. При работе с таким файлом не получится перескочить сразу к нужной части данных, сначала придется прочитать все предыдущие. <br><br>\r\n\r\nПри работе с файлом с <strong>прямым или произвольным</strong> доступом можно перескочить непосредственно к любой порции данных, не читая предыдущие. Как проигрыватель компакт-дисков или МР3-плеер перескакивает сразу к любой песне.<br><br>\r\n\r\n<strong>Имена файлов</strong><br><br>\r\nБольшинство пользователей компьютеров привыкли, что файлы определяются по имени. Когда создаете документ с помощью текстового редактора и сохраняете его в файле, указываете имя файла. Если исследуете содержимое диска с помощью проводника Windows, видите список имен файлов.<br><br>\r\n\r\nУ каждой операционной системы собственные правила именования файлов. Многие системы поддерживают использование расширений файлов, т.е. коротких последовательностей символов, которые расположены в конце имени файла и предваряются точкой. Файлы, изображенные на рисунке, имеют расширения jpg, txt и docx. Расширение обычно говорит о типе данных в файле. Например, расширение jpg сообщает, что файл содержит графическое изображение, сжатое согласно стандарту JPEG. Расширение txt свидетельствует, что в файле текст. Расширение docx информирует о наличии в файле документа Microsoft Word.<br><br>\r\n\r\n<strong>Кодировка файлов</strong><br><br>\r\n\r\nКодировка UTF-8 самая распространенная, рекомендуем использовать именно ее в качестве кодировки по умолчанию для текстовых файлов.<br><br>\r\n\r\nUTF-8 — сложная кодировка, на обозначение одного символа в ней может использоваться от одного до шести байт. Подробнее про эту кодировку можно почитать в википедии.<br><br>\r\n\r\nВ операционной системе Windows до сих пор используется однобайтовая кодировка Windows-1251 (😨). Чтобы избежать проблем при работе с текстовыми файлами в Windows нужно явно указывать кодировку. В редакторе Notepad («Блокнот») можно указывать кодировку при сохранении файла.<br><br>\r\n\r\n<strong>Относительные и абсолютные пути</strong><br><br>\r\nПуть файла (или путь к файлу) — последовательное указание имен папок, через которые надо пройти, чтобы добраться до объекта.<br><br>\r\n\r\nПути к файлу бывают двух типов:<br><br>\r\n\r\n<li>абсолютные;</li>\r\n<li>относительные.</li><br><br>\r\n<strong>Абсолютный путь</strong> – полный путь к файлу, показывающий точное место его расположения. Он всегда один и тот же, пока файл не перемещен.\r\n\r\nПримеры абсолютного пути:\r\n<pre>\r\n<strong>\r\nD:\\Data\\MyFiles\\picture.png;\r\nС:\\MyPrograms\\Python\\script.py;\r\nC:\\Users\\timur\\YandexDisk\\BeeGeek\\Python\\book.pdf.\r\n</strong>\r\n</pre>\r\nУказывая абсолютный путь на компьютере, обязательно нужно указывать диск, а также использовать \\ (для Windows) в качестве разделителя имен папок.<br><br>\r\n\r\nВ unix-подобных ОС, например, в Linux и Mac OS для отделения имен папок используется прямой слеш /, а не обратный, как в Windows.<br><br>\r\n\r\n<strong>Относительный путь</strong> – привязан к какой-либо \"отправной точке\" и указан по отношению к ней.<br><br>\r\n\r\nНапример, у нас есть картинка picture.png, которая хранится на диске D. Абсолютный путь к ней будет D:\\Data\\MyFiles\\picture.png, а относительно папки Data можно указывать MyFiles\\picture.png.<br><br>\r\n\r\nАбсолютный путь показывает точное местонахождение файла, а относительный показывает путь к файлу от какой-либо \"отправной точки\".",
    "time_create": "2024-09-10T00:29:59.058Z",
    "time_update": "2024-09-24T00:36:38.891Z",
    "is_published": true,
    "slug": "files",
    "direct": 1,
    "sub_lesson": [
      36,
      34,
      31,
      32,
      33,
      30,
      35
    ]
  }
},
{
  "model": "developer.developer",
  "pk": 8,
  "fields": {
    "lesson": "Дата и Время",
    "content": "<strong>Модуль datetime</strong><br><br>\r\nВремя в компьютере хранится для человека в довольно неудобном виде. Это количество секунд, прошедших с полуночи 1 января 1970 года (00:00:00 UTC), этот момент называют «эпохой Unix». Для компьютера такая система удобна, ему так проще хранить время и, например, сравнивать даты. А вот для человека это совершенно непривычно.<br><br>\r\n\r\nДля удобной работы с датой и временем в Python есть модуль datetime. Данный модуль используется для работы со временем и датами, позволяя представлять данную информацию в наиболее удобной форме.<br><br>\r\n\r\nЗа счет множества встроенных методов, предназначенных для удобного отображения, а также манипуляции над временем и датами, повышается функциональность и простота программ.<br><br>\r\n\r\nМодуль datetime состоит из нескольких типов данных. Благодаря их наличию, программист получает доступ ко многим полезным методам:<br><br>\r\n\r\n<li>получение текущих системных даты и времени</li>\r\n<li>вычисление разницы между датами и другие арифметические операции над ними</li>\r\n<li>сравнение даты и времени</li>\r\n<li>форматированный вывод информации о дате и времени</li><br><br>\r\n<strong>Типы данных модуля datetime</strong><br><br>\r\nМодуль datetime включает в себя несколько разных типов данных, каждый из которых обладает собственными методами и атрибутами, а также служит для определенных целей. Все они представлены в следующей таблице, где содержатся их названия и краткое описание.<br><br>\r\n\r\n<li>date - представляет собой информацию о дате, исключая данные о времени, на основе Григорианского календаря</li>\r\n<li>time - представляет собой информацию о времени, полностью исключая сведения о дате</li>\r\n<li>datetime - содержит информацию о времени и дате, основываясь на данных из Григорианского календаря</li>\r\n<li>timedelta - описывает определенный период во времени, который находится между двумя различными моментами</li>\r\n<li>tzinfo - представляет различные сведения о часовом поясе</li>\r\n<li>timezone - описывает время, руководствуясь стандартом UTC</li>",
    "time_create": "2024-09-10T00:31:27.865Z",
    "time_update": "2024-09-24T00:20:03.350Z",
    "is_published": true,
    "slug": "date-time",
    "direct": 1,
    "sub_lesson": [
      29,
      24,
      27,
      28,
      25,
      26
    ]
  }
},
{
  "model": "developer.developer",
  "pk": 9,
  "fields": {
    "lesson": "Устройство памяти",
    "content": "<strong>Компьютерная память</strong><br><br>\r\nКомпьютерная память — часть вычислительной машины, используемая для записи и хранения различного рода данных. Память, как и центральный процессор, неизменно является частью компьютера с 1940-х годов. Память в вычислительных устройствах имеет иерархическую структуру и обычно предполагает использование нескольких запоминающих устройств, имеющих различные характеристики. Выделяют два основных типа памяти:<br><br>\r\n\r\n<li>внутренняя память</li>\r\n<li>внешняя память</li><br><br>\r\n\r\n<strong>Внутренняя память</strong><br><br>\r\nХарактерными особенностями внутренней памяти по сравнению с внешней являются высокое быстродействие и ограниченный объем. Физически внутренняя память компьютера представляет собой интегральные микросхемы, которые размещаются в специальных гнездах на материнской плате. Чем больше размер внутренней памяти, тем более сложную задачу и с большей скоростью может решить компьютер.<br><br>\r\n\r\nВнутренняя память подразделяется на:<br><br>\r\n\r\n<li>постоянную память</li>\r\n<li>оперативную память</li>\r\n<li>кэш-память</li><br><br>\r\nПостоянная память хранит очень важную для нормальной работы компьютера информацию. В частности, в ней содержатся программы, необходимые для проверки основных устройств компьютера, а также для загрузки операционной системы. Очевидно, что изменять эти программы нельзя, так как при любом вмешательстве сразу станет невозможным последующее использование компьютера. Поэтому разрешено только чтение хранимой там постоянно информации. Это свойство постоянной памяти объясняет часто используемое ее английское название Read Only Memory (ROM) — память только для чтения. <br><br>\r\n\r\nВся записанная в постоянную память информация сохраняется и после выключения компьютера, так как такие микросхемы являются энергонезависимыми. Запись информации в постоянную память происходит обычно только один раз — при производстве соответствующих чипов фирмой-изготовителем.<br><br>\r\n\r\nПостоянная память — устройство для долговременного хранения программ и данных.<br><br>\r\n\r\n<strong>Оперативная память</strong><br><br>\r\nОперативная память хранит информацию, необходимую для выполнения программ в текущем сеансе работы: исходные данные, команды, промежуточные и конечные результаты. Эта память работает только при включенном электропитании компьютера. После его выключения содержимое оперативной памяти стирается, так как такие микросхемы являются энергозависимыми устройствами.<br><br>\r\n\r\nУстройство оперативной памяти обеспечивает режимы записи, считывания и хранения информации, причем в любой момент времени возможен доступ к любой ячейке памяти. Часто оперативную память называют RAM (англ. Random Access Memory — память с произвольным доступом).<br><br>\r\n\r\nПри выключении компьютера вся находящаяся в оперативной памяти информация стирается.\r\n\r\nОперативная память характеризуется высоким быстродействием и относительно малой емкостью.\r\n\r\nМикросхемы оперативной памяти монтируются на печатной плате. Каждая такая плата снабжена контактами, расположенными вдоль нижнего края. Для подключения к другим устройствам компьютера такая плата вставляется своими контактами в специальный разъем (слот) на материнской плате. Материнская плата имеет несколько разъемов для модулей оперативной памяти, суммарный объем которых может принимать ряд фиксированных значений, например 2, 4, 8, 16, 32 Гбайт и более.<br><br>\r\n\r\n<strong>Кэш-память</strong><br><br>\r\nКэш-память (англ. cache — тайник, склад) служит для увеличения производительности компьютера.<br><br>\r\n\r\nКэш-память используется при обмене данными между процессором и оперативной памятью. Алгоритм ее работы позволяет сократить частоту обращений процессора к оперативной памяти и, следовательно, повысить производительность компьютера.<br><br>\r\n\r\nСовременные процессоры оснащены кэшем, который состоит зачастую из трех уровней: L1 (первый уровень), L2 (второй уровень), L3 (третий уровень). <br><br>\r\n\r\nКэш первого уровня (L1) – наиболее быстрый уровень кэш-памяти, который работает напрямую с ядром процессора, благодаря этому плотному взаимодействию, данный уровень обладает наименьшим временем доступа и работает на частотах, близких процессору. Размер данного кэша обычно не велик, четырехъядерный процессор Intel Core i7-3770K оснащен 4×32Кб=128Кб  кэш-памяти первого уровня (на каждое ядро по 32Кб).<br><br>\r\n\r\nКэш второго уровня (L2) – второй уровень более масштабный, нежели первый, но в результате, обладает меньшими скоростными характеристиками. Четырехъядерный процессор Intel Core i7-3770K оснащен 4×256КБ=1Мб кэш-памяти второго уровня (на каждое ядро по 256Кб).<br><br>\r\n\r\nКэш третьего уровня (L3) – третий уровень, более медленный, нежели два предыдущих. Но всё равно он гораздо быстрее, чем оперативная память. Объём кэша L3 в i7-3770K составляет 8 Мбайт. Если два предыдущих уровня разделяются на каждое ядро, то данный уровень является общим для всего процессора. Показатель довольно солидный, но не заоблачный.<br><br>\r\n\r\n<strong>Внешняя память</strong><br><br>\r\nНазначение внешней памяти компьютера заключается в долговременном хранении информации любого вида. Выключение питания компьютера не приводит к очистке внешней памяти. Объем этой памяти в тысячи раз больше объема внутренней памяти. Кроме того, в случае необходимости ее можно нарастить. Но обращение к внешней памяти требует гораздо большего времени. Как человек затрачивает на поиск информации в справочной литературе гораздо больше времени, чем на ее поиск в собственной памяти, так и время обращения (доступа) к внешней памяти существенно больше, чем к оперативной.<br><br>\r\n\r\nВ отличие от оперативной памяти, внешняя память не имеет прямой связи с процессором.<br><br>\r\n\r\nК устройствам внешней памяти относятся:<br><br>\r\n\r\n<li>жесткие магнитные диски (HDD — Hard Disk Drive)</li>\r\n<li>твердотельные накопители (SSD — Solid State Drive)</li>\r\n<li>оптические диски (CD-ROM, DVD-ROM, Blue-Ray и т.д.)</li>\r\n<li>флеш-накопители</li>\r\n<li>гибкие магнитные диски</li><br><br>\r\nНаиболее распространенный вариант постоянной памяти — жесткие диски HDD. Они представляют собой один или несколько магнитных дисков, вращающихся с огромной скоростью (от 5 до 12 тысяч оборотов в минуту), и головок, предназначенных для считывания и записи информации. HDD являются надежными носителями информации, позволяют записывать и считывать информацию огромное количество раз. Единственный их минус — они очень восприимчивы к ударам, падениям и прочим механическим воздействиям, особенно в момент работы.<br><br>\r\n\r\nПоследние годы все большее распространение набирают твердотельные накопители SSD. Основные преимущества и недостатки SSD-накопителей:<br><br>\r\n\r\n<li>имеют в разы более высокую скорость чтения и записи, чем HDD</li>\r\n<li>не восприимчивы к механическим воздействиям</li>\r\n<li>стоимость SSD-накопителей превышает стоимость HDD в несколько раз</li>\r\n<li>имеют конечное количество циклов чтения-записи</li>",
    "time_create": "2024-09-10T00:32:16.552Z",
    "time_update": "2024-09-26T02:57:51.026Z",
    "is_published": true,
    "slug": "memory",
    "direct": 1,
    "sub_lesson": [
      41,
      37,
      38,
      39,
      65,
      40
    ]
  }
},
{
  "model": "developer.developer",
  "pk": 10,
  "fields": {
    "lesson": "Обработка исключений",
    "content": "<strong>Типы ошибок</strong><br><br>\r\nРазработка программы на любом языке программирования практически всегда бывает связана с возникновением различного рода ошибок, препятствующих получению желаемого результата.<br><br>\r\n\r\nОбычно выделяют следующие три категории ошибок:<br><br>\r\n\r\n<li>синтаксические – возникают из-за синтаксических погрешностей кода</li>\r\n<li>логические – проявляются вследствие логических неточностей в алгоритме</li>\r\n<li>ошибки времени выполнения, исключения – вызваны некорректными действиями пользователя или системы</li><br><br>\r\n\r\n<strong>Синтаксические ошибки</strong><br><br>\r\nСинтаксические ошибки являются следствием несоблюдения общепринятого синтаксиса языка. Другими словами, это ошибки, связанные с неправильно набранным кодом. Например пропуск круглой скобки, запятой или двоеточия.\r\n\r\nВ приведенном ниже коде:\r\n<pre>\r\n<strong>\r\nprint('Hello, world!'\r\n</strong>\r\n</pre>\r\nдопущена одна синтаксическая ошибка: пропущена закрывающая скобка. При попытке его запуска получим:\r\n<pre>\r\n<strong>\r\nSyntaxError: '(' was never closed\r\n</strong>\r\n</pre>\r\nВ приведенном ниже коде:\r\n<pre>\r\n<strong>\r\ndef square(num)\r\n    return num ** 2\r\n</strong>\r\n</pre>\r\nдопущена также синтаксическая ошибка: пропущен символ двоеточия в описании функции. При попытке его запуска получим:\r\n<pre>\r\n<strong>\r\n    def square(num)\r\n                   ^\r\nSyntaxError: expected ':'\r\n</strong>\r\n</pre>\r\nСинтаксические ошибки легко отлавливаются интерпретатором, который сразу же сообщает программисту о проблеме в написанном коде. <br><br>\r\n\r\n<strong>Логические ошибки</strong><br><br>\r\nЛогические ошибки считаются более сложными в выявлении, поскольку не отлавливаются интерпретатором. Обычно они вызваны определенным недостатком в логике программы, из-за чего результат работы программы отличается от желаемого результата. Возможным решением проблемы является тестирование программы на разных примерах входных данных, для которых известен правильный результат.\r\n\r\nВ приведенном ниже коде:\r\n<pre>\r\n<strong>\r\ndef avg(a, b):\r\n    return a + b / 2\r\n</strong>\r\n</pre>\r\nописана функция avg(), подсчитывающая среднее значение переданных в нее аргументов. В теле функции допущена логическая ошибка, пропущены скобки, на два должна делиться сумма чисел a и b.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(avg(6, 14))\r\n</strong>\r\n</pre>\r\nвыводит неверный результат:\r\n<pre>\r\n<strong>\r\n13.0\r\n</strong>\r\n</pre>\r\nОбратите внимание на то, что приведенная выше функция avg() не всегда работает неверно.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(avg(0, 7))\r\n</strong>\r\n</pre>\r\nвыводит верный результат:\r\n<pre>\r\n<strong>\r\n3.5\r\n</strong>\r\n</pre>\r\nЛогические ошибки могут проявлять себя только при определенных условиях. Часто код с логической ошибкой может работать достаточно долго.<br><br>\r\n\r\n<strong>Ошибки времени выполнения</strong><br><br>\r\nИсключения представляют собой еще один вид ошибок, которые проявляются в зависимости от наличия обстоятельств, меняющих ход выполнения программы. Исключения являются ошибками времени выполнения, возникающими в процессе выполнения программы и связанными с некорректностью переданных в программу данных, недоступностью ресурсов и т.д.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnum1 = 10\r\nnum2 = 0\r\n\r\nprint(num1 / num2)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nZeroDivisionError: division by zero\r\n</strong>\r\n</pre>\r\nДеление на ноль провоцирует исключительную ситуацию, которая приводит к аварийному завершению работы и выводу ошибки на экран. ZeroDivisionError — это название исключения, а division by zero — его краткое описание.<br><br>\r\n\r\nЕсли мы хотим, чтобы программа работала с широким диапазоном входных данных и внешних условий, то надо учитывать исключения, программа должна их верно обрабатывать.<br><br>\r\n\r\nПо умолчанию при обнаружении необработанного исключения Python немедленно останавливает выполнение программы и выводит сообщение об ошибке.<br><br>\r\n\r\n<strong>Работа с кодами возврата</strong><br><br>\r\nВ эпоху расцвета процедурного программирования синтаксис работы с исключениями был тривиален и основывался на том, что вернула функция. Если функция возвращала True — все хорошо, если же False — то произошла ошибка. При этом сразу выделились два подхода к работе с ошибками:<br><br>\r\n\r\n<li>подход два в одном — функция возвращает False как для ожидаемой, так и для неожиданной ошибки. Такой подход как правило применялся в API общего назначения и коде пользовательских программ, когда большую часть ошибок можно было смело считать фатальными</li>\r\n<li>подход разделения ошибок, при котором функция возвращает False в случае неожиданной ошибки, а ожидаемую ошибку возвращает отдельным возвращаемым значением (числовым). Такой подход применялся в более надежном коде и подразумевал разделение на ожидаемые ошибки и неожиданные</li>\r\nДля каждой ошибки можно придумать свой код возврата. Коды не должны совпадать с возможными обычными ответами.<br><br>\r\n\r\nНесмотря на то, что язык Python полностью поддерживает работу с исключениями, как с полноценными объектами, мы все же можем встретить следы работы с кодами возврата, которые Python унаследовал от языка C.<br><br>\r\n\r\nСтроковый тип данных str содержит два похожих метода find() и index(). Оба метода выполняют одну и ту же работу, а именно ищут позицию первого вхождения подстроки в заданную строку. Однако в случае если подстрока не найдена, то поведение методов отличается. Метод find() использует механизм кодов возврата, в то время как метод index() возбуждает исключение.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ntext = 'Hello, world!'\r\n\r\nprint(text.find('w'))\r\nprint(text.find('a'))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n7\r\n-1\r\n</strong>\r\n</pre>\r\nИз-за того, что в строке Hello, world! нет символа a, нам было возвращено значение −1. Это и есть код возврата.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ntext = 'Hello, world!'\r\n\r\nprint(text.index('a'))\r\n</strong>\r\n</pre>\r\nприводит к возникновению исключения:\r\n<pre>\r\n<strong>\r\nValueError: substring not found\r\n</strong>\r\n</pre>\r\nПри работе с кодами возврата даже простая функция для обработки пользовательских данных обрастает дополнительным кодом, проверкой многих условий и «магическими» кодами возврата. Если функция с кодом возврата находится глубоко в стеке вызовов, то придется сделать так, чтобы ее правильно обрабатывала вся вышестоящая цепочка функций. Каждая из них должна принимать код и возвращать свой.<br><br>\r\n\r\nУ работы с исключениями есть преимущества перед кодами возврата. В современных языках программирования, таких как Python, C#, Java, GO и т.д., используются именно исключения.",
    "time_create": "2024-09-10T00:33:18.541Z",
    "time_update": "2024-09-24T01:05:46.127Z",
    "is_published": true,
    "slug": "exceptions",
    "direct": 1,
    "sub_lesson": [
      42,
      43,
      44,
      45,
      46
    ]
  }
},
{
  "model": "developer.developer",
  "pk": 11,
  "fields": {
    "lesson": "Рекурсия",
    "content": "<strong>Введение в рекурсию</strong><br><br>\r\nРанее мы встречались с функциями, которые вызывают другие функции. Рассмотрим функцию get_stat(), которая принимает в качестве аргумента непустой список целых чисел и возвращает кортеж, состоящий из трех значений: минимальный элемент списка, максимальный элемент списка и среднее арифметическое значение всех элементов списка.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndef get_stat(numbers):\r\n    minimum = min(numbers)\r\n    maximum = max(numbers)\r\n    average = sum(numbers)/len(numbers)\r\n\r\n    return (minimum, maximum, average)\r\n\r\nprint(get_stat([1, 2, 3, 4, 5]))\r\nprint(get_stat([7]))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n(1, 5, 3.0)\r\n(7, 7, 7.0)\r\n</strong>\r\n</pre>\r\nКак мы видим, написанная нами функция get_stat() вызывает функции: min(), max(), sum(), len(). На практике такая ситуация очень распространена.<br><br>\r\n\r\nБывают случаи, когда функция также вызывает саму себя. Такая функция называется рекурсивной.\r\n<strong>Рекурсивная функция</strong> – это функция, которая вызывает саму себя.\r\n\r\nРассмотрим определение рекурсивной функции message(), которая вызывает саму себя.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndef message():\r\n    print('Это рекурсивная функция')\r\n    message()\r\n\r\nmessage()\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nЭто рекурсивная функция\r\nЭто рекурсивная функция\r\nЭто рекурсивная функция\r\nЭто рекурсивная функция\r\nЭто рекурсивная функция\r\nЭто рекурсивная функция\r\nЭто рекурсивная функция\r\nЭто рекурсивная функция\r\nЭто рекурсивная функция\r\nЭто рекурсивная функция\r\n...\r\n</strong>\r\n</pre>\r\nИ этот результат будет повторяться бесконечно (почти).<br><br>\r\n\r\nФункция message() выводит на экран строку текста Это рекурсивная функция, а затем вызывает саму себя. При каждом вызове функцией самой себя цикл повторяется. Несложно заметить, что при такой реализации функции message() в ней не предусмотрен способ остановки рекурсивных вызовов. Эта функция выглядит как бесконечный цикл, поскольку отсутствует программный код, который остановил бы ее бесконечные вызовы.<br><br>\r\n\r\nВ ситуации когда не предусмотрен способ остановки рекурсивных вызовов происходит переполнение аппаратного стека и возбуждается исключение RecursionError.<br><br>\r\n\r\nПодобно циклу, рекурсивная функция должна иметь определенный способ управлять количеством своих повторов.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndef message(times):\r\n    if times > 0:\r\n        print('Это рекурсивная функция')\r\n        message(times - 1)\r\n\r\nmessage(5)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nЭто рекурсивная функция\r\nЭто рекурсивная функция\r\nЭто рекурсивная функция\r\nЭто рекурсивная функция\r\nЭто рекурсивная функция\r\n</strong>\r\n</pre>\r\nТеперь функция message() принимает аргумент times, который задает количество раз, которые функция должна выводить сообщение. Строка текста Это рекурсивная функция будет выводиться до тех пор, пока times больше нуля, при этом функция будет вызывать саму себя повторно, передавая уменьшенный на единицу аргумент.<br><br>\r\n\r\nВо время каждого вызова функции message() в оперативной памяти создается новый экземпляр переменной times. При первом вызове функции times имеет значение 5. Когда функция себя вызывает, создается новый экземпляр переменной times и в него передается значение 4. Этот цикл повторяется до тех пор, пока в функцию в качестве аргумента не будет передан 0. <br><br>\r\n\r\n\r\n\r\nФункция message() вызывается шесть раз. В первый раз она вызывается из основной программы, а остальные пять раз она вызывает саму себя. Количество раз, которые функция вызывает саму себя, называется глубиной рекурсии. В этом примере глубина рекурсии равняется пяти. Когда функция достигает своего шестого вызова, значение переменной times равно 0. В этой точке условное выражение оператора if становится ложным, и поэтому функция завершает свою работу. Поток управления программы возвращается из шестого экземпляра функции в точку в пятом экземпляре непосредственно после вызова рекурсивной функции.<br><br>\r\n\r\nПоскольку после вызова рекурсивной функции больше нет инструкций, пятый экземпляр функции message() возвращает поток управления программы назад в четвертый экземпляр функции и т.д.<br><br>\r\n\r\nДавайте модифицируем нашу функцию message(), добавив строку кода, которая выводит текущее значение переменной times после рекурсивного вызова.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndef message(times):\r\n    if times > 0:\r\n        print('Это рекурсивная функция.')\r\n        message(times - 1)\r\n        print(times)\r\n\r\nmessage(5)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nЭто рекурсивная функция.\r\nЭто рекурсивная функция.\r\nЭто рекурсивная функция.\r\nЭто рекурсивная функция.\r\nЭто рекурсивная функция.\r\n1\r\n2\r\n3\r\n4\r\n5\r\n</strong>\r\n</pre>\r\nОбратите внимание на то, что сначала печатается значение 1, затем 2 и так далее до 5.<br><br>\r\n\r\nРекурсия может оказаться мощным инструментом для решения повторяющихся задач. Задача может быть решена на основе рекурсии, если ее разделить на уменьшенные задачи, которые по структуре идентичны общей задаче.<br><br>\r\n\r\nОбратите внимание, что рекурсия никогда не является непременным условием для решения задачи. Любая задача, которая может быть решена рекурсивно, также может быть решена на основе цикла, и наоборот.<br><br>\r\n\r\nРекурсивные алгоритмы обычно менее эффективны, чем итеративные алгоритмы. Это связано с тем, что процесс вызова функции требует выполнения компьютером нескольких действий. Эти действия включают выделение памяти под параметры и локальные переменные и для хранения адреса местоположения программы. Такие действия, которые иногда называются накладными расходами, происходят при каждом вызове функции. Накладные расходы не требуются при использовании цикла.<br><br>\r\n\r\nНекоторые повторяющиеся задачи легче решаются на основе рекурсии, чем на основе цикла. Там, где цикл приводит к более быстрому времени исполнения, программист может быстрее разработать рекурсивный алгоритм. В целом рекурсивная функция работает следующим образом:<br><br>\r\n\r\n<li>если в настоящий момент задача может быть решена без рекурсии, то функция ее решает</li>\r\n<li>если в настоящий момент задача не может быть решена, то функция ее сводит к уменьшенной и при этом аналогичной задаче и вызывает саму себя для решения этой уменьшенной задачи</li><br>\r\nДля того чтобы применить такой подход, во-первых, мы идентифицируем по крайней мере один случай, в котором задача может быть решена без рекурсии. Он называется базовым случаем. Во-вторых, мы определяем то, как задача будет решаться рекурсивно во всех остальных случаях. Это называется рекурсивным случаем. В рекурсивном случае мы все время должны сводить задачу к уменьшенному варианту исходной задачи. С каждым рекурсивным вызовом задача уменьшается. В результате будет достигнут базовый случай, и рекурсия прекратится.<br><br>\r\n\r\n<strong>Хвостовая рекурсия</strong> — частный случай рекурсии, при котором любой рекурсивный вызов является последней операцией перед возвратом из функции.\r\n\r\nПример функции с хвостовой рекурсией:\r\n<pre>\r\n<strong>\r\ndef message(times):\r\n    if times > 0:\r\n        print('Это рекурсивная функция')\r\n        message(times - 1)\r\n</strong>\r\n</pre>\r\nПример функции с рекурсией, которая не является хвостовой:\r\n<pre>\r\n<strong>\r\ndef message(times):\r\n    if times > 0:\r\n        print('Это рекурсивная функция.')\r\n        message(times - 1)\r\n        print(times)\r\n</strong>\r\n</pre>\r\nХвостовой вид рекурсии примечателен тем, что может быть легко заменён на итерацию путём корректной перестройки кода функции. Оптимизация хвостовой рекурсии путём преобразования её в итерацию реализована во многих языках программирования. В Python такой оптимизации нет.<br><br>\r\nАппаратный стек используется для нужд выполняющейся программы: хранения переменных и вызова функций. При вызове функции процессор помещает в стек адрес команды, следующей за командой вызова функции, — «адрес возврата» из функции. По команде возврата из функции из стека извлекается адрес возврата и осуществляется переход по этому адресу.",
    "time_create": "2024-09-10T00:33:58.572Z",
    "time_update": "2024-09-24T01:26:38.588Z",
    "is_published": true,
    "slug": "recursion",
    "direct": 1,
    "sub_lesson": [
      47
    ]
  }
},
{
  "model": "developer.developer",
  "pk": 12,
  "fields": {
    "lesson": "Итераторы",
    "content": "<strong>Итерируемые объекты</strong><br><br>\r\nВ языке Python под итерируемым объектом подразумевают объект, который можно итерировать, то есть проходиться по нему, перебирая каждый элемент раз за разом. К примеру, уже известные нам списки (тип list), строки (тип str), кортежи (тип tuple), множества (тип set), словари (тип dict) являются итерируемыми, поскольку мы можем перебирать каждый элемент этих объектов.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnumbers = [1, 2, 3]\r\nname = 'python'\r\n\r\nfor num in numbers:        # итерируем по списку, перебирая каждый элемент\r\n    print(num)\r\n\r\nfor c in name:             # итерируем по строке, перебирая каждый символ\r\n    print(c)\r\n\r\nprint(2 in numbers)        # неявное итерирование по списку\r\nprint('A' in name)         # неявное итерирование по строке\r\nprint(*numbers)            # неявное итерирование по списку при распаковке\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n1\r\n2\r\n3\r\np\r\ny\r\nt\r\nh\r\no\r\nn\r\nTrue\r\nFalse\r\n1 2 3\r\n</strong>\r\n</pre>\r\nЕсли подходить более формально в Python, существует два типа итерируемых объектов:<br><br>\r\n\r\n<li>итераторы</li>\r\n<li>коллекции и последовательности</li><br><br>\r\n\r\n<strong>Итераторы</strong><br><br>\r\n<strong>Итератор</strong> — специальный объект, который выдает свои элементы по одному за раз.<br><br>\r\n\r\nЕсли итератор передать во встроенную функцию next(), то эта функция вернет его следующий элемент. При этом сам итератор также сдвинется на следующий элемент. При следующем вызове функция next() вернет следующий элемент и т.д. Если же в итераторе элементов больше не осталось, то вызов функции next() приведет к возникновению исключения StopIteration.<br><br>\r\n\r\n<strong>Коллекции и последовательности</strong><br><br>\r\n<strong>Коллекция</strong> — объект, хранящий набор значений одного или различных типов, позволяющий обращаться к этим значениям, а также применять специальные функции и методы, зависящие от типа коллекции.<br><br>\r\n\r\nТакже среди коллекций можно выделить те, элементы которых пронумерованы индексами и расположены в строгом порядке. Такие коллекции <strong>называются последовательностями</strong>. Например, списки, строки и кортежи являются последовательностями, а множества и словари нет.<br><br>\r\n\r\nКоллекции не являются итераторами сами по себе, но позволяют создать итератор на своей основе.<br><br>\r\n\r\nДля того чтобы создать итератор на основе некоторой коллекции, достаточно вызвать встроенную функцию iter(), передав нужную коллекцию в качестве ее аргумента.<br><br>\r\n\r\nНапример, список не является итератором, но на его основе можно создать сколько угодно итераторов, каждый из которых будет перебирать элементы списка от первого до последнего.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnumbers = [1, 2, 3]\r\n\r\niterator = iter(numbers)          # создаем итератор на основании списка\r\n\r\nprint(next(iterator))             # запрашиваем и печатаем первый элемент итератора\r\nprint(next(iterator))             # запрашиваем и печатаем второй элемент итератора\r\nprint(next(iterator))             # запрашиваем и печатаем третий элемент итератора\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n1\r\n2\r\n3\r\n</strong>\r\n</pre>\r\nПолучить итератор можно из любого итерируемого объекта, для этого нужно передать итерируемый объект во встроенную функцию iter().<br><br>\r\n\r\nПосле того как мы получили итератор, мы можем передать его встроенной функции next(). При каждом новом вызове, функция next() возвращает очередной элемент итератора. Если же в итераторе элементов больше не осталось, то функция next() возбуждает исключение StopIteration.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnumbers = [1, 2, 3]\r\n\r\niterator = iter(numbers)          # создаем итератор на основе списка\r\n\r\nprint(next(iterator))             # запрашиваем и печатаем первый элемент итератора\r\nprint(next(iterator))             # запрашиваем и печатаем второй элемент итератора\r\nprint(next(iterator))             # запрашиваем и печатаем третий элемент итератора\r\n\r\nprint(next(iterator))             # возбуждается исключение StopIteration\r\n</strong>\r\n</pre>\r\nприводит к возникновению исключения StopIteration.<br><br>\r\n\r\nЕдинственное, что мы можем сделать с итератором, — передать его функции next(). Как только итератор становится пустым и порождается исключение StopIteration, он становится совершенно бесполезным.<br><br>\r\n\r\nОсновная разница между последовательностями и итераторами, заключается в том, что в последовательностях элементы пронумерованы индексами, начиная от нуля. Мы можем обратиться к конкретному элементу таких объектов по индексу. В итераторах мы можем лишь последовательно запрашивать следующий элемент.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnumbers = [1, 2, 3, 4]            # список\r\nletters = ('a', 'b', 'c')         # кортеж\r\nlanguage = 'python'               # строка\r\n\r\nprint(numbers[3])                 # обращение по индексу\r\nprint(letters[2])                 # обращение по индексу\r\nprint(language[5])                # обращение по индексу\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n4\r\nc\r\nn\r\n</strong>\r\n</pre>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nletters = ('a', 'b', 'c')\r\n\r\niterator = iter(letters)           # создаем итератор на основе кортежа\r\n\r\nprint(iterator[1])                 # обращение по индексу\r\n</strong>\r\n</pre>\r\nприводит к возникновению исключения:\r\n<pre>\r\n<strong>\r\nTypeError: 'tuple_iterator' object is not subscriptable\r\n</strong>\r\n</pre>\r\n\r\n<strong>Преимущества итераторов</strong><br><br>\r\nОсновными преимуществами использования итераторов являются:<br><br>\r\n\r\n<li>однотипность работы с объектами разных типов</li>\r\n<li>ленивые вычисления и экономия потребляемой памяти</li>\r\n<li>комбинация множества итераторов для создания понятной и читабельной программы</li><br><br>\r\n\r\n<strong>Однотипность работы с объектами разных типов</strong><br><br>\r\nИтераторы позволяют разным объектам притворяться одинаковыми. Списки, кортежи, строки, множества, словари, объекты типа range имеют разные типы, но мы можем использовать любой из этих объектов:<br><br>\r\n\r\n<li>в цикле for</li>\r\n<li>в функциях высшего порядка map(), filter(), reduce(), reversed() и т.д.</li>\r\n<li>для проверки наличия некоторого значения с помощью оператора принадлежности in</li>\r\n<li>для распаковки элементов с помощью * и т.д.</li><br><br>\r\n\r\nЦикл for в Python работает по следующему принципу:<br><br>\r\n\r\n<li>создает итератор на основе итерируемого объекта</li>\r\n<li>запрашивает очередной элемент из итератора с помощью функции next() и передает его в выполняемый блок кода (тело цикла)</li>\r\n<li>останавливается при получении исключения StopIteration</li><br>\r\nБлагодаря этому, в цикл for можно передать и список, и кортеж, и строку, и объект типа range, и многие другие объекты, которые имеют свои итераторы.\r\n\r\nПо сути, приведенный ниже код:\r\n<pre>\r\n<strong>\r\nnumbers = [1, 2, 3, 4]\r\n\r\nfor num in numbers:\r\n    print(num)\r\n</strong>\r\n</pre>\r\nза кулисами превращается в:\r\n<pre>\r\n<strong>\r\nnumbers = [1, 2, 3, 4]\r\n\r\niterator = iter(numbers)           # создается итератор\r\n\r\nwhile True:\r\n    try:\r\n        item = next(iterator)\r\n        print(item)\r\n    except StopIteration:\r\n        break\r\n</strong>\r\n</pre>\r\n\r\n<strong>Ленивые вычисления и экономия потребляемой памяти</strong><br><br>\r\nЛенивые вычисления предполагают, что не нужно ничего делать до тех пор, пока в этом нет необходимости. Это не просто удобно, но и позволяет экономить память и время на вычисление.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnumbers = range(5)             # 5 чисел в последовательности\r\n\r\nfor num in numbers:\r\n    print(num)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n0\r\n1\r\n2\r\n3\r\n4\r\n</strong>\r\n</pre>\r\nОбъекты типа range являются итерируемыми объектами. Цикл for создает на основе объекта range итератор, у которого запрашивает элементы по одному, пока не будет достигнут конец последовательности чисел. В нашем примере, пока не будет получено число 4.<br><br>\r\n\r\nВажно понимать, что объект типа range не хранит весь набор чисел. Он создает новое число (на лету) только тогда, когда оно потребуется, при этом старые значения не хранятся. Размер объектов range не зависит от количества чисел, которые предполагается перебрать, ведь нужно помнить только начальное и конечное значения последовательности, шаг и текущее значение.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom sys import getsizeof\r\n\r\nnumbers1 = range(5)                  # 5 чисел в последовательности\r\nnumbers2 = range(100000)             # 100000 чисел в последовательности\r\nnumbers3 = range(10000000000000)     # 10000000000000 чисел в последовательности\r\n\r\nprint(getsizeof(numbers1))\r\nprint(getsizeof(numbers2))\r\nprint(getsizeof(numbers3))\r\n</strong>\r\n</pre>\r\nвыводит (размер в байтах):\r\n<pre>\r\n<strong>\r\n48\r\n48\r\n48\r\n</strong>\r\n</pre>\r\nВсе объекты range имеют один и тот же размер в памяти — 48 байт. Такой подход позволяет создавать \"большие\" итераторы (даже бесконечные), не занимая много памяти.<br><br>\r\n\r\nЗаметим, что мы можем преобразовать любой итерируемый объект в список. Однако при таком преобразовании все элементы итерируемого объекта будут записаны в память.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom sys import getsizeof\r\n\r\nnumbers1 = list(range(5))                  # 5 чисел в списке\r\nnumbers2 = list(range(100000))             # 100000 чисел в списке\r\n\r\nprint(getsizeof(numbers1))\r\nprint(getsizeof(numbers2))\r\n</strong>\r\n</pre>\r\nвыводит (размер в байтах):\r\n<pre>\r\n<strong>\r\n96\r\n800056\r\n</strong>\r\n</pre>\r\nЧем больше элементов в списке, тем больше памяти он занимает. Преобразование итерируемого объекта в список не всегда будет заканчиваться удачно.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom sys import getsizeof\r\n\r\nnumbers3 = list(range(10000000000000))     # 10000000000000 чисел в списке\r\n\r\nprint(getsizeof(numbers3))\r\n</strong>\r\n</pre>\r\nприводит в возникновению исключения MemoryError. Python не позволяет нам создать такой большой список 😔.<br><br>\r\n\r\nОбъекты типа range являются ленивыми, преобразовывать их в списки стоит с особенной аккуратностью и только тогда, когда это действительно необходимо.<br><br>\r\n\r\n<strong>Комбинация множества итераторов</strong><br><br>\r\nУ итераторов есть замечательная особенность: их можно комбинировать. Это позволяет вместо огромных циклов с перемешанными этапами обработки писать небольшие блоки, которые стыкуются друг с другом.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nsentence = 'In the face of ambiguity refuse the temptation to guess'\r\n\r\nfilter_iterator = filter(lambda word: len(word) > 4, sentence.split())   # фильтруем\r\nmap_iterator = map(lambda word: word.upper(), filter_iterator)           # преобразовываем\r\nenumerate_iterator = enumerate(map_iterator, 1)                          # нумеруем\r\n\r\nfor index, value in enumerate_iterator:                                  # выводим\r\n    print(f'{index}. {value}')\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n1. AMBIGUITY\r\n2. REFUSE\r\n3. TEMPTATION\r\n4. GUESS\r\n</strong>\r\n</pre>\r\nОбратите внимание на то, что все три объекта filter_iterator, map_iterator, enumerate_iterator являются итераторами. Они не хранят все данные в памяти, а создают и выдают их по мере того, как их запрашивают. Другими словами, при обращении к очередному элементу enumerate_iterator произойдет последовательное обращение сначала к элементу map_iterator, а затем к элементу filter_iterator.<br><br>\r\n\r\nИмейте в виду, что от порядка, в котором комбинируются итераторы, зависит итоговый результат.<br><br>\r\n\r\nВстроенной функции next() можно передать второй аргумент, который будет возвращен вместо возбуждения исключения StopIteration, если в итераторе больше не осталось элементов.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnums = iter([1, 2, 3, 4])\r\n\r\nprint(next(nums))\r\nprint(next(nums))\r\nprint(next(nums))\r\nprint(next(nums))\r\nprint(next(nums, -1))\r\nprint(next(nums, -1))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n1\r\n2\r\n3\r\n4\r\n-1\r\n-1\r\n</strong>\r\n</pre>\r\nНе забывайте, что коллекции не являются итераторами. Поэтому встроенная функция next() не позволяет получить очередной элемент, например списка, строки и т.д.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnums = [1, 2, 3, 4]\r\n\r\nprint(next(nums))\r\n</strong>\r\n</pre>\r\nприводит к возникновению исключения:\r\n<pre>\r\n<strong>\r\nTypeError: 'list' object is not an iterator\r\n</strong>\r\n</pre>\r\nНо на основе коллекции можно создать итератор.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnums = [1, 2, 3, 4]\r\nnums_iterator = iter(nums)       # создаем итератор\r\n\r\nprint(type(nums))\r\nprint(type(nums_iterator))\r\nprint(next(nums_iterator))\r\nprint(next(nums_iterator))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nclass 'list'\r\nclass 'list_iterator'\r\n1\r\n2\r\n</strong>\r\n</pre>\r\nИтераторы могут генерировать бесконечное число значений, не занимая много дополнительной памяти. Например, итератор может генерировать все натуральные числа или все простые числа. Или генерировать значения, количество которых заранее неизвестно.<br><br>\r\n\r\nВстроенная функция len() не работает с большей частью итерируемых объектов, потому что их длина может быть очень большой или даже бесконечной.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnumbers = [1, 2, 3, 4, 5, 6]\r\n\r\nevens = filter(lambda num: num % 2 == 0, numbers)\r\nprint(len(evens))\r\n</strong>\r\n</pre>\r\nприводит к возникновению ошибки:\r\n<pre>\r\n<strong>\r\nTypeError: object of type 'filter' has no len()\r\n</strong>\r\n</pre>\r\nВ случае с итерируемыми объектами, которые являются итераторами, посчитать длину можно только если полностью пройти итератор от начала до конца, что может быть очень долго. Для итераторов, про которые заранее неизвестно, бесконечные они или нет, функция len() могла бы работать не просто долго, а вечно. Именно поэтому функция len() не применима к итераторам.<br><br>\r\n\r\nДля некоторых итерируемых объектов длину можно посчитать мгновенно, не перебирая элементы. К таким объектам можно отнести числовые последовательности range.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnumbers1 = range(5)                  # 5 чисел в последовательности\r\nnumbers2 = range(100000)             # 100000 чисел в последовательности\r\nnumbers3 = range(10000000000000)     # 10000000000000 чисел в последовательности\r\n\r\nprint(len(numbers1))\r\nprint(len(numbers2))\r\nprint(len(numbers3))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n5\r\n100000\r\n10000000000000\r\n</strong>\r\n</pre>\r\n\r\nОбратите внимание на то, что на основе одного списка (кортежа, строки, множества, словаря и т.д.) мы можем создавать множество несвязанных между собой итераторов. Каждый из них будет независимо от других перемещаться от начала до конца.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnumbers = list(range(1, 10))\r\n\r\niterator1 = iter(numbers)\r\niterator2 = iter(numbers)\r\niterator3 = iter(numbers)\r\n\r\nprint(numbers)\r\n\r\nprint(next(iterator1))\r\nprint(next(iterator1))\r\n\r\nprint(next(iterator2))\r\n\r\nprint(next(iterator3))\r\nprint(next(iterator3))\r\nprint(next(iterator3))\r\nprint(next(iterator3))\r\nprint(next(iterator3))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\r\n1\r\n2\r\n1\r\n1\r\n2\r\n3\r\n4\r\n5\r\n</strong>\r\n</pre>\r\n Важно понимать разницу между итерируемыми объектами и итераторами:<br><br>\r\n\r\n<li>iterable (итерируемый) — это свойство того, по кому будет происходить итерирование</li>\r\n<li>iterator (итерирующий) — это тот, кто ходит</li><br>\r\nДругими словами, iterable — сущность, по которой ходим, книга, которую листаем, а iterator — листающая сущность, палец, который указывает на нужный лист в книге.",
    "time_create": "2024-09-10T00:34:55.981Z",
    "time_update": "2024-09-24T01:47:24.934Z",
    "is_published": true,
    "slug": "iterators",
    "direct": 1,
    "sub_lesson": [
      48,
      49,
      50
    ]
  }
},
{
  "model": "developer.developer",
  "pk": 13,
  "fields": {
    "lesson": "Генераторы",
    "content": "<strong>Функции генераторы</strong><br><br>\r\n<strong>Функция генератор</strong> – это функция, которая возвращает итератор. Она выглядит как обычная функция, за исключением того, что использует выражение yield, а не return.<br><br>\r\n\r\nКогда вызывается обычная функция, она получает личное пространство имен, в котором создаются ее локальные переменные. Когда обычная функция достигает оператора return, локальные переменные уничтожаются и значение возвращается вызывающей стороне. Последующий вызов той же функции создает новое локальное пространство имен и новый набор локальных переменных.<br><br>\r\n\r\nФункция генератор, напротив сохраняет локальные переменные от вызова к вызову. Это своего рода возобновляемая функция.<br><br>\r\n\r\nРассмотрим пример функции генератора, которая порождает последовательность целых чисел от 0 (включительно) до n (не включительно).\r\n<pre>\r\n<strong>\r\ndef generate_ints(n):\r\n    for num in range(n):\r\n        yield num\r\n</strong>\r\n</pre>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ngenerator1 = generate_ints(5)           # создаем генератор, порождающий числа 0 1 2 3 4\r\n\r\nprint(type(generator1))\r\n\r\nprint(next(generator1))\r\nprint(next(generator1))\r\nprint(next(generator1))\r\nprint(next(generator1))\r\nprint(next(generator1))\r\n\r\ngenerator2 = generate_ints(3)           # создаем генератор, порождающий числа 0 1 2\r\n\r\nfor num in generator2:\r\n    print(num)\r\n\r\nnum1, num2 = generate_ints(2)           # создаем генератор, порождающий числа 0 1\r\n\r\nprint(num1, num2)\r\nвыводит:\r\n\r\n<class 'generator'>\r\n0\r\n1\r\n2\r\n3\r\n4\r\n0\r\n1\r\n2\r\n0 1\r\n</strong>\r\n</pre>\r\nПо сути, функция generate_ints() просто возвращает генератор, порождающий последовательность нужных чисел. <br><br>\r\n\r\n<strong>Генератор</strong> – это итератор, который порождает значения, переданные yield. Когда выполнение доходит до конца функции, объект генератор возбуждает исключение StopIteration в полном соответствии с протоколом итератора.<br><br>\r\n\r\nРабота с генератором происходит по стандартному сценарию работы с итератором. Мы можем:<br><br>\r\n\r\n<li>вызывать функцию next() для получения очередного значения генератора</li>\r\n<li>итерироваться с помощью цикла for по генератору</li>\r\n<li>распаковывать генератор</li>\r\n<li>проверять принадлежность с помощью оператора in\r\nи т.д.</li><br><br>\r\nФункция генератор возвращает объект специального типа <class 'generator'>, который реализует протокол итератора, то есть является самым настоящим итератором.<br><br>\r\n\r\nКак несложно понять, мы можем достичь эффекта генераторов вручную, написав свой собственный класс, поддерживающий протокол итератора.<br><br>\r\n\r\nКласс GenerateInts полностью аналогичен указанной выше функции генератору:\r\n<pre>\r\n<strong>\r\nclass GenerateInts:                             \r\n    def __init__(self, n):         # конструктор принимает верхнюю границу диапазона\r\n        self.n = n\r\n        self.current = 0\r\n    \r\n    def __iter__(self):\r\n        return self\r\n    \r\n    def __next__(self): \r\n        if self.current == self.n:\r\n            raise StopIteration\r\n        else:\r\n            self.current += 1\r\n            return self.current - 1\r\n</strong>\r\n</pre>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\niterator1 = GenerateInts(5)           # создаем итератор, содержащий числа 0 1 2 3 4\r\n\r\nprint(type(iterator1))\r\n\r\nprint(next(iterator1))\r\nprint(next(iterator1))\r\nprint(next(iterator1))\r\nprint(next(iterator1))\r\nprint(next(iterator1))\r\n\r\niterator2 = GenerateInts(3)           # создаем итератор, содержащий числа 0 1 2\r\n\r\nfor num in iterator2:\r\n    print(num)\r\n\r\nnum1, num2 = GenerateInts(2)          # создаем итератор, содержащий числа 0 1\r\n\r\nprint(num1, num2)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n<class '__main__.GenerateInts'>\r\n0\r\n1\r\n2\r\n3\r\n4\r\n0\r\n1\r\n2\r\n0 1\r\n</strong>\r\n</pre>\r\nНа данном примере видно, насколько генераторные функции упрощают процесс реализации собственных итераторов, значительно сокращая количество строк кода.<br><br>\r\n\r\nМожет показаться, что в теле функции генератора всегда должен быть цикл, но это необязательно.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndef generate_1234():\r\n    yield 1\r\n    yield 2\r\n    yield 3\r\n    yield 4\r\n\r\nprint(*generate_1234())         # распаковка генератора\r\n</strong>\r\n</pre>\r\nсодержит определение функции генератора generate_1234(), которая порождает последовательность значений 1,2,3,4 и выводит:\r\n<pre>\r\n<strong>\r\n1 2 3 4\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функции генераторы с побочными действиями</strong><br><br>\r\nФункция генератор может не только порождать значения, но и совершать различные побочные действия во время выполнения, такие как:<br><br>\r\n\r\n<li>вывод текста на экран</li>\r\n<li>запись данных в файл</li>\r\n<li>приостановка исполняющейся программы на некоторое время\r\nи т.д.</li>\r\nРассмотрим определение функции генератора, которая печатает текст во время выполнения.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndef generate_AB():\r\n    print('start')\r\n    yield 'A'\r\n    print('continue')\r\n    yield 'B'\r\n    print('end')\r\n\r\nfor char in generate_AB():\r\n    print('-->', char)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nstart\r\n--> A\r\ncontinue\r\n--> B\r\nend\r\n</strong>\r\n</pre>\r\nКак мы уже знаем, для итерирования цикл for сначала получает итератор, то есть выполняет следующий код:\r\n<pre>\r\n<strong>\r\niterator = iter(generate_AB())\r\n</strong>\r\n</pre>\r\nа затем на каждой итерации вызывает функцию next(iterator).  В теле цикла на каждой итерации печатается строка --> и значение, полученное при вызове next(iterator).<br><br>\r\n\r\nВо время первой итерации и первом вызове next(iterator) генератор, перед тем как сгенерировать значение 'A' (то есть дойти до строки yield 'A'), сначала выполняет строку print('start').<br><br>\r\n\r\nВо время второй итерации и втором вызове next(iterator) генератор, перед тем как сгенерировать значение 'B' (то есть дойти до строки yield 'B'), сначала выполняет строку print('continue').<br><br>\r\n\r\nВо время третьей итерации и третьем вызове next(iterator) генератор выполняет строку print('end') и завершает свою работу, возбуждая исключение StopIteration. Цикл for перехватывает это исключение и нормально завершается.<br><br>\r\n\r\n<strong>Ключевое слово return в теле функции генератора</strong><br><br>\r\nДо версии Python 3.3 наличие ключевого слова return внутри функции генератора приводило к возникновению ошибки:\r\n<pre>\r\n<strong>\r\nSyntaxError: 'return' with argument inside generator\r\n</strong>\r\n</pre>\r\nТеперь это допускается, при этом инструкция return приводит к возбуждению исключения StopIteration.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndef generate_ints():\r\n    yield 1\r\n    yield 2\r\n    return 3\r\n    yield 4\r\n\r\nfor num in generate_ints():\r\n    print(num)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n1\r\n2\r\n</strong>\r\n</pre>\r\nСтрока кода return 3 в функции генераторе generate_ints() возбуждает исключение StopIteration, которое перехватывает цикл for, после чего он завершается. Обратите внимание на то, что само значение 3 не выводится.<br><br>\r\n\r\n<strong>Особенности и ограничения функций генераторов</strong><br><br>\r\nОсновные особенности, присущие всем функциям генераторам:<br><br>\r\n\r\n<li>любая функция, содержащая ключевое слово yield, является функцией генератором</li>\r\n<li>когда вызывается функция генератор, то она не возвращает единственное значение, как это делает обыкновенная функция</li>\r\n<li>функция генератор всегда возвращает объект типа generator, который поддерживает протокол итератора</li>\r\n<li>Разница между yield и оператором return заключается в том, что для ключевого слова yield состояние выполнения генератора приостанавливается и локальные переменные сохраняются. При следующем вызове метода генератора __next__() функция возобновляет свое выполнение из той точки, из которой завершила в прошлый раз.</li><br><br>\r\n\r\nГенератор является итератором, поэтому он обладает всеми его особенностями:<br><br>\r\n\r\n<li>нельзя получить длину генератора функцией len()</li>\r\n<li>нельзя распечатать элементы генератора функцией print() без предварительной распаковки</li>\r\n<li>у генератора нельзя получить элемент по индексу</li>\r\n<li>после итерации по генератору он становится пустым</li><br><br>\r\n\r\nЛюбой итератор является итерируемым объектом, в то время как любой генератор является итератором, а значит и итерируемым объектом.<br><br>\r\n\r\nИтерируемый объект и итератор – это протоколы, то есть правила реализации. Генератор – это не протокол, а конкретная реализация. Это специальный механизм в языке Python, который позволяет создать однократно перебираемую функцию, логика перебора которой легко и красиво описывается.<br><br>\r\n\r\nЕдинственное синтаксическое различие между обычной функцией и функцией генератором – тот факт, что в теле последней встречается ключевое слово yield. Многие разработчики из команды Python считали, что для функций генераторов следовало бы ввести новое ключевое слово gen вместо def, но Гвидо не согласился.",
    "time_create": "2024-09-10T00:35:32.614Z",
    "time_update": "2024-09-24T02:01:07.481Z",
    "is_published": true,
    "slug": "generators",
    "direct": 1,
    "sub_lesson": [
      51,
      52,
      53
    ]
  }
},
{
  "model": "developer.developer",
  "pk": 14,
  "fields": {
    "lesson": "Регулярные выражения",
    "content": "<strong>Регулярные выражения</strong><br><br>\r\nРегулярные выражения (regular expression, regex, регулярка) – это мощный способ обработки текста, позволяющий находить в строках подстроки по сложным условиям.<br><br>\r\n\r\nЧуть более формально, <strong>регулярное выражение</strong> — это строка, задающая шаблон поиска подстрок в тексте. Одному шаблону может соответствовать много разных строк. Регулярное выражение состоит из обычных символов и специальных командных последовательностей. Например, \\d задаёт любую цифру, а \\d+ — задает любую последовательность из одной или более цифр.<br><br>\r\n\r\nРабота с регулярными выражениями реализована во всех современных языках программирования. Однако существует несколько диалектов, поэтому функционал регулярных выражений может различаться от языка к языку.<br><br>\r\n\r\nВ некоторых языках программирования пользоваться регулярными выражениями очень удобно (например, Python), в некоторых — не слишком (например, C++).<br><br>\r\n\r\nРегулярные выражения обычно применяют для:<br><br>\r\n\r\n<li>поиска подстрок в строке</li>\r\n<li>разделения строки на подстроки</li>\r\n<li>замены части строки</li><br><br>\r\n\r\nРегулярные выражения позволяют очень компактно описывать текстовые шаблоны.<br><br>\r\n\r\nНапример, указанный выше шаблон телефонного номера ddd-ddd-dddd (три цифры дефис три цифры дефис четыре цифры) можно описать регулярным выражением:\r\n<pre>\r\n<strong>\r\n\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d\r\n</strong>\r\n</pre>\r\nили еще более компактной версией:\r\n<pre>\r\n<strong>\r\n\\d{3}-\\d{3}-\\d{4}\r\n</strong>\r\n</pre>",
    "time_create": "2024-09-10T00:36:38.649Z",
    "time_update": "2024-09-24T02:10:11.890Z",
    "is_published": true,
    "slug": "regular-expressions",
    "direct": 1,
    "sub_lesson": [
      54,
      55,
      56,
      57,
      58,
      59,
      60
    ]
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 1,
  "fields": {
    "lesson": "Логические операции",
    "content": "<strong>Логические операторы</strong><br><br>\r\nКак быть в ситуации, когда у нас есть несколько условий? В Python есть три логических оператора, которые позволяют создавать сложные условия:<br><br>\r\n\r\n<strong>and </strong>— логическое умножение;<br>\r\n<strong>or</strong> — логическое сложение;<br>\r\n<strong>not</strong> — логическое отрицание.<br><br>\r\n<strong>Оператор and</strong><br><br>\r\nПредположим, мы написали программу для учеников от двенадцати лет, которые учатся по крайней мере в 7 классе. Доступ к ней тем, кто младше, надо запретить. Следующий код решает поставленную задачу:\r\n<pre>\r\n<strong>\r\nage = int(input('Сколько вам лет?: '))\r\ngrade = int(input('В каком классе вы учитесь?: '))\r\nif age >= 12 and grade >= 7:\r\n    print('Доступ разрешен.')\r\nelse:\r\n    print('Доступ запрещен.')\r\n</strong>\r\n</pre>\r\nМы объединили два условия при помощи оператора and. Он означает, что в этом ветвлении блок кода выполняется только при выполнении обоих условий одновременно!\r\n\r\nОператор and может объединять произвольное количество условий:\r\n<pre>\r\n<strong>\r\nage = int(input('Сколько вам лет?: '))\r\ngrade = int(input('В каком классе вы учитесь?: '))\r\ncity = input('В каком городе вы живете?: ')\r\nif age >= 12 and grade >= 7 and city == 'Москва':\r\n    print('Доступ разрешен.')\r\nelse:\r\n    print('Доступ запрещен.')\r\n</strong>\r\n</pre>\r\n\r\n<strong>Оператор or</strong><br><br>\r\n\r\nОператор or также применяется для объединения условий. Однако, в отличие от and, для выполнения блока кода достаточно выполнения хотя бы одного из условий.\r\n<pre>\r\n<strong>\r\ncity = input('В каком городе вы живете?: ')\r\nif city == 'Москва' or city == 'Санкт-Петербург' or city == 'Екатеринбург':\r\n    print('Доступ разрешен.')\r\nelse:\r\n    print('Доступ запрещен.')\r\n</strong>\r\n</pre>\r\n\r\nДля того, чтобы выражение or было истинным, требуется, чтобы хотя бы одно условие оператора or было истинным. При этом не имеет значения, истинным или ложным является второе выражение.<br><br>\r\n\r\nЛогическое выражение X <strong>and</strong> Y истинно, если оба значения X и Y истинны.<br>\r\n\r\nЛогическое выражение X <strong>or</strong> Y истинно, если хотя бы одно из значений X и Y истинно.<br>\r\n\r\nМы можем использовать оба логических операторов одновременно:\r\n<pre>\r\n<strong>\r\nage = int(input('Сколько вам лет?: '))\r\ngrade = int(input('В каком классе вы учитесь?: '))\r\ncity = input('В каком городе вы живете?: ')\r\nif age >= 12 and grade >= 7 and (city == 'Москва' or city == 'Санкт-Петербург'):\r\n    print('Доступ разрешен.')\r\nelse:\r\n    print('Доступ запрещен.')\r\n</strong>\r\n</pre>\r\nТакой код проверяет, что возраст учеников от двенадцати лет и учатся они по крайней мере в 7 классе и живут в Москве или Санкт-Петербурге.<br><br>\r\n\r\n<strong>Оператор not</strong><br><br>\r\nОператор not позволяет инвертировать (т.е. заменить на противоположный) результат логического выражения. Например, следующий код:\r\n<pre>\r\n<strong>\r\nage = int(input('Сколько вам лет?: '))\r\nif not (age < 12):\r\n    print('Доступ разрешен.')\r\nelse:\r\n    print('Доступ запрещен.')\r\n</strong>\r\n</pre>\r\nполностью эквивалентен коду:\r\n<pre>\r\n<strong>\r\nage = int(input('Сколько вам лет?: '))\r\nif age >= 12:\r\n    print('Доступ разрешен.')\r\nelse:\r\n    print('Доступ запрещен.')\r\n</strong>\r\n</pre>\r\nВ первом примере мы поместили выражение age < 12 в скобки для того, чтобы было чётко видно, что мы применяем оператор not к значению выражения age < 12, а не только к переменной age.<br><br>\r\n\r\n<strong>Приоритеты логических операторов</strong><br><br>\r\nЛогические операторы, подобно арифметическим операторам (+, -, *, /), имеют приоритет выполнения. Приоритет выполнения следующий:<br><br>\r\n\r\nв первую очередь выполняется логическое отрицание not;<br>\r\nдалее выполняется логическое умножение and;<br>\r\nдалее выполняется логическое сложение or.<br>\r\nДля явного указания порядка выполнения условных операторов используют скобки.<br><br>\r\n\r\n<strong>Оба оператора</strong>, and и or, вычисляются по укороченной схеме.\r\nВот как это работает с оператором and. Если условие слева от оператора and является ложным, то условие справа от него не проверяется, так как результат выражения будет гарантированно ложным и проверка оставшегося условия — пустая трата процессорного времени.<br><br>\r\n\r\nНапример, в таком выражении:\r\n<pre>\r\n<strong>\r\n5 > 100 and 10 > 0\r\n</pre>\r\n</strong>\r\nвычисляется только выражение 5 > 100. Оно ложно (потому что 5 не может быть больше 100). При операторе and оба выражения должны быть правдивы, чтобы результат был True. Но у нас уже одно не правдиво, значит, результат и так будет False. Поэтому нам и не надо вычислять второе выражение, оно всё равно не повлияет на результат.<br><br>\r\n\r\nАналогично работает оператор or. Если условие слева от оператора or истинное, то условие справа от него не проверяется. Действительно, результат будет гарантированно истинным и проверка оставшегося условия станет пустой тратой процессорного времени.<br><br>\r\n\r\nНапример, в таком выражении:\r\n<pre>\r\n<strong>\r\n10 > 0 or 5 > 100\r\n</strong>\r\n</pre>\r\nвычисляется только выражение 10 > 0. Оно правдиво, значит результат тоже правдив, т.к. нам достаточно одного правдивого выражения при операторе or.",
    "slug": "logic-operation"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 2,
  "fields": {
    "lesson": "Каскадные условия",
    "content": "<strong>Вложенный оператор</strong><br><br>\r\nВнутри условного оператора можно использовать любые инструкции языка Python, в том числе и условный оператор. Получаем вложенное ветвление: после одной развилки в ходе исполнения программы появляется другая развилка. При этом вложенные блоки имеют больший размер отступа (+4 пробела для каждого следующего уровня).\r\n<pre>\r\n<strong>\r\nif условие1:\r\n    блок кода\r\nelse:\r\n    if условие2:\r\n        блок кода\r\n    else:\r\n        if условие3:\r\n            блок кода            \r\n        ...\r\n\r\nx = int(input())\r\ny = int(input())\r\n\r\nif x > 0:\r\n    if y > 0:\r\n        print('Первая четверть')\r\n    else:\r\n        print('Четвертая четверть')\r\nelse:\r\n    if y > 0:\r\n        print('Вторая четверть')\r\n    else:\r\n        print('Третья четверть')\r\n</strong>\r\n</pre>\r\nВ данном случае уровень вложенности равен двум, так что программа одинаково хорошо читается как с помощью использования логического оператора and, так и с помощью вложенного оператора.<br><br>\r\n\r\nРассмотрим программу, которая переводит стобалльную оценку в пятибалльную. Для ее реализации нужно воспользоваться вложенным условным оператором:\r\n<pre>\r\n</strong>\r\ngrade = int(input('Введите вашу отметку по 100-балльной системе: '))\r\n\r\nif grade >= 90:\r\n    print(5)\r\nelse:\r\n    if grade >= 80:\r\n        print(4)\r\n    else:\r\n        if grade >= 70: \r\n            print(3)\r\n        else:\r\n            if grade >= 60:\r\n                print(2)\r\n            else:\r\n                print(1)\r\n</strong>\r\n</pre>\r\nВ этом примере уровень вложенности настолько глубок, что код становится трудно понять.\r\n\r\nВыбор из нескольких альтернатив – это обычное дело, здесь имеет смысл избегать глубокого вложения. Для этого в Python есть <strong>каскадный условный оператор</strong>.\r\n\r\nМы не могли написать 5 независимых if-ов, поскольку в таком случае было бы напечатано сразу несколько значений пятибалльной оценки.\r\n\r\n<strong>Каскадный условный оператор</strong><br><br>\r\nЕсли требуется проверить несколько условий, в языке Python используется каскадный условный оператор.\r\n\r\nСинтаксис каскадного условного оператора имеет следующий вид:\r\n<pre>\r\n<strong>\r\nif условие1:\r\n    блок кода\r\nelif условие2:\r\n    блок кода\r\n...\r\nelse:\r\n    блок кода\r\n</strong>\r\n</pre>\r\n\r\nПри исполнении такого условного оператора сначала проверяется условие1. Если оно является истинным, то исполняется блок кода, который следует сразу после него, вплоть до выражения elif. Остальная часть конструкции игнорируется. Однако если условие1 является ложным, то программа перескакивает непосредственно к следующему выражению elif и проверяет условие2. Если оно истинное, то исполняется блок кода, который следует сразу после него, вплоть до следующего выражения elif. И остальная часть условного оператора тогда игнорируется. Этот процесс продолжается до тех пор, пока не будет найдено условие, которое является истинным, либо пока больше не останется выражений elif. Если ни одно условие не является истинным, то исполняется блок кода после выражения else.<br><br>\r\n\r\nПриведенный ниже фрагмент кода является примером каскадного условного оператораif-elif-else. Этот фрагмент кода работает так же, как предыдущий код, использующий вложенный условный оператор. \r\n<pre>\r\n<strong>\r\ngrade = int(input('Введите вашу отметку: '))\r\n\r\nif grade >= 90:\r\n    print(5)\r\nelif grade >= 80:\r\n    print(4)\r\nelif grade >= 70:\r\n    print(3)\r\nelif grade >= 60:\r\n    print(2)\r\nelse:\r\n    print(1)\r\n</strong>\r\n</pre>\r\nОбратите внимание на выравнивание и выделение отступом, которые применены в инструкции if-elif-else: выражения if, elif и else выравнены и исполняемые по условию блоки выделены отступом.<br><br>\r\n\r\n<strong>Инструкция if-elif-else не является обязательной</strong>, потому что ее логика может быть запрограммирована вложенными инструкциями if-else. Однако длинная серия вложенных инструкций if-else имеет два характерных недостатка:<br><br>\r\n\r\nпрограммный код может стать сложным и трудным для восприятия; <br>\r\nиз-за необходимого выделения отступом продолжительная серия вложенных инструкций if-else может стать слишком длинной, чтобы целиком уместиться на экране монитора без горизонтальной прокрутки.<br><br>\r\nЛогика инструкции if-elif-else обычно прослеживается легче, чем длинная серия вложенных инструкций if-else. И поскольку в инструкции if-elif-else все выражения выровнены, длина строк в данной инструкции, как правило, короче. <br><br>\r\n\r\n<strong>Заключительный блок else в операторе if-elif-else является необязательным</strong>:\r\n<pre>\r\n<strong>\r\ntraffic_light_signal = input('Введите сигнал светофора: ')\r\n\r\nif traffic_light_signal == 'красный':\r\n    print('Стой!')\r\nelif traffic_light_signal == 'желтый':\r\n    print('Приготовься...')\r\nelif traffic_light_signal == 'зеленый':\r\n    print('Иди!')\r\n</strong>\r\n</pre>\r\nВ данном случае если будет введен некорректный сигнал светофора, программа ничего не выведет. Каждое условие будет проверено поочередно, и программа завершится без ошибок.",
    "slug": "cascade-conditions"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 3,
  "fields": {
    "lesson": "Вложенные циклы",
    "content": "<strong>Вложенные циклы</strong><br><br>\r\nВложенный цикл расположен в еще одном цикле. Часы служат хорошим примером работы вложенного цикла. Секундная, минутная и часовая стрелки вращаются вокруг циферблата.Часовая стрелка смещается всего на 1 шаг для каждых 60 шагов минутной стрелки. И секундная стрелка должна сделать 60 шагов для 1 шага минутной стрелки. Это означает, что для каждого полного оборота часовой стрелки (12 шагов), минутная стрелка делает 720 шагов.<br><br>\r\n\r\nРассмотрим цикл, который частично моделирует электронные часы. Он показывает секунды от 0 до 59:\r\n<pre>\r\n<strong>\r\nfor seconds in range(60):\r\n    print(seconds)\r\n</strong>\r\n</pre>\r\nМожно добавить переменную minutes и вложить цикл написанный выше внутрь еще одного цикла, который повторяется 60 раз:\r\n<pre>\r\n<strong>\r\nfor minutes in range(60):\r\n    for seconds in range(60):\r\n        print(minutes, ':', seconds)\r\n</strong>\r\n</pre>\r\nДля того, чтобы сделать модель законченной, можно добавить еще одну переменную для подсчета часов:\r\n<pre>\r\n<strong>\r\nfor hours in range(24):\r\n    for minutes in range(60):\r\n        for seconds in range(60):\r\n            print(hours, ':', minutes, ':', seconds)\r\n</strong>\r\n</pre>\r\nРезультатом работы такого кода будет:\r\n<pre>\r\n<strong>\r\n0 : 0 : 0\r\n0 : 0 : 1\r\n0 : 0 : 2\r\n...\r\n23 : 59 : 58\r\n23 : 59 : 59\r\n</strong>\r\n</pre> \r\nСамый внутренний цикл сделает 60 итераций для каждой итерации среднего цикла. Средний цикл сделает 60 итераций для каждой итерации самого внешнего цикла. Когда самый внешний цикл сделает 24 итерации, средний сделает 24 ⋅ 60 = 1440 итераций, и самый внутренний цикл сделает 24 ⋅ 60 ⋅ 60 = 86400 итераций!<br><br>\r\n\r\nПример имитационной модели часов подводит нас к нескольким моментам, имеющим отношение к вложенным циклам:<br><br>\r\n\r\n<li>вложенный цикл выполняет все свои итерации для каждой отдельной итерации внешнего цикла;</li>\r\n<li>вложенные циклы завершают свои итерации быстрее, чем внешние циклы;</li>\r\n<li>для того, чтобы получить общее количество итераций вложенного цикла, надо перемножить количество итераций всех циклов.</li><br><br>\r\n\r\n<strong>Мы можем вкладывать друг в друга циклы как for, так и while.</strong><br><br>\r\n\r\n<strong>Операторы break и continue во вложенных циклах</strong><br><br>\r\nОператор break выполняет прерывание ближайшего цикла в котором он расположен. Аналогично, оператор continue осуществляет переход на следующую итерацию ближайшего цикла.<br><br>\r\n\r\nРассмотрим программный код:\r\n<pre>\r\n<strong>\r\nfor i in range(3):\r\n    for j in range(3):\r\n        print(i, j)\r\n</strong>\r\n</pre>\r\nРезультатом его выполнения будут 9 строк:\r\n<pre>\r\n<strong>\r\n0 0\r\n0 1\r\n0 2\r\n1 0\r\n1 1\r\n1 2\r\n2 0\r\n2 1\r\n2 2\r\n</strong>\r\n</pre>\r\nИзменим код, добавив во вложенный цикл условный оператор с оператором break:\r\n<pre>\r\n<strong>\r\nfor i in range(3):\r\n    for j in range(3):\r\n        if i == j:\r\n            break\r\n        print(i, j)\r\n</strong>\r\n</pre>\r\nРезультатом выполнения нового кода будут 3 строки:\r\n<pre>\r\n<strong>\r\n1 0\r\n2 0\r\n2 1\r\n</strong>\r\n</pre>\r\nИзменим оператор прерывания break на оператор continue:\r\n<pre>\r\n<strong>\r\nfor i in range(3):\r\n    for j in range(3):\r\n        if i == j:\r\n            continue\r\n        print(i, j)\r\n</strong>\r\n</pre>\r\nРезультатом выполнения нового кода будут 6 строк:\r\n<pre>\r\n<strong>\r\n0 1\r\n0 2\r\n1 0\r\n1 2\r\n2 0\r\n2 1\r\n</strong>\r\n</pre>\r\nЕсли необходимо добиться прерывания внешнего цикла из-за выполнения условия во внутреннем, то стоит сделать это через сигнальную метку.<br><br>\r\n\r\n<strong>Примеры решения задач</strong><br><br>\r\nОдин интересный способ узнать о работе вложенных циклов состоит в их использовании для вывода на экран комбинаций символов. Давайте взглянем на один простой пример. Предположим, что мы хотим напечатать на экране звездочки в виде прямоугольной таблицы:\r\n<pre>\r\n<strong>\r\n******\r\n******\r\n******\r\n******\r\n******\r\n******\r\n******\r\n******\r\n</strong>\r\n</pre>\r\nТаблица состоящая из звездочек состоит из 8 строк и 6 столбцов. Приведенный ниже фрагмент кода можно использовать для вывода одной строки звездочек:\r\n<pre>\r\n<strong>\r\nfor i in range(6):\r\n    print ( '*', end='')\r\n</strong>\r\n</pre>\r\nДля того чтобы завершить весь вывод таблицы звездочек, нам нужно выполнить этот цикл восемь раз. Мы можем поместить этот цикл в еще один цикл, который делает восемь итераций, как показано ниже:\r\n<pre>\r\n<strong>\r\nfor i in range(8):\r\n    for j in range(6):\r\n        print('*', end='')\r\n    print()\r\n</strong>\r\n</pre>\r\nВнешний цикл делает восемь итераций. Во время каждой итерации этого цикла внутренний цикл делает 6 итераций. (Обратите внимание, что в строке 4 после того, как все строки были напечатаны, мы вызываем функцию print(). Мы должны это сделать, чтобы в конце каждой строки продвинуть экранный курсор на следующую строку. Без этой инструкции все звездочки будут напечатаны на экране в виде одной длинной строки.)<br><br>\r\n\r\nДавайте рассмотрим еще один пример. Предположим, что вы хотите напечатать звездочки в комбинации, которая похожа на приведенный ниже звездный треугольник:\r\n<pre>\r\n<strong>\r\n*\r\n**\r\n***\r\n****\r\n*****\r\n******\r\n*******\r\n********\r\n</strong>\r\n</pre>\r\nПредставим эту комбинацию звездочек, как сочетание строк и столбцов. В этой комбинации всего восемь строк. В первой строке один столбец. Во второй строке – два столбца. В третьей строке – три. И так продолжается до восьмой строки, в которой восемь столбцов.\r\n<pre>\r\n<strong>\r\nfor i in range(8):\r\n    for j in range(i + 1):\r\n        print('*', end='')\r\n    print()\r\n</strong>\r\n</pre>",
    "slug": "cycle-in-cycle"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 4,
  "fields": {
    "lesson": "Цикл for: функция range",
    "content": "<strong>Функция range() с одним параметром</strong><br><br>\r\nРассмотрим программный код:\r\n<pre>\r\n<strong>\r\nfor i in range(10):\r\n    print('Привет', i)\r\n</strong>\r\n</pre>\r\nЗначение, которое мы указываем в скобках у функции range() обозначает количество итераций цикла, при этом переменная i принимает последовательно значения: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.\r\n\r\nЕсли быть более точным, то мы говорим, что функция range(n) генерирует последовательность чисел от 0 до n-1, а цикл for последовательно перебирает эту последовательность.\r\n\r\n<strong>Перегрузка range() с двумя параметрами</strong><br><br>\r\nЕсли мы хотим начинать последовательность не с 0, а с какого-то другого числа, то мы можем использовать перегрузку функции range() принимающую два параметра. Например, вызов функции range(1, 5) сгенерирует последовательность чисел 1, 2, 3, 4  (<strong>будьте внимательны, правая граница не включительна</strong>). Если нам нужны числа от 1 до 5 включительно, то мы используем range(1, 6).<br><br>\r\n\r\nТаким образом:\r\n\r\n<li>range(n): создает последовательность чисел 0, 1, 2, 3, ..., n - 1;</li>\r\n<li>range(n, m): создает последовательность чисел n, n + 1, n + 2, ..., m - 2, m - 1.</li><br><br>\r\nНапишем программу, которая выводит те числа из промежутка [100 ; 999], которые оканчиваются на 7.Используя функцию range() с двумя параметрами, получаем:\r\n<pre>\r\n<strong>\r\nfor i in range(100, 1000):  # перебираем числа от 100 до 999\r\n    if i % 10 == 7:         # используем остаток от деления на 10, для получения последней цифры\r\n        print(i)\r\n</strong>\r\n</pre>\r\nОбратите внимание, в качестве второго параметра мы передали число 1000.<br><br>\r\n\r\nЕсли первый параметр больше второго, то функция range() генерирует пустую последовательность. Например, вызов функции range(10, 1) приводит к генерации пустой последовательности.<br><br>\r\n\r\n<strong>Перегрузка range() с 3 параметрами</strong><br><br>\r\nПередавая два параметра в функцию range() мы можем генерировать любую последовательность целых чисел с шагом 1. Но, что делать если нужно поменять шаг? Как быть если мы хотим сгенерировать последовательность чисел 5, 10, 15, 20, 25? В этом случае существует еще одна перегрузка функции range(), принимающая три параметра: range(n, m, k). Первый параметр задает старт последовательности, второй параметр задает стоп последовательности и третий – шаг генерации чисел.\r\n\r\nНапример, вызов функции range(1, 10, 2) создаст последовательность чисел 1, 3, 5, 7, 9, а вызов функции range(5, 30, 5) сгенерирует последовательность 5, 10, 15, 20, 25.<br><br>\r\n\r\nНапишем программу, которая выводит все четные числа из промежутка [56 ; 170].<br><br>\r\n\r\nИспользуя функцию range() с тремя параметрами, получаем:\r\n<pre>\r\n<strong>\r\nfor i in range(56, 171, 2):\r\n    print(i)\r\n</strong>\r\n</pre>\r\nОбратите внимание, мы можем использовать функцию range() с двумя параметрами:\r\n<pre>\r\n<strong>\r\nfor i in range(56, 171):\r\n    if i % 2 == 0:\r\n        print(i)\r\n</strong>\r\n</pre>\r\nоднако такой код получается менее эффективным.\r\n\r\n<strong>Отрицательный шаг генерации</strong><br><br>\r\nЕсли шаг генерации является положительным числом, то генерируемая последовательность будет возрастать. Мы можем указать отрицательный шаг генерации (третий параметр), что приведет к генерированию убывающей последовательности.<br><br>\r\n\r\nВ случае отрицательного шага, мы должны гарантировать, что старт последовательности (первый параметр) больше чем конец последовательности (второй параметр).\r\n\r\nНапример, вызов функции range(20, 16, -1) создаст последовательность чисел 20, 19, 18, 17, а вызов функции range(20, 10, -3) сгенерирует последовательность 20, 17, 14, 11.<br><br>\r\n\r\nНапишем программу, которая отсчитывает от 5 до 1, а затем выводит текст Взлетаем!!!:\r\n<pre>\r\n<strong>\r\nfor i in range(5, 0, -1):\r\n    print(i, end=' ')\r\nprint('Взлетаем!!!')\r\n</strong>\r\n</pre>\r\nРезультатом будет:\r\n<pre>\r\n<strong>\r\n5 4 3 2 1 Взлетаем!!!\r\n</strong>\r\n</pre>\r\nЕсли величина шага отрицательна и первый параметр меньше второго, то функция range() генерирует пустую последовательность. Например, вызов функции range(1, 10, -1) приводит к генерации пустой последовательности.<br><br>\r\n\r\n<strong>Примеры использования функции range()</strong>\r\n<pre>\r\n<strong>\r\nВызов функции  \t Последовательность чисел   \r\nrange(10)  \t  0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\nrange(1, 10)\t  1, 2, 3, 4, 5, 6, 7, 8, 9\r\nrange(3, 7)\t  3, 4, 5, 6\r\nrange(7, 3)\t  пустая последовательность\r\nrange(2, 15, 3)\t  2, 5, 8, 11, 14\r\nrange(9, 2, -1)\t  9, 8, 7, 6, 5, 4, 3\r\nrange(3, 10, -2)  пустая последовательность\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция range()</strong> может принимать от одного до трех параметров: range(n), range(n, m), range(n, m, k)<br><br>\r\n\r\n<li>первый параметр – это старт последовательности (включительно);</li><br>\r\n<li>второй параметр – это стоп последовательности (не включительно);</li><br>\r\n<li>третий параметр – это величина шага.</li><br><br>\r\n<strong>Функция range()</strong> может генерировать только целые числа, включая отрицательные.<br><br>\r\n\r\n<strong>Величина шага</strong> не может равняться нулю. Следующий код:\r\n<pre>\r\n<strong>\r\nfor i in range(1, 10, 0):\r\n    print(i)\r\nприведет к ошибке ValueError: range() arg 3 must not be zero.\r\n</strong>\r\n</pre>",
    "slug": "function-range"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 5,
  "fields": {
    "lesson": "Частые сценарии",
    "content": "<strong>Подсчет количества</strong><br><br>\r\nНередко нужно, чтобы наши программы подсчитывали, сколько раз что-либо произошло. К примеру, видеоигра может подсчитывать количество поворотов персонажа, или математическая программа может считать, как много чисел обладают некоторым свойством. Ключ к подсчету – использование переменной счетчика.<br><br>\r\n\r\nНапишем программу, которая считывает 10 чисел и определяет, сколько из них больше 10.\r\n<pre>\r\n<strong>\r\ncounter = 0\r\nfor _ in range(10):\r\n    num = int(input())\r\n    if num > 10:\r\n        counter = counter + 1\r\n\r\nprint('Было введено', counter, 'чисел, больших 10.')\r\n</strong>\r\n</pre>\r\nКаждый раз, когда мы считываем число, большее 10, мы добавляем 1 к нашему текущему значению переменной counter. В программе это реализовано в строке counter = counter + 1. Обратите внимание на начальное значение переменной счетчика counter = 0. Без начального значения мы получили бы ошибку, поскольку, дойдя до строки counter = counter + 1, Python ничего не знал бы о переменной counter. Строка кода counter = counter + 1 означает: возьми старое значение переменной counter, прибавь к нему 1 и переприсвой переменной это значение. Если не придать переменной начальное значение, то непонятно, к чему прибавлять 1 в самый первый раз.<br><br>\r\n\r\n<strong>Подсчет количества</strong> – это очень частый сценарий. Он состоит из двух шагов:<br><br>\r\n\r\nСоздание переменной счетчика, и придание ей первоначального значения: counter = 0;\r\nУвеличение переменной счетчика на 1: counter = counter + 1.<br><br>\r\nЧасто при написании программ требуется использовать несколько счетчиков. Модифицируем предыдущую программу: посчитаем еще и количество нулей среди введенных чисел.\r\n<pre>\r\n<strong>\r\ncounter1 = 0\r\ncounter2 = 0\r\nfor _ in range(10):\r\n    num = int(input())\r\n    if num > 10:\r\n        counter1 = counter1 + 1\r\n    if num == 0:\r\n        counter2 = counter2 + 1\r\n\r\nprint('Было введено', counter1, 'чисел, больших 10.')\r\nprint('Было введено', counter2, 'нулей.' )\r\n</strong>\r\n</pre>\r\nРассмотрим еще один пример: подсчитать количество чисел из диапазона \r\n[1 ; 100], квадрат которых оканчивается на 4.\r\n<pre>\r\n<strong>\r\ncounter = 0\r\nfor i in range(1, 101):\r\n    if i**2 % 10 == 4:\r\n        counter = counter + 1\r\n\r\nprint(counter)\r\n</strong>\r\n</pre>\r\nМы используем функцию range() с двумя параметрами для генерации последовательности чисел от 1 до 100. Каждый раз, когда переменная i последовательно принимает значения от 1 до 100, мы проверяем условие: i**2 % 10 == 4 (оканчивается ли квадрат числа i на 4).<br><br>\r\n\r\n<strong>Для переменной счетчика удобно использовать имя counter (или более сокращенно cnt). </strong><br><br>\r\n\r\n<strong>Вычисление суммы и произведения</strong><br><br>\r\nНаравне с подсчетом количества по частоте стоит задача вычисления суммы. К примеру, видеоигра должна считать сумму очков. В таком случае начальное значение переменной будет равно 0, а далее оно будет увеличиваться на некоторое количество заработанных очков, скажем на 10. Мы пишем следующий код:\r\n<pre>\r\n<strong>\r\nscore = 0\r\n...\r\nscore = score + 10\r\n</strong>\r\n</pre>\r\nНапишем программу, которая считывает 10 чисел и определяет сумму тех из них, которые больше 10.\r\n<pre>\r\n<strong>\r\ntotal = 0\r\nfor _ in range(10):\r\n    num = int(input())\r\n    if num > 10:\r\n        total = total + num\r\n\r\nprint('Сумма чисел больших 10 равна',  total)\r\n</strong>\r\n</pre>\r\nКаждый раз, когда программа считывает число, большее 10, она добавляет его к текущему значению переменной total. Это реализовано в строке total = total + num. Обратите внимание на начальное значение переменной-сумматора total = 0. Без начального значения мы получили бы ошибку, поскольку, дойдя до строки total = total + num, Python ничего не знал бы о переменной total . Строка кода total = total + num означает: возьми старое значение переменной total, прибавь к нему num и переприсвой переменной это значение. Если не придать переменной начальное значение, то не к чему прибавлять num в самый первый раз.<br><br>\r\n\r\nПодсчет суммы состоит из двух шагов:<br><br>\r\n\r\n<li>Создание переменной сумматора и придание ей первоначального значения: total = 0;</li>\r\n<li>Увеличение переменной сумматора на нужное число: total = total + num.</li><br><br>\r\n\r\nНапишем программу, которая считает сумму натуральных чисел от 1 до 100:\r\n<pre>\r\n<strong>\r\ntotal = 0\r\nfor i in range(1, 101):\r\n    total = total + i\r\n\r\nprint('Сумма равна', total)\r\n</strong>\r\n</pre>\r\nРассмотрим еще один пример: напишем программу, которая запрашивает 10 целых чисел и находит их среднее значение:\r\n<pre>\r\n<strong>\r\ntotal = 0\r\nfor _ in range(10):\r\n    num = int(input())\r\n    total = total + num\r\n\r\naverage = total / 10\r\nprint('Среднее значение равно', average)\r\n</strong>\r\n</pre>\r\nАналогичным образом вычисляется произведение. При вычислении произведения начальное значение переменной мультипликатора мы устанавливаем равным 1, в отличие от сумматора, где оно равно 0.<br><br>\r\n\r\n<strong>Для переменной сумматора и мультипликатора удобно использовать имя total.</strong><br><br> \r\n\r\n<strong>Обмен значений переменных</strong><br><br>\r\nОчень часто нам требуется обменять значения двух переменных x и y. Начинающие программисты иногда пишут такой код:\r\n<pre>\r\n<strong>\r\nx = y\r\ny = x\r\n</strong>\r\n</pre>\r\nОднако он не работает. Предположим, что x = 3 и y = 5. Первая строка присвоит переменной x значение 5, что правильно, однако вторая строка установит значение переменной y в 5, поскольку значение x уже равно 5. Для решения задачи мы можем использовать временную переменную:\r\n<pre>\r\n<strong>\r\ntemp = x\r\nx = y\r\ny = temp\r\n</strong>\r\n</pre>\r\nТакой код пишут почти во всех языках программирования. Однако в Python есть и более простой способ. Мы можем написать так:\r\n<pre>\r\n<strong>\r\nx, y = y, x\r\n</strong>\r\n</pre>\r\nВ результате выполнения такого кода Python поменяет значения переменных x и y местами.<br><br>\r\n\r\n<strong>Сигнальные метки</strong><br><br>\r\nСигнальная метка (флажок) может использоваться, когда надо, чтобы одна часть программы узнала о происходящем в другой части программы.<br><br>\r\nНапишем программу, определяющую, что натуральное число является простым:\r\n<pre>\r\n<strong>\r\nnum = int(input())\r\nflag = True\r\n\r\nfor i in range(2, num):\r\n    if num % i == 0:  #  если исходное число делится на какое-либо отличное от 1 и самого себя\r\n        flag = False\r\n\r\nif num == 1:\r\n    print('Это единица, она не простая и не составная') \r\nelif flag == True:\r\n    print('Число простое')\r\nelse:\r\n    print('Число составное')\r\n</strong>\r\n</pre>\r\nНапомним, что <strong>число является простым, если оно не имеет делителей, кроме 1 и самого себя</strong>. Вышеприведенная программа работает следующим образом: начальное значение переменной флага равно True, что говорит о том, что число является простым. Затем мы перебираем все числа от 2 до num - 1 (включительно). Если одно из этих значений оказывается делителем числа num, тогда число num является составным и мы устанавливаем значение флага False. Как только цикл завершен, мы проверяем, установлен флаг в True или нет. Если это так, мы знаем, что делитель найден не был и число является простым. В противном случае число является составным.<br><br>\r\n\r\n<strong>Флаговые переменные могут иметь более осмысленное название. Например, в случае с проверкой числа на простоту, название флаговой переменной могло бы быть is_prime.</strong><br><br>\r\n\r\n<strong>Максимум и минимум</strong><br><br>\r\nПоиск наибольшего или наименьшего значения в некоторой последовательности чисел – также частая задача в программировании. Напишем программу, которая считывает 10 положительных чисел и находит среди них наибольшее число.\r\n<pre>\r\n<strong>\r\nlargest = 0\r\nfor _ in range(10):\r\n    num = int(input())    \r\n    if num > largest:\r\n        largest = num\r\n\r\nprint('Наибольшее число равно', largest) \r\n</strong>\r\n</pre>\r\nМы устанавливаем начальное значение переменной largest  в 0. Далее программа считывает \r\n10 чисел, и если какое-то из них оказывается больше текущего значения largest, переприсваивает его. В качестве начального значения взято число 0, поскольку мы знаем, что все числа положительны (а 0 является максимальным неположительным числом). Таким образом, уже первое сравнение приведет к переприсваиванию.<br><br>\r\n\r\nРаспространен подход, когда в качестве начального значения переменной сразу принимается первый элемент последовательности. Напишем программу, которая считывает 10 чисел (необязательно положительных) и находит среди них наибольшее:\r\n<pre>\r\n<strong>\r\nlargest = int(input())  # принимаем первое число за максимальное\r\nfor _ in range(9):\r\n    num = int(input())\r\n    if num > largest:\r\n        largest = num\r\n\r\nprint('Наибольшее число равно', largest) \r\n</strong>\r\n</pre>\r\nДля нахождения наименьшего значения последовательности следует поменять знак неравенства (>) на противоположный (<). В таком случае название переменной largest стоит заменить на smallest. Для переменных, хранящих наибольшее и наименьшее значения, подходят имена largest и smallest соответственно.<br><br>\r\n\r\n<strong>Очень часто сигнальные метки называют flag.</strong><br><br>\r\n\r\n<strong>Поскольку в Python есть встроенные функции max() и min(), то давать такие названия для максимального и минимального значения не очень хорошо. Куда лучше использовать названия largest и smallest или mx и mn.</strong>",
    "slug": "common-scenarios"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 6,
  "fields": {
    "lesson": "Цикл while: обработка цифр числа",
    "content": "<strong>Обработка цифр числа</strong><br><br>\r\nИспользуя цикл while и операцию целочисленного деления // с операцией нахождения остатка от деления одного целого числа на другое %, можно обработать цифры числа с произвольным количеством разрядов (цифр).<br><br>\r\n\r\nПусть дано натуральное число n. Тогда:\r\n<pre>\r\n<strong>\r\nрезультатом операции n % 10 – является последняя цифра числа;\r\nрезультатом операции n // 10 – является число с удаленной последней цифрой.\r\n</strong>\r\n</pre>\r\nНапишем программу, которая считывает натуральное число (целое положительное) и обрабатывает его цифры.\r\n<pre>\r\n<strong>\r\nn = int(input())\r\nwhile n != 0:  # пока в числе есть цифры\r\n    last_digit = n % 10  # получить последнюю цифру\r\n    # код обработки последней цифры\r\n    n = n // 10  # удалить последнюю цифру из числа\r\n</strong>\r\n</pre>\r\nЦикл while работает до тех пор пока в числе есть необработанные цифры. Тело цикла содержит:<br><br>\r\n\r\n<li>процедуру получения последней цифры last_digit = n % 10;</li>\r\n<li>код обработки последней цифры;</li>\r\n<li>процедуру удаления последней цифры из числа n = n // 10.</li><br><br>\r\nВ качестве процедуры обработки может быть все, что угодно: вывод цифр, нахождение суммы, произведения цифр, нахождение наибольшей или наименьшей цифры, подсчет цифр удовлетворяющих некоторому условию и т.д.<br><br>\r\n\r\nНапишем программу, которая определяет есть ли в числе цифра 7.\r\n<pre>\r\n<strong>\r\nnum = int(input())\r\nhas_seven = False  # сигнальная метка\r\n\r\nwhile num != 0:\r\n    last_digit = num % 10\r\n    if last_digit == 7:\r\n        has_seven = True\r\n    num = num // 10\r\n\r\nif has_seven == True:\r\n    print('YES')\r\nelse:\r\n    print('NO')\r\n</strong>\r\n</pre>",
    "slug": "number-crunching"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 7,
  "fields": {
    "lesson": "Break, continue и else",
    "content": "<strong>Оператор прерывания цикла break</strong><br><br>\r\nИногда бывает нужно прервать выполнение цикла преждевременно. Оператор break прерывает ближайший цикл for или while.<br><br>\r\n\r\nУсовершенствуем с помощью оператора break программу, проверяющую число на простоту:\r\n<pre>\r\n<strong>\r\nnum = int(input())\r\nflag = True\r\n\r\nfor i in range(2, num):\r\n    if num % i == 0:        #  если исходное число делится на какое-либо отличное от 1 и самого себя\r\n        flag = False\r\n        break               # останавливаем цикл если встретили делитель числа        \r\n\r\nif flag:  # эквивалентно if flag == True:\r\n    print('Число простое')\r\nelse:\r\n    print('Число составное')\r\n</strong>\r\n</pre>\r\nКак только мы встречаем делитель отличный от 1 и num, мы меняем значение сигнальной метки и прерываем цикл, поскольку дальнейшее его выполнение лишено смысла: число гарантированно не является простым.<br><br>\r\n\r\n<strong>Оператор прерывания цикла break позволяет ускорять программы, так как мы избавляемся от лишних итераций.</strong><br><br>\r\n\r\nНапишем программу, использующую цикл for, которая считывает 10 чисел и суммирует их до тех пор, пока не обнаружит отрицательное число. В этом случае выполнение цикла прерывается командой break:\r\n<pre>\r\n</strong>\r\nresult = 0\r\nfor i in range(10):\r\n    num = int(input())\r\n    if num < 0:\r\n        break\r\n    result += num\r\nprint(result)\r\n</strong>\r\n</pre>\r\nОператор прерывания цикла break удобен в связке с сигнальными метками: когда после проверки некоторого условия нам нет смысла продолжать выполнение цикла.<br><br>\r\n\r\nНапишем программу, которая определяет, содержит ли введенное пользователем число цифру 7.\r\n<pre>\r\n<strong>\r\nnum = int(input())\r\nnumber = num\r\nflag = False\r\nwhile num != 0:\r\n    last_digit = num % 10\r\n    if last_digit == 7:\r\n        flag = True\r\n        break        # прерываем цикл, так как число гарантированно содержит цифру 7\r\n    num //= 10\r\n\r\nif flag:  # эквивалентно if flag == True:\r\n    print('Число', number, 'содержит цифру 7')\r\nelse:\r\n    print('Число', number, 'не содержит цифру 7')\r\n</strong>\r\n</pre>\r\nКак только мы встретили цифру 7, мы меняем значение сигнальной метки и прерываем цикл с помощью оператора break. Мы можем и не прерывать цикл преждевременно, а дождаться его естественного завершения (условие num != 0, то есть все цифры числа обработаны), однако в таком случае мы будем совершать лишнюю работу, и в случае, если число очень большое, программа будет работать медленнее.<br><br>\r\n\r\n<strong>Бесконечные циклы</strong><br><br>\r\nСамый простой способ создать бесконечный цикл в Python – записать следующий код:\r\n<pre>\r\n<strong>\r\nwhile True:\r\n    print('Python is awesome!')\r\n</strong>\r\n</pre>\r\nРезультатом выполнения такого кода будет бесконечное количество строчек текста:\r\n<pre>\r\n<strong>\r\nPython is awesome!\r\nPython is awesome!\r\n.\r\n.\r\n.\r\nPython is awesome!\r\nPython is awesome!\r\nPython is awesome!\r\n</strong>\r\n</pre>\r\nБесконечный цикл продолжает повторяться до тех пор, пока программа не будет прервана. Изучив оператор break, мы получили механизм прерывания бесконечных циклов.<br><br>\r\n\r\nВозможно, вам может показаться, что бесконечные циклы лишены смысла, однако это не совсем так. Например, вы можете написать программу, которая запускается и работает, постоянно принимая запросы на обслуживание. Программный код такой программы может выглядеть так:\r\n<pre>\r\n<strong>\r\nwhile True:\r\n    query = get_new_query() #  получаем новый запрос на обработку\r\n    query.process()         #  обрабатываем запрос\r\n</strong>\r\n</pre>\r\nИногда с помощью бесконечного цикла удается сделать программный код более читабельным. Более простым может быть завершение цикла на основе условий внутри тела цикла, а не на основе условий в его заголовке:\r\n<pre>\r\n<strong>\r\nwhile True:\r\n    if условие 1:  # условие для остановки цикла\r\n        break\r\n    ...\r\n    if условие 2:  # еще одно условие для остановки цикла\r\n        break\r\n    ...\r\n    if условие 3:  # еще одно условие для остановки цикла\r\n        break\r\n</strong>\r\n</pre>\r\nВ подобных случаях, когда существует множество причин завершения цикла, часто их проще выделить из нескольких разных мест, чем пытаться указать все условия завершения в заголовке цикла.<br><br>\r\n\r\n<strong>Важно: бесконечные циклы могут быть очень полезными. Просто помните, что вы должны убедиться, что цикл в какой-то момент будет прерван, чтобы он действительно не становился бесконечным.</strong><br><br>\r\n\r\n<strong>Оператор continue</strong><br><br>\r\nДругая стандартная идиома циклов — пропуск отдельных элементов при переборе. Оператор continue позволяет перейти к следующей итерации цикла for или while до завершения всех команд в теле цикла.<br><br>\r\n\r\nНапишем программу, которая выводит все числа от 1 до 100, кроме чисел 7, 17, 29 и 78.\r\n<pre>\r\n<strong>\r\nfor i in range(1, 101):\r\n    if i == 7 or i == 17 or i == 29 or i == 78:\r\n        continue  # переходим на следующую итерацию\r\n    print(i)\r\n</strong>\r\n</pre>\r\nОператор break прерывает выполнение ближайшего цикла, а не программы, то есть далее будет выполнена команда, следующая сразу за циклом.",
    "slug": "break-continue-else"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 8,
  "fields": {
    "lesson": "Блок else в циклах",
    "content": "<strong>Блок else в циклах</strong><br><br>\r\nPython допускает необязательный блок else в конце циклов while и for. Это уникальная особенность Python, не встречающаяся в большинстве других языков программирования. Синтаксис такой конструкции следующий:\r\n<pre>\r\n<strong>\r\nwhile условие:\r\n    блок кода1\r\nelse:\r\n    блок кода2\r\n\r\n# или\r\n\r\nfor i in range(10):\r\n    блок кода1\r\nelse:\r\n    блок кода2\r\n</strong>\r\n</pre>\r\nБлок кода2, указанный в else, будет выполнен, когда штатным образом завершается цикл while или for.<br><br>\r\n\r\nСейчас вы можете подумать: «Как это может быть полезным?» Ведь мы можем сделать то же самое, поместив блок кода2 сразу после цикла while или for без else:\r\n<pre>\r\n<strong>\r\nwhile условие:\r\n    блок кода1\r\nблок кода2\r\n\r\n# или\r\n\r\nfor i in range(10):\r\n    блок кода1\r\nблок кода2\r\n</strong>\r\n</pre>\r\nВ чем разница?<br>\r\n\r\nЕсли слово else отсутствует в описании цикла, то блок кода2 будет выполняться после завершения цикла, несмотря ни на что. Если же слово else присутствует, то блок кода2 будет выполняться только в том случае, если цикл завершается штатным образом. Под штатным завершением цикла подразумевается его завершение без использования оператора прерывания break.<br><br>\r\n\r\nРассмотрим следующий программный код:\r\n<pre>\r\n<strong>\r\nn = 5\r\nwhile n > 0:\r\n    n -= 1\r\n    print(n)\r\nelse:\r\n    print('Цикл завершен.')\r\n</strong>\r\n</pre>\r\nДанный цикл повторяется до тех пор, пока истинно условие n > 0. Поскольку цикл завершился штатным образом, то блок кода в инструкции else будет выполнен. Таким образом, результатом выполнения такой программы будут строки:\r\n<pre>\r\n<strong>\r\n4\r\n3\r\n2\r\n1\r\n0\r\nЦикл завершен.\r\n</strong>\r\n</pre>\r\nРассмотрим следующий программный код:\r\n<pre>\r\n<strong>\r\nn = 5\r\nwhile n > 0:\r\n    n -= 1\r\n    print(n)\r\n    if n == 2:\r\n        break\r\nelse:\r\n    print('Цикл завершен.')\r\n</strong>\r\n</pre>\r\nЭтот цикл преждевременно завершается с помощью оператора прерывания break, поэтому блок кода в инструкции else не будет выполнен. Результатом выполнения такой программы будут строки:\r\n<pre>\r\n<strong>\r\n4\r\n3\r\n2\r\n</strong>\r\n</pre>\r\nВам может показаться, что инструкция else в циклах while и for не совсем соответствует тому, что реально происходит. Гвидо ван Россум, создатель Python, сказал, что если бы он проектировал язык Python заново, то избавился бы от else в циклах.<br><br>\r\n\r\nНапишем программу, которая определяет, содержит ли введенное пользователем число цифру 7. Вместо программного кода, написанного ранее:\r\n<pre>\r\n<strong>\r\nnum = int(input())\r\nn = num\r\nflag = False\r\nwhile n != 0:\r\n    last = n % 10\r\n    if last == 7:\r\n        flag = True\r\n        break        # прерываем цикл, так как число гарантированно содержит цифру 7\r\n    n //= 10\r\n\r\nif flag == True:\r\n    print('Число', num, 'содержит цифру 7')\r\nelse:\r\n    print('Число', num, 'не содержит цифру 7')\r\n</strong>\r\n</pre>\r\nмы можем использовать:\r\n<pre>\r\n<strong>\r\nnum = int(input())\r\nn = num\r\nwhile n != 0:\r\n    last = n % 10\r\n    if last == 7:\r\n        print('Число', num, 'содержит цифру 7')\r\n        break\r\n    n //= 10\r\nelse:\r\n    print('Число', num, 'не содержит цифру 7')\r\n</strong>\r\n</pre>\r\nОператор continue не влияет на выполнение блока else в циклах.<br><br>\r\n\r\nБлок else в циклах часто применяется для обработки отсутствия элементов.",
    "slug": "block-else"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 9,
  "fields": {
    "lesson": "Числовые типы данных",
    "content": "<strong>Целочисленный тип данных</strong><br><br>\r\nЦелые числа в Python представлены типом данных int (сокращение int происходит от слова integer). Для определения целого числа типа int используется последовательность цифр от 0 до 9.<br><br>\r\n\r\nЯвно указанное численное значение в коде программы называется целочисленным литералом. Когда Python встречает целочисленный литерал, он создает объект типа int, хранящий указанное значение.\r\n<pre>\r\n<strong>\r\nn = 17  # целочисленный литерал\r\nm = 7   # целочисленный литерал\r\n</strong>\r\n</pre>\r\nЦелочисленный тип данных int используют не только потому, что он встречается в реальном мире, но и потому, что он естественным образом возникает при создании большинства программ.<br><br>\r\n\r\n\r\n<strong>Преобразование строки в целое число</strong><br><br>\r\nДля преобразования строки в целое число, мы используем команду int():\r\n<pre>\r\n<strong>\r\nnum = int(input())  # преобразование считанной строки в целое число\r\n</strong>\r\n</pre>\r\n\r\nСледующий код преобразует строку 12345 в целое число:\r\n<pre>\r\n<strong>\r\nn = int('12345')  # преобразование строки в целое число\r\n</strong>\r\n</pre>\r\nЕсли строка не является числом, то при преобразовании возникнет ошибка.\r\n\r\n<strong>Целочисленные операторы</strong><br><br>\r\nЯзык Python предоставляет четыре основных арифметических оператора для работы с целыми числами (+, −, *, /), а также три дополнительных (% для остатка, // для целочисленного деления и ** для возведения в степень).<br><br>\r\n\r\nСледующая программа демонстрирует все целочисленные операторы:\r\n<pre>\r\n<strong>\r\na = 13\r\nb = 7\r\n\r\ntotal = a + b\r\ndiff = a - b\r\nprod = a * b\r\ndiv1 = a / b\r\ndiv2 = a // b\r\nmod = a % b\r\nexp = a ** b\r\n\r\nprint(a, '+', b, '=', total)\r\nprint(a, '-', b, '=', diff)\r\nprint(a, '*', b, '=', prod)\r\nprint(a, '/', b, '=', div1)\r\nprint(a, '//', b, '=', div2)\r\nprint(a, '%', b, '=', mod)\r\nprint(a, '**', b, '=', exp)\r\n</strong>\r\n</pre>\r\nВ результате работы такой программы будет выведено:\r\n<pre>\r\n<strong>\r\n13 + 7 = 20\r\n13 - 7 = 6\r\n13 * 7 = 91\r\n13 / 7 = 1.8571428571428572\r\n13 // 7 = 1\r\n13 % 7 = 6\r\n13 ** 7 = 62748517\r\n</strong>\r\n</pre>\r\nПри обычном делении (/) получается число не являющееся целым. Деление на ноль приводит к ошибке.<br><br>\r\n\r\n<strong>Длинная арифметика</strong><br><br>\r\nОтличительной особенностью языка Python является неограниченность целочисленного типа данных. По факту, размер числа зависит только от наличия свободной памяти на компьютере. Это отличает Python от таких языков как C++, C, C#, Java где переменные целого типа данных имеют ограничение. \r\n<pre>\r\n<strong>\r\natom = 10 ** 80  # количество атомов во вселенной\r\nprint('Количество атомов =', atom)\r\n</strong>\r\n</pre>\r\nРезультатом выполнения программы будет число с 81 цифрой:\r\n<pre>\r\n<strong>\r\nКоличество атомов = 100000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n</strong>\r\n</pre>\r\n<strong>Символ разделитель</strong><br><br>\r\nДля удобного чтения чисел можно использовать символ подчеркивания:\r\n<pre>\r\n<strong>\r\nnum1 = 25_000_000\r\nnum2 = 25000000\r\nprint(num1)\r\nprint(num2)\r\n</strong>\r\n</pre>\r\nРезультатом выполнения такого кода будет:\r\n<pre>\r\n<strong>\r\n25000000\r\n25000000\r\n</strong>\r\n</pre>\r\n<strong>Числа с плавающей точкой</strong><br><br>\r\nНаравне с целыми числами в Python есть возможность работы с дробными (вещественными) числами. <br><br>\r\n\r\n<strong>Дробные (вещественные) числа в информатике называют числами с плавающей точкой.\r\n</strong><br><br>\r\nДля представления чисел с плавающей точкой в Python используется тип данных float.\r\n<pre>\r\n<strong>\r\ne = 2.71828  # литерал с плавающей точкой\r\npi = 3.1415  # литерал с плавающей точкой\r\n</strong>\r\n</pre>\r\nВ Python, когда вы используете операцию деления /, результат всегда будет числом с плавающей точкой, даже если оба числа являются целыми. Вот пример:\r\n<pre>\r\n<strong>\r\nprint(4 / 2)  # Результат: 2.0, а не 2\r\n</strong>\r\n</pre>\r\nВ отличие от математики, где разделителем является запятая, в информатике используется точка при записи чисел с плавающей точкой.<br><br>\r\n\r\n<strong>Преобразование строки к числу с плавающей точкой</strong><br><br>\r\nДля преобразования строки к числу с плавающей точкой мы используем команду float():\r\n<pre>\r\n<strong>\r\nnum = float(input()) # преобразование считанной строки в число с плавающей точкой\r\n</strong>\r\n</pre>\r\n\r\nСледующий код преобразует строку 1.2345 к числу с плавающей точкой:\r\n<pre>\r\n<strong>\r\nn = float('1.2345')  # преобразование строки к числу с плавающей точкой\r\n</strong>\r\n</pre>\r\nЕсли строка не является числом, то при преобразовании возникнет ошибка.<br><br>\r\n\r\n<strong>Арифметические операторы</strong><br><br>\r\nЯзык Python предоставляет четыре основных арифметических оператора для работы с числами с плавающей точкой (+, −, *, /) и один дополнительный (** – для возведения в степень).<br><br>\r\n\r\nСледующая программа демонстрирует арифметические операторы:\r\n<pre>\r\n<strong>\r\na = 13.5\r\nb = 2.0\r\n\r\ntotal = a + b\r\ndiff = a - b\r\nprod = a * b\r\ndiv = a / b\r\nexp = a ** b\r\n\r\nprint(a, '+', b, '=', total)\r\nprint(a, '-', b, '=', diff)\r\nprint(a, '*', b, '=', prod)\r\nprint(a, '/', b, '=', div)\r\nprint(a, '**', b, '=', exp)\r\n</strong>\r\n</pre>\r\nВ результате работы такой программы будет выведено:\r\n<pre>\r\n<strong>\r\n13.5 + 2.0 = 15.5\r\n13.5 - 2.0 = 11.5\r\n13.5 * 2.0 = 27.0\r\n13.5 / 2.0 = 6.75\r\n13.5 ** 2.0 = 182.25\r\n</strong>\r\n</pre>\r\nДеление на ноль приводит к ошибке.<br><br>\r\n\r\n<strong>Преобразование между int и float</strong><br><br>\r\nНеявное преобразование. Любое целое число (тип int) можно использовать там, где ожидается число с плавающей точкой (тип float), поскольку при необходимости Python автоматически преобразует целые числа в числа с плавающей точкой.<br><br>\r\n\r\nЯвное преобразование. Число с плавающей точкой нельзя неявно преобразовать в целое число. Для такого преобразования необходимо использовать явное преобразование с помощью команды int().\r\n<pre>\r\n<strong>\r\nnum1 = 17.89\r\nnum2 = -13.56\r\nnum3 = int(num1)\r\nnum4 = int(num2)\r\nprint(num3)\r\nprint(num4)\r\n</strong>\r\n</pre>\r\nРезультатом выполнения такого кода будет:\r\n<pre>\r\n<strong>\r\n17\r\n-13\r\n</strong>\r\n</pre>\r\nОбратите внимание, что преобразование чисел с плавающей точкой в целое производится с округлением в сторону нуля, то есть int(1.7) = 1, int(-1.7) = -1.",
    "slug": "int-float-digit"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 10,
  "fields": {
    "lesson": "Строковый тип данных",
    "content": "<strong>Строковый тип данных</strong><br><br>\r\nСтроки в Python используются, когда надо работать с текстовыми данными.<br><br>\r\n\r\nСоздание строки. Для создания строк мы используем парные кавычки '' или \"\":\r\n<pre>\r\n<strong>\r\ns1 = 'Python'\r\ns2 = \"Pascal\"\r\n</strong>\r\n</pre>\r\n<strong>Считывание строки</strong>.<br><br> Для считывания текстовых данных в строковую переменную мы используем функцию input():\r\n<pre>\r\n<strong>\r\ns = input()  # считали текст\r\nnum = int(input())  # считали текст и преобразовали его в целое число\r\n</strong>\r\n</pre>\r\n<strong>Пустая строка</strong>.<br><br> Для создания пустой строки мы пишем s = '' или s = \"\". Пустая строка – это аналог числа 0.\r\n\r\n<strong>Длина строки</strong>.<br><br> Для определения длины строки (количества символов) мы используем встроенную функцию len():\r\n<pre>\r\n<strong>\r\ns = 'Hello'\r\nn = len(s)  # значение переменной равно 5\r\nprint(n)\r\n</strong>\r\n</pre>\r\n<strong>Конкатенация и умножение на число</strong>.<br><br> Операторы + и * можно использовать для строк. Оператор + сцепляет две и более строк. Это называется конкатенацией строк. Оператор * повторяет строку указанное количество раз.\r\n<pre>\r\n<strong>\r\nВыражение\tРезультат\r\n'AB' + 'cd'\t'ABcd'\r\n'A' + '7' + 'B'\t'A7B'\r\n'Hi'* 4\t        'HiHiHiHi'\r\n</strong>\r\n</pre>\r\n<strong>Оператор принадлежности in</strong>.<br><br> С помощью оператора in мы можем проверять, находится ли одна строка в составе другой. То есть, является ли одна строка подстрокой другой:\r\n<pre>\r\n<strong>\r\ns = 'All you need is love'\r\nif 'love' in s:\r\n    print('❤️')\r\nelse:\r\n    print('💔')\r\n</strong>\r\n</pre>    \r\nТак как строка s содержит подстроку 'love', то будет выведен смайлик ❤️.<br><br>\r\n\r\n<strong>Индексация</strong><br><br>\r\nОчень часто бывает необходимо обратиться к конкретному символу в строке. Для этого в Python используются квадратные скобки [], в которых указывается индекс (номер) нужного символа в строке.<br><br>\r\n\r\nПусть s = 'Python'. Таблица ниже показывает, как работает индексация:\r\n<pre>\r\n<strong>\r\nВыражение\tРезультат\tПояснение\r\ns[0]\t            P\t    первый символ строки\r\ns[1]\t            y\t    второй символ строки\r\ns[2]\t            t\t    третий символ строки\r\ns[3]\t            h\t    четвертый символ строки\r\ns[4]\t            o\t    пятый символ строки\r\ns[5]\t            n\t    шестой символ строки\r\n</strong>\r\n</pre>\r\nОбратите внимание, первый символ строки равен s[0], а не s[1]. В Python индексация начинается с 0, по аналогии с функцией range(n), которая генерировала последовательность натуральных чисел от 0 до n - 1.<br><br>\r\n\r\nВ отличие от многих языков программирования, в Python есть возможность работы с отрицательными индексами. Если первый символ строки имеет индекс 0, то последнему элементу присваивается индекс -1.<br><br>\r\n\r\nЕсли s = 'Python', и мы попытаемся обратиться к s[17], то мы получим ошибку:\r\n<pre>\r\n<strong>\r\nIndexError: string index out of range\r\n</strong>\r\n</pre>\r\nОшибка возникает, поскольку строка содержит всего 6 символов.<br><br>\r\n<strong>Срезы строк</strong><br><br>\r\nИногда нужно бывает работать с целыми частями строки, в таком случае мы используем срезы (slices). Срезы похожи на комбинацию индексации и функции range().<br><br>\r\n\r\nРассмотрим строку s = 'abcdefghij'.\r\n\r\nС помощью среза мы можем получить несколько символов исходной строки, создав диапазон индексов разделенных двоеточием s[x:y].\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nprint(s[2:5])\r\nprint(s[0:6])\r\nprint(s[2:7])\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\ncde\r\nabcdef\r\ncdefg\r\n</strong>\r\n</pre>\r\nПри построении среза s[x:y] первое число – это то место, где начинается срез (включительно), а второе – это место, где заканчивается срез (невключительно). Разрезая строки, мы создаем подстроку, которая по сути является строкой внутри другой строки.<br><br>\r\nЕсли опустить второй параметр в срезе s[x:] (но поставить двоеточие), то срез берется до конца строки. Аналогично если опустить первый параметр s[:y], то можно взять срез от начала строки. Срез s[:] совпадает с самой строкой s.<br><br>\r\nМы также можем использовать отрицательные индексы для создания срезов. Как уже говорилось ранее, отрицательные индексы строки начинаются с -1 и отсчитываются до достижения начала строки. При использовании отрицательных индексов первый параметр среза должен быть меньше второго, либо должен быть пропущен.<br><br>\r\nМы можем передать в срез третий необязательный параметр, который отвечает за шаг среза. К примеру, срез s[1:7:2] создаст строку bdf состоящую из каждого второго символа (индексы 1, 3, 5, правая граница не включена в срез).<br><br>\r\nЕсли в качестве шага среза указать отрицательное число, то символы будут идти в обратном порядке.<br><br>\r\n\r\n<strong>Изменение символа строки по индексу</strong><br><br>\r\nПредположим, у нас есть строка s = 'abcdefghij' и мы хотим заменить символ с индексом 4 на 'X'. Можно попытаться написать код:\r\n<pre>\r\n<strong>\r\ns[4] = 'X'\r\n</strong>\r\n</pre>\r\nОднако такой код не работает. В Python строки являются неизменяемыми, то есть мы не можем менять их содержимое с помощью индексатора.<br><br>\r\n\r\nЕсли мы хотим поменять какой-либо символ строки s, мы должны создать новую строку. Следующий код использует срезы и решает поставленную задачу:\r\n<pre>\r\n<strong>\r\ns = s[:4] + 'X' + s[5:]\r\n</strong>\r\n</pre>\r\nМы создаем два среза: от начала строки до 3 символа и с 5 символа по конец строки, а между ними вставляем нужный нам символ, который встанет на 4 позицию.<br><br>\r\n\r\n<strong>Методы строк</strong><br><br>\r\n<strong>Метод capitalize()</strong> возвращает копию строки s, в которой первый символ имеет верхний регистр, а все остальные символы имеют нижний регистр. Символы, не являющиеся буквами алфавита, остаются неизменными.\r\n\r\nРезультатом выполнения следующего кода:\r\n<pre>\r\n<strong>\r\ns = 'foO BaR BAZ quX'\r\nprint(s.capitalize())\r\n</strong>\r\n</pre>\r\nбудет:\r\n<pre>\r\n<strong>\r\nFoo bar baz qux\r\n</strong>\r\n</pre>\r\n<strong>Метод swapcase()</strong> возвращает копию строки s, в которой все символы, имеющие верхний регистр, преобразуются в символы нижнего регистра и наоборот.\r\n\r\nРезультатом выполнения следующего кода:\r\n<pre>\r\n<strong>\r\ns = 'FOO Bar 123 baz qUX'\r\nprint(s.swapcase())\r\n</strong>\r\n</pre>\r\nбудет:\r\n<pre>\r\n<strong>\r\nfoo bAR 123 BAZ Qux\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод title()</strong> возвращает копию строки s, в которой первый символ каждого слова переводится в верхний регистр. Этот метод использует довольно простой алгоритм: он не пытается различить важные и неважные слова и не обрабатывает аббревиатуры и апострофы.\r\n\r\nРезультатом выполнения следующего кода:\r\n<pre>\r\n<strong>\r\ns = 'the sun also rises'\r\nprint(s.title())\r\n</strong>\r\n</pre>\r\nбудет:\r\n<pre>\r\n<strong>\r\nThe Sun Also Rises\r\n</strong>\r\n</pre>\r\n<strong>Метод lower()</strong> возвращает копию строки s, в которой все символы имеют нижний регистр.\r\n\r\nРезультатом выполнения следующего кода:\r\n<pre>\r\n<strong>\r\ns = 'FOO Bar 123 baz qUX'\r\nprint(s.lower())\r\n</strong>\r\n</pre>\r\nбудет:\r\n<pre>\r\n<strong>\r\nfoo bar 123 baz qux\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод upper()</strong> возвращает копию строки s, в которой все символы имеют верхний регистр.\r\n\r\nРезультатом выполнения следующего кода:\r\n<pre>\r\n<strong>\r\ns = 'FOO Bar 123 baz qUX'\r\nprint(s.upper())\r\n</strong>\r\n</pre>\r\nбудет:\r\n<pre>\r\n<strong>\r\nFOO BAR 123 BAZ QUX\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод count(sub, start, end)</strong> считает количество непересекающихся вхождений подстроки sub в исходную строку s.\r\n\r\nПриведённый ниже код:\r\n<pre>\r\n<strong>\r\ns = 'foo goo moo'\r\nprint(s.count('oo'))\r\nprint(s.count('oo', 0, 8))  # подсчет с 0 по 7 символ\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n3\r\n2\r\n</strong>\r\n</pre>\r\n<strong>Метод startswith(suffix, start, end)</strong> определяет, начинается ли исходная строка s подстрокой suffix. Если исходная строка начинается с подстроки suffix, метод возвращает значение True, а если нет, то значение False.\r\n\r\nПриведённый ниже код:\r\n<pre>\r\n<strong>\r\ns = 'foobar'\r\nprint(s.startswith('foo'))\r\nprint(s.startswith('baz'))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTrue\r\nFalse\r\n</strong>\r\n</pre>\r\n<strong>Метод endswith(suffix, start, end)</strong> определяет, оканчивается ли исходная строка s подстрокой suffix. Метод возвращает значение True, если исходная строка оканчивается на подстроку suffix, или False в противном случае.\r\n\r\nПриведённый ниже код:\r\n<pre>\r\n<strong>\r\ns = 'foobar'\r\nprint(s.endswith('bar'))\r\nprint(s.endswith('baz'))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTrue\r\nFalse\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод find(sub, start, end)</strong> находит индекс первого вхождения подстроки sub в исходной строке s. Если строка s не содержит подстроки sub, то метод возвращает значение -1. Мы можем использовать данный метод наравне с оператором in для проверки: содержит ли заданная строка некоторую подстроку или нет.\r\n\r\nПриведённый ниже код:\r\n<pre>\r\n<strong>\r\ns = 'foo bar foo baz foo qux'\r\nprint(s.find('foo'))\r\nprint(s.find('bar'))\r\nprint(s.find('qu'))\r\nprint(s.find('python'))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n0\r\n4\r\n20\r\n-1\r\n</strong>\r\n</pre>\r\n<strong>Метод rfind(sub, start, end)</strong> идентичен методу find(sub, start, end), за тем исключением, что он ищет первое вхождение подстроки sub, начиная с конца строки s.<br><br>\r\n\r\n<strong>Метод index(sub, start, end)</strong> идентичен методу find(sub, start, end), за тем исключением, что он вызывает ошибку ValueError: substring not found во время выполнения программы, если подстрока sub не найдена.<br><br>\r\n\r\n<strong>Метод rindex(sub, start, end)</strong> идентичен методу index(sub, start, end), за тем исключением, что он ищет первое вхождение подстроки sub, начиная с конца строки s.<br><br>\r\n\r\nМетоды find() и rfind() являются более безопасными чем index() и rindex(), так как не приводят к возникновению ошибки во время выполнения программы.<br><br>\r\n\r\n<strong>Метод strip()</strong> возвращает копию строки s, у которой удалены все пробелы, стоящие в начале и конце строки.\r\n\r\nПриведённый ниже код:\r\n<pre>\r\n<strong>\r\ns = '     foo bar foo baz foo qux      '\r\nprint(s.strip())\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nfoo bar foo baz foo qux\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод lstrip()</strong> возвращает копию строки s, у которой удалены все пробелы, стоящие в начале строки.\r\n\r\nПриведённый ниже код:\r\n<pre>\r\n<strong>\r\ns = '     foo bar foo baz foo qux      '\r\nprint(s.lstrip())\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nfoo bar foo baz foo qux⎵ ⎵ ⎵ ⎵ ⎵ ⎵\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод rstrip()</strong> возвращает копию строки s, у которой удалены все пробелы, стоящие в конце строки.\r\n\r\nПриведённый ниже код:\r\n<pre>\r\n<strong>\r\ns = '      foo bar foo baz foo qux      '\r\nprint(s.rstrip())\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n⎵ ⎵ ⎵ ⎵ ⎵ ⎵foo bar foo baz foo qux\r\n</strong>\r\n</pre>\r\nМетоды strip(), lstrip(), rstrip() могут принимать на вход опциональный аргумент<chars>. Необязательный аргумент <chars>– это строка, которая определяет набор символов для удаления.<br><br>\r\n\r\n<strong>Метод replace(old, new)</strong> возвращает копию s со всеми вхождениями подстроки old, замененными на <new>. Также может принимать опциональный третий аргумент count, который определяет количество замен.\r\n\r\nПриведённый ниже код:\r\n<pre>\r\n<strong>\r\ns = 'foo bar foo baz foo qux'\r\nprint(s.replace('foo', 'grault'))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\ngrault bar grault baz grault qux\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод isalnum()</strong> определяет, состоит ли исходная строка из буквенно-цифровых символов. Метод возвращает значение True, если исходная строка является непустой и состоит только из буквенно-цифровых символов, или False в противном случае. Обратите внимание, что метод isalnum() возвращает значение True даже в том случае, когда строка состоит только из буквенных или только из цифровых символов.\r\n\r\nПриведённый ниже код:\r\n<pre>\r\n<strong>\r\ns1 = 'abc123'\r\ns2 = 'abc$*123'\r\ns3 = ''\r\n\r\nprint(s1.isalnum())\r\nprint(s2.isalnum())\r\nprint(s3.isalnum())\r\n</strong>\r\n</pre>\r\n\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTrue\r\nFalse\r\nFalse\r\n</strong>\r\n</pre>\r\n<strong>Метод isalpha()</strong> определяет, состоит ли исходная строка из буквенных символов. Метод возвращает значение True, если исходная строка является непустой и состоит только из буквенных символов, или False в противном случае.\r\n\r\nПриведённый ниже код:\r\n<pre>\r\n<strong>\r\ns1 = 'ABCabc'\r\ns2 = 'abc123'\r\ns3 = ''\r\n\r\nprint(s1.isalpha())\r\nprint(s2.isalpha())\r\nprint(s3.isalpha())\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTrue\r\nFalse\r\nFalse\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод isdigit()</strong> определяет, состоит ли исходная строка только из цифровых символов. Метод возвращает значение True, если исходная строка является непустой и состоит только из цифровых символов, или False в противном случае.\r\n\r\nПриведённый ниже код:\r\n<pre>\r\n<strong>\r\ns1 = '1234567'\r\ns2 = 'abc123'\r\ns3 = ''\r\n\r\nprint(s1.isdigit())\r\nprint(s2.isdigit())\r\nprint(s3.isdigit())\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTrue\r\nFalse\r\nFalse\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод islower()</strong> определяет, являются ли все буквенные символы исходной строки строчными (имеют нижний регистр). Метод возвращает значение True, если все буквенные символы исходной строки являются строчными, или False в противном случае. Обратите внимание, что метод islower() игнорирует все небуквенные символы.\r\n\r\nПриведённый ниже код:\r\n<pre>\r\n<strong>\r\ns1 = 'abc'\r\ns2 = 'abc1$d'\r\ns3 = 'Abc1$D'\r\n\r\nprint(s1.islower())\r\nprint(s2.islower())\r\nprint(s3.islower())\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTrue\r\nTrue\r\nFalse\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод isupper()</strong> определяет, являются ли все буквенные символы исходной строки заглавными (имеют верхний регистр). Метод возвращает значение True, если все буквенные символы исходной строки являются заглавными, или False в противном случае. Обратите внимание, что метод isupper() игнорирует все небуквенные символы.\r\n\r\nПриведённый ниже код:\r\n<pre>\r\n<strong>\r\ns1 = 'ABC'\r\ns2 = 'ABC1$D'\r\ns3 = 'Abc1$D'\r\n\r\nprint(s1.isupper())\r\nprint(s2.isupper())\r\nprint(s3.isupper())\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTrue\r\nTrue\r\nFalse\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод isspace()</strong> определяет, состоит ли исходная строка только из пробельных символов. Метод возвращает значение True, если строка состоит только из пробельных символов, или False в противном случае. Для пустой строки метод isspace() также возвращает False, так как в этом случае строка не состоит из пробельных символов.\r\n\r\nПриведённый ниже код:\r\n<pre>\r\n<strong>\r\ns1 = '       '\r\ns2 = 'abc1$d'\r\n\r\nprint(s1.isspace())\r\nprint(s2.isspace())\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTrue\r\nFalse\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод split()</strong> разбивает строку на слова, используя в качестве разделителя последовательность пробельных символов, и возвращает список из этих слов. У метода split() есть необязательный параметр, который определяет, какой набор символов будет использоваться в качестве разделителя между элементами списка. \r\n\r\nПриведённый ниже код:\r\n<pre>\r\n<strong>\r\ns = 'Python is the most powerful language'\r\nwords = s.split()\r\nprint(words)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n['Python', 'is', 'the', 'most', 'powerful', 'language']\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод join()</strong> собирает строку из элементов списка, используя в качестве разделителя строку, к которой применяется метод.\r\n\r\nПриведённый ниже код:\r\n<pre>\r\n<strong>\r\nwords = ['Python', 'is', 'the', 'most', 'powerful', 'language']\r\ns = ' '.join(words)\r\nprint(s)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nPython is the most powerful language\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод fomat().</strong> Для более наглядного форматирования мы можем использовать строковый метод format(). Мы передаем необходимые параметры методу format(), а Python ставит их вместо фигурных скобок {} – заполнителей. Мы можем создавать сколько угодно заполнителей.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nbirth_year = 1972\r\nname = 'Jared'\r\nprofession = 'programmer'\r\ntext = 'My name is {}, I was born in {}, I work as a {}.'.format(name, birth_year, profession)\r\n\r\nprint(text)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nMy name is Jared, I was born in 1972, I work as a programmer.\r\n</strong>\r\n</pre>\r\n\r\n<strong>f-строки</strong>. В Python 3.6 появилась новая разновидность строк — f-строки. Если поставить перед строкой префикс f, в заполнители можно будет включить код, например, имя переменной или любые другие выражения. f-строки обеспечивают чистый и интуитивно понятный способ форматирования строк. На место заполнителя {first_name} встает значение переменной first_name, на место заполнителя {last_name} встает значение переменной last_name и т.д.\r\n<pre>\r\n<strong>\r\nfirst_name = 'Taylor'\r\nlast_name = 'Swift'\r\ncountry = 'USA'\r\nbirth_date = '1989/12/13'\r\nbirth_place = 'West Reading, Pennsylvania'\r\ntext = f'{first_name} {last_name} is a very famous singer from the {country}. She was born on {birth_date} in {birth_place}.'\r\n\r\nprint(text)\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция ord()</strong> позволяет определить код некоторого символа в таблице символов Unicode. Аргументом данной функции является одиночный символ. Обратите внимание, что функция ord() принимает именно одиночный символ. Если попытаться передать строку, содержащую более одного символа, мы получим ошибку времени выполнения.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnum1 = ord('A')\r\nnum2 = ord('B')\r\nnum3 = ord('a') \r\nprint(num1, num2, num3)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n65 66 97\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция chr()</strong> позволяет определить по коду символа сам символ. Аргументом данной функции является численный код.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nchr1 = chr(65)\r\nchr2 = chr(75)\r\nchr3 = chr(110)\r\n\r\nprint(chr1, chr2, chr3)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nA K n\r\n</strong>\r\n</pre>",
    "slug": "string-data-type"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 11,
  "fields": {
    "lesson": "Списки",
    "content": "<strong>Списки</strong><br><br>\r\nСписки - это структура данных, которая в большинстве языков программирования называется массивом. В Python она называется списком. Однако разница между списками и массивами все же существует. Элементы массива всегда имеют одинаковый тип данных и располагаются в памяти компьютера непрерывным блоком, а элементы списка могут быть разбросаны по памяти как угодно и могут иметь разный тип данных.<br><br>Список представляет собой последовательность элементов, пронумерованных от 0, как символы в строке. Значения, заключенные в квадратные скобки и отделенные запятыми, называются элементами списка.<br><br>\r\n\r\nСтруктура данных (data structure) — программная единица, позволяющая хранить и обрабатывать множество однотипных и/или логически связанных данных.<br><br>\r\n\r\n<strong>Создание списка</strong><br><br>\r\nЧтобы создать список, нужно перечислить его элементы через запятую в квадратных скобках:\r\n<pre>\r\n<strong>\r\nnumbers = [2, 4, 6, 8, 10]\r\nlanguages = ['Python', 'C#', 'C++', 'Java']\r\n</strong>\r\n</pre>\r\nСписок numbers состоит из 5 элементов, и каждый из них — целое число.\r\n<pre>\r\n<strong>\r\nnumbers[0] == 2;\r\nnumbers[1] == 4;\r\nnumbers[2] == 6;\r\nnumbers[3] == 8;\r\nnumbers[4] == 10.\r\n</strong>\r\n</pre>\r\nСписок languages состоит из 4 элементов, каждый из которых — строка.\r\n<pre>\r\n<strong>\r\nlanguages[0] == 'Python';\r\nlanguages[1] == 'C#';\r\nlanguages[2] == 'C++';\r\nlanguages[3] == 'Java'.\r\n</strong>\r\n</pre>\r\nСписок может содержать значения разных типов данных. Обычно элементы списка содержат данные одного типа, и на практике редко приходится создавать списки, содержащие элементы разных типов данных.<br><br>\r\n\r\n<strong>Пустой список</strong><br><br>\r\nСоздать пустой список можно двумя способами:<br><br>\r\n\r\n<li>Использовать пустые квадратные скобки [];</li>\r\n<li>Использовать встроенную функцию, которая называется list.</li><br><br>\r\nСледующие две строки кода создают пустой список:\r\n<pre>\r\n<strong>\r\nmylist = []  # пустой список\r\nmylist = list()  # тоже пустой список\r\n</strong>\r\n</pre>\r\n\r\nPython имеет встроенную <strong>функцию list()</strong>, которая помимо создания пустого списка может преобразовывать некоторые типы объектов в списки.\r\n\r\nНапример, мы знаем, что функция range() создает последовательность целых чисел в заданном диапазоне. Для преобразования этой последовательности в список, мы пишем следующий код:\r\n<pre>\r\n<strong>\r\nnumbers = list(range(5))\r\n</strong>\r\n</pre>\r\n\r\n<strong>Длиной списка</strong> называется количество его элементов. Для того, чтобы посчитать длину списка мы используем встроенную функцию len() (от слова length – длина).\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nnumbers = [2, 4, 6, 8, 10]\r\nlanguages = ['Python', 'C#', 'C++', 'Java']\r\n\r\nprint(len(numbers))      # выводим длину списка numbers\r\nprint(len(languages))    # выводим длину списка languages\r\n\r\nprint(len(['apple', 'banana', 'cherry']))   # выводим длину списка, состоящего из 3 элементов\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\n5\r\n4\r\n3\r\n</strong>\r\n</pre>\r\n\r\n<strong>Оператор in</strong> позволяет проверить, содержит ли список некоторый элемент.\r\n\r\nРассмотрим следующий код:\r\n<pre>\r\n<strong>\r\nnumbers = [2, 4, 6, 8, 10]\r\n\r\nif 2 in numbers:\r\n    print('Список numbers содержит число 2')\r\nelse:\r\n    print('Список numbers не содержит число 2')\r\n</strong>\r\n</pre>\r\nТакой код проверяет, содержит ли список numbers число 2 и выводит соответствующий текст:\r\n<pre>\r\n<strong>\r\nСписок numbers содержит число 2\r\n</strong>\r\n</pre>\r\n\r\nПри работе со строками мы использовали <strong>индексацию</strong>, то есть обращение к конкретному символу строки по его индексу. Аналогично, можно индексировать и списки.<br><br>\r\n\r\nДля индексации списков в Python используются квадратные скобки [], в которых указывается индекс (номер) нужного элемента в списке. Так же, как и в строках, для нумерации с конца разрешены отрицательные индексы.\r\n\r\nКак и в строках, попытка обратиться к элементу списка по несуществующему индексу вызовет ошибку:\r\n<pre>\r\n<strong>\r\nIndexError: index out of range\r\n</strong>\r\n</pre>\r\n\r\nС помощью <strong>среза</strong> мы можем получить несколько элементов списка, создав диапазон индексов, разделенных двоеточием numbers[x:y]. При построении среза numbers[x:y] первое число – это то место, где начинается срез (включительно), а второе – это место, где заканчивается срез (невключительно). Разрезая списки, мы создаем новые списки, по сути, подсписки исходного.<br><br>\r\n\r\nРассмотрим список numbers = [2, 4, 6, 8, 10].\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nprint(numbers[1:3])\r\nprint(numbers[2:5])\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n[4, 6]\r\n[6, 8, 10]\r\n</strong>\r\n</pre>\r\n\r\n<strong>Использование срезов для изменения элементов в заданном диапазоне</strong><br><br>\r\nДля изменения целого диапазона элементов списка можно использовать срезы. Например, если мы хотим перевести на русский язык названия фруктов 'banana', 'cherry', 'kiwi', то это можно сделать с помощью среза.<br><br>\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nfruits = ['apple', 'apricot', 'banana', 'cherry', 'kiwi', 'lemon', 'mango']\r\nfruits[2:5] = ['банан', 'вишня', 'киви']\r\n\r\nprint(fruits)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n['apple', 'apricot', 'банан', 'вишня', 'киви', 'lemon', 'mango']\r\n</strong>\r\n</pre>\r\n\r\n<strong>Операция конкатенации + и умножения на число *</strong><br><br>\r\nМы можем применять операторы + и * для списков подобно тому, как мы это делали со строками.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nprint([1, 2, 3, 4] + [5, 6, 7, 8])\r\nprint([7, 8] * 3)\r\nprint([0] * 10)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n[1, 2, 3, 4, 5, 6, 7, 8]\r\n[7, 8, 7, 8, 7, 8]\r\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\r\n</strong>\r\n</pre>\r\n\r\n<strong>Встроенные функции sum(), min(), max()</strong><br><br>\r\nВстроенная <strong>функция sum()</strong> принимает в качестве параметра список чисел и вычисляет сумму его элементов.<br><br>\r\n\r\nВстроенные <strong>функции min() и max()</strong> принимают в качестве параметра список и находят минимальный и максимальный элементы соответственно.<br><br>\r\n\r\n<strong>Списочные выражения</strong><br><br>\r\nВ Python есть механизм для создания списков из неповторяющихся элементов. Такой механизм называется — списочное выражение (list comprehension).\r\n\r\nПредыдущий код можно записать следующим образом:\r\n<pre>\r\n<strong>\r\nnumbers = [i for i in range(10)]\r\n</strong>\r\n</pre>\r\nОбщий вид списочного выражения следующий:\r\n<pre>\r\n<strong>\r\n[выражение for переменная in последовательность]\r\n</strong>\r\n</pre>\r\n\r\nгде переменная — имя некоторой переменной, последовательность — последовательность значений, которые она принимает (список, строка или объект, полученный при помощи функции range), выражение — некоторое выражение, как правило, зависящее от использованной в списочном выражении переменной, которым будут заполнены элементы списка. <br><br>\r\n\r\n<strong>Методы списков</strong><br><br>\r\n\r\n<strong>Метод append()</strong>\r\nДля добавления нового элемента в конец списка используется метод append(). Обратите внимание, для того чтобы использовать метод append(), нужно, чтобы список был создан (при этом он может быть пустым).\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nnumbers = [1, 1, 2, 3, 5, 8, 13]  # создаем список\r\n\r\nnumbers.append(21)  # добавляем число 21 в конец списка\r\nnumbers.append(34)  # добавляем число 34 в конец списка\r\n\r\nprint(numbers)\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\n[1, 1, 2, 3, 5, 8, 13, 21, 34]\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод extend()</strong>\r\nМожно также расширить список другим списком путем вызова метода extend(). Он как бы расширяет один список, добавляя к нему элементы другого списка.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nnumbers = [0, 2, 4, 6, 8, 10]\r\nodds = [1, 3, 5, 7]\r\n\r\nnumbers.extend(odds)\r\nprint(numbers)\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\n[0, 2, 4, 6, 8, 10, 1, 3, 5, 7]\r\n</strong>\r\n</pre>\r\n\r\nОтличие между методами append() и extend() проявляется при добавлении строки к списку.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nwords1 = ['iq option', 'stepik', 'beegeek']\r\nwords2 = ['iq option', 'stepik', 'beegeek']\r\n\r\nwords1.append('python')\r\nwords2.extend('python')\r\n\r\nprint(words1)\r\nprint(words2)\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\n['iq option', 'stepik', 'beegeek', 'python']\r\n['iq option', 'stepik', 'beegeek', 'p', 'y', 't', 'h', 'o', 'n']\r\n</strong>\r\n</pre>\r\nМетод append() добавляет строку 'python' целиком к списку, а метод extend() разбивает строку 'python' на  символы 'p', 'y', 't', 'h', 'o', 'n' и их добавляет в качестве элементов списка.<br><br>\r\n\r\nС помощью <strong>оператора del</strong> можно удалять элементы списка по определенному индексу. Оператор del работает и со срезами: мы можем удалить целый диапазон элементов списка.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\r\ndel numbers[5]    # удаляем элемент имеющий индекс 5\r\n\r\nprint(numbers)\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\n[1, 2, 3, 4, 5, 7, 8, 9]\r\n</strong>\r\n</pre>\r\nЭлемент под указанным индексом удаляется, а список перестраивается.<br><br>\r\n\r\n<strong>Метод insert()</strong> позволяет вставлять значение в список в заданной позиции. В него передается два аргумента:<br><br>\r\n\r\nindex: индекс, задающий место вставки значения;<br>\r\nvalue: значение, которое требуется вставить.<br><br>\r\nКогда значение вставляется в список, список расширяется в размере, чтобы разместить новое значение. Значение, которое ранее находилось в заданной индексной позиции, и все элементы после него сдвигаются на одну позицию к концу списка.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nnames = ['Gvido', 'Roman' , 'Timur']\r\nprint(names)\r\nnames.insert(0, 'Anders')\r\nprint(names)\r\nnames.insert(3, 'Josef')\r\nprint(names)\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\n['Gvido', 'Roman' , 'Timur']\r\n['Anders', 'Gvido', 'Roman' , 'Timur']\r\n['Anders', 'Gvido', 'Roman' , 'Josef', 'Timur']\r\n</strong>\r\n</pre>\r\nЕсли указан недопустимый индекс, то во время выполнения программы не происходит ошибки. Если задан индекс за пределами конца списка, то значение будет добавлено в конец списка. Если применен отрицательный индекс, который указывает на недопустимую позицию, то значение будет вставлено в начало списка.<br><br>\r\n\r\n<strong>Метод index()</strong> возвращает индекс первого элемента, значение которого равняется переданному в метод значению. Таким образом, в метод передается один параметр:<br><br>\r\n\r\nvalue: значение, индекс которого требуется найти.<br><br>\r\nЕсли элемент в списке не найден, то во время выполнения происходит ошибка.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nnames = ['Gvido', 'Roman' , 'Timur']\r\nposition = names.index('Timur')\r\nprint(position)\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\n2\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод remove()</strong> удаляет первый элемент, значение которого равняется переданному в метод значению. В метод передается один параметр:<br><br>\r\n\r\nvalue: значение, которое требуется удалить.<br><br>\r\nМетод уменьшает размер списка на один элемент. Все элементы после удаленного элемента смещаются на одну позицию к началу списка. Если элемент в списке не найден, то во время выполнения происходит ошибка.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nfood = ['Рис', 'Курица', 'Рыба', 'Брокколи', 'Рис']\r\nprint(food)\r\nfood.remove('Рис')\r\nprint(food)\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\n['Рис', 'Курица', 'Рыба', 'Брокколи', 'Рис']\r\n['Курица', 'Рыба', 'Брокколи', 'Рис']\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод pop()</strong> удаляет элемент по указанному индексу и возвращает его. В метод pop() передается один необязательный аргумент:<br><br>\r\n\r\nindex: индекс элемента, который требуется удалить.<br><br>\r\nЕсли индекс не указан, то метод удаляет и возвращает последний элемент списка. Если список пуст или указан индекс за пределами диапазона, то во время выполнения происходит ошибка.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nnames = ['Gvido', 'Roman' , 'Timur']\r\nitem = names.pop(1)\r\nprint(item)\r\nprint(names)\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\nRoman\r\n['Gvido', 'Timur']\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод count()</strong> возвращает количество элементов в списке, значения которых равны переданному в метод значению. \r\n\r\nТаким образом, в метод передается один параметр:<br><br>\r\n\r\nvalue: значение, количество элементов, равных которому,  нужно посчитать.<br><br>\r\nЕсли значение в списке не найдено, то метод возвращает 0.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nnames = ['Timur', 'Gvido', 'Roman', 'Timur', 'Anders', 'Timur']\r\ncnt1 = names.count('Timur')\r\ncnt2 = names.count('Gvido')\r\ncnt3 = names.count('Josef')\r\n\r\nprint(cnt1)\r\nprint(cnt2)\r\nprint(cnt3)\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\n3\r\n1\r\n0\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод reverse()</strong> инвертирует порядок следования значений в списке, то есть меняет его на противоположный.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nnames = ['Gvido', 'Roman' , 'Timur']\r\nnames.reverse()\r\nprint(names)\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\n['Timur', 'Roman', 'Gvido']\r\n</strong>\r\n</pre>\r\nСуществует большая разница между вызовом метода names.reverse() и использованием среза names[::-1]. Метод reverse() меняет порядок элементов на обратный в текущем списке, а срез создает копию списка, в котором элементы следуют в обратном порядке.<br><br>\r\n\r\n<strong>Метод clear()</strong> удаляет все элементы из списка.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nnames = ['Gvido', 'Roman' , 'Timur']\r\nnames.clear()\r\nprint(names)\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\n[]\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод copy()</strong> создает поверхностную копию списка. Аналогичного результата можно достичь с помощью срезов или функции list()\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nnames = ['Gvido', 'Roman' , 'Timur']\r\nnames_copy = names.copy()              # создаем поверхностную копию списка names\r\n\r\nprint(names)\r\nprint(names_copy)\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\n['Gvido', 'Roman', 'Timur']\r\n['Gvido', 'Roman', 'Timur']\r\n</strong>\r\n</pre>\r\n\r\n<strong>метод sort()</strong> сортирует элементы списка по возрастанию или убыванию. По умолчанию метод sort() сортирует список по возрастанию. Если требуется отсортировать список по убыванию, необходимо явно указать параметр reverse = True. Метод sort() использует алгоритм Timsort.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\na = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99]\r\na.sort()\r\nprint('Отсортированный список:', a)\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\nОтсортированный список: [-67, -3, -2, 0, 1, 6, 7, 8, 9, 12, 34, 45, 99, 1000]\r\n</strong>\r\n</pre>",
    "slug": "list-data-type"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 12,
  "fields": {
    "lesson": "Словари",
    "content": "<strong>Cловари</strong> – изменяемые коллекции элементов с произвольными индексами – ключами. Если в списках элементы индексируются целыми числами, начиная с 0, то в словарях — любыми ключами, в том числе в виде строк. Словарь — реализация структуры данных \"ассоциативный массив\" или \"хеш таблица\". В других языках аналогичная структура называется map, HashMap, Dictionary. Словари принципиально отличаются от списков по структуре хранения в памяти. Список — последовательная область памяти, то есть все его элементы (указатели на элементы) действительно хранятся в указанном порядке, расположены последовательно. Благодаря этому и можно быстро «прыгнуть» к элементу по его индексу. В словаре же используется специальная структура данных — хеш-таблица. Она позволяет вычислять числовой хеш от ключа и использовать обычные списки, где в качестве индекса элемента берется этот хеш.<br><br>\r\n\r\n<li>Обращение по индексу и срезы недоступны для словарей.</lt>\r\n\r\n<li>Операция конкатенации + и умножения на число * недоступны для словарей.</li><br><br>\r\n\r\nСловари нужно использовать в следующих случаях:<br><br>\r\n\r\n<li>Подсчет числа каких-то объектов. В этом случае нужно завести словарь, в котором ключи — названия объектов, а значения — их количество.</li>\r\n<li>Хранение каких-либо данных, связанных с объектом. Ключи — наименования объектов, значения — связанные с ними данные. Например, если нужно по названию месяца определить его порядковый номер, то это можно сделать при помощи словаря num = {'January': 1, 'February': 2, 'March': 3, ...}.</li>\r\n<li>Установка соответствия между объектами (например, “родитель-потомок”). Ключ — объект, значение — соответствующий ему объект.</li>\r\n<li>Если нужен обычный список, где максимальное значение индекса элемента очень велико, но при этом используются не все возможные индексы (так называемый “разреженный список”), то для экономии памяти можно использовать словарь.</li><br><br>\r\n\r\n<strong>Создание словаря</strong><br><br>\r\nЧтобы создать словарь, нужно перечислить его элементы – пары ключ-значение – через запятую в фигурных скобках, как и элементы множества. Первым указывается ключ, после двоеточия — значение, доступное в словаре по этому ключу.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nlanguages = {'Python': 'Гвидо ван Россум', \r\n             'C#': 'Андерс Хейлсберг', \r\n             'Java': 'Джеймс Гослинг', \r\n             'C++': 'Бьёрн Страуструп'}\r\n</strong>\r\n</pre>\r\nсоздает словарь, в котором ключом служит строка — название языка программирования, а значением — имя создателя языка.<br><br>\r\n\r\n<strong>Создание словаря с помощью функции dict()</strong><br><br>\r\nЕсли ключи словаря — строки без каких-либо специальных символов, то для создания словаря можно использовать функцию dict().\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ninfo = dict(name='Timur', age=28, job='Teacher')\r\n</strong>\r\n</pre>\r\nсоздает словарь с тремя элементами, ключами которого служат строки 'name', 'age', 'job', а значениями – 'Timur', 28, 'Teacher'.<br><br>\r\n\r\n<strong>Создание словаря на основании списков и кортежей</strong><br><br>\r\nСоздавать словари можно на основе списков кортежей или кортежей списков. Первый элемент списка или кортежа станет ключом, второй — значением.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ninfo_list = [('name', 'Timur'), ('age', 28), ('job', 'Teacher')]  # список кортежей\r\n\r\ninfo_dict = dict(info_list)  # создаем словарь на основе списка кортежей\r\n</strong>\r\n</pre>\r\nсоздает словарь с тремя элементами, где ключи — строки name, age, job, а соответствующие им значения — 'Timur', 28, 'Teacher'.\r\n\r\nАналогично работает приведенный ниже код: \r\n<pre>\r\n<strong>\r\ninfo_tuple = (['name', 'Timur'], ['age', 28], ['job', 'Teacher'])  # кортеж списков\r\n\r\ninfo_dict = dict(info_tuple)  # создаем словарь на основе кортежа списков\r\n</strong>\r\n</pre>\r\nЕсли необходимо создать словарь, каждому ключу которого соответствует одно и то же значение, можно воспользоваться методом fromkeys().\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndict1 = dict.fromkeys(['name', 'age', 'job'], 'Missed information')\r\n</strong>\r\n</pre>\r\nсоздает словарь с тремя элементами, где ключи — строки 'name', 'age', 'job', а соответствующие им значения: 'Missed information', 'Missed information', 'Missed information'.\r\n\r\n   Если методу fromkeys() не передать второй параметр, то по умолчанию присваивается значение None.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndict1 = dict.fromkeys(['name', 'age', 'job'])\r\n</strong>\r\n</pre>\r\nсоздает словарь с тремя элементами, в которых ключи — строки 'name', 'age', 'job', а значения — None, None, None.<br><br>\r\n\r\n<strong>Пустой словарь</strong><br><br>\r\nПустой словарь можно создать двумя способами:<br><br>\r\n\r\n<li>с помощью пустых фигурных скобок;</li>\r\n<li>с помощью функции dict().</li>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndict1 = {}\r\ndict2 = dict()\r\n\r\n\r\nprint(dict1)\r\nprint(dict2)\r\nprint(type(dict1))\r\nprint(type(dict2))\r\n</strong>\r\n</pre>\r\nсоздает два пустых словаря и выводит:\r\n<pre>\r\n<strong>\r\n{}\r\n{}\r\n<class 'dict'>\r\n<class 'dict'>\r\n</strong>\r\n</pre>\r\n\r\n<strong>Вывод словаря</strong><br><br>\r\nДля вывода всего словаря можно использовать функцию print():\r\n<pre>\r\n<strong>\r\nlanguages = {'Python': 'Гвидо ван Россум', \r\n             'C#': 'Андерс Хейлсберг', \r\n             'Java': 'Джеймс Гослинг'}\r\n\r\ninfo = dict(name = 'Timur', age = 28, job = 'Teacher')\r\n\r\nprint(languages)\r\nprint(info)\r\n</strong>\r\n</pre>\r\nФункция print() выводит на экран элементы словаря в фигурных скобках, разделенные запятыми:\r\n<pre>\r\n<strong>\r\n{'Python': 'Гвидо ван Россум', 'C#': 'Андерс Хейлсберг', 'Java': 'Джеймс Гослинг'}\r\n{'name': 'Timur', 'age': 28, 'job': 'Teacher'}\r\n</strong>\r\n</pre>\r\nНачиная с версии Python 3.6, словари являются упорядоченными, то есть сохраняют порядок следования ключей в порядке их внесения в словарь.<br><br>\r\n\r\n<strong>Функция len()</strong><br><br>\r\n<strong>Длиной словаря</strong> называется количество его элементов. Для определения длины словаря используют встроенную функцию len() (от слова length – длина).\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nfruits = {'Apple': 70, 'Grape': 100, 'Banana': 80}\r\ncapitals = {'Россия': 'Москва', 'Франция': 'Париж'}\r\n\r\nprint(len(fruits))\r\nprint(len(capitals))\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\n3\r\n2\r\n</strong>\r\n</pre>\r\n\r\n<strong>Оператор принадлежности in</strong><br><br>\r\nОператор in позволяет проверить, содержит ли словарь заданный ключ. Оператор принадлежности in на словарях работает очень быстро, намного быстрее, чем на списках, поэтому если нужен многократный поиск в коллекции данных, словарь – подходящий выбор.\r\n\r\nРассмотрим код:\r\n<pre>\r\n<strong>\r\ncapitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}\r\n\r\nif 'Франция' in capitals:\r\n    print('Столица Франции - это', capitals['Франция'])\r\n</strong>\r\n</pre>\r\nТакой код проверяет, содержит ли словарь capitals элемент с ключом Франция и выводит соответствующий текст:  \r\n<pre>\r\n<strong>\r\nСтолица Франции - это Париж\r\n</strong>\r\n</pre>\r\n\r\n<strong>Встроенные функции sum(), min(), max()</strong><br><br>\r\nВстроенная функция sum() принимает в качестве аргумента словарь с числовыми ключами и вычисляет сумму его ключей. Для корректной работы функции sum() ключами словаря должны быть именно числа.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nmy_dict = {10: 'Россия', 20: 'США', 30: 'Франция'}\r\n\r\nprint('Сумма всех ключей словаря =', sum(my_dict))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nСумма всех ключей словаря = 60\r\n</strong>\r\n</pre>\r\nВстроенные функции min() и max() принимают в качестве аргумента словарь и находят минимальный и максимальный ключ соответственно, при этом ключ может принадлежать к любому типу данных, для которого возможны операции порядка <, <=, >, >= (числа, строки, и т.д.). \r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ncapitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}\r\nmonths = {1: 'Январь', 2: 'Февраль', 3: 'Март'}\r\n\r\nprint('Минимальный ключ =', min(capitals))\r\nprint('Максимальный ключ =', max(months))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nМинимальный ключ = Россия\r\nМаксимальный ключ = 3\r\n</strong>\r\n</pre>\r\n\r\n<strong>Сравнение словарей</strong><br><br>\r\nСловари можно сравнивать между собой. Равные словари имеют одинаковое количество элементов и содержат равные элементы (ключ: значение). Для сравнения словарей используются операторы == и !=.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nmonths1 = {1: 'Январь', 2: 'Февраль'}\r\nmonths2 = {1: 'Январь', 2: 'Февраль', 3: 'Март'}\r\nmonths3 = {3: 'Март', 1: 'Январь', 2: 'Февраль'}\r\n\r\nprint(months1 == months2)\r\nprint(months2 == months3)\r\nprint(months1 != months3)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nFalse\r\nTrue\r\nTrue\r\n</strong>\r\n</pre>\r\n\r\n<strong>Методы словарей</strong><br><br>\r\n<strong>Методы keys(), values(), items()</strong><br><br>\r\nСловарный <strong>метод keys()</strong> возвращает список ключей всех элементов словаря.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\ncapitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}\r\n\r\nfor key in capitals.keys():     # итерируем по списку ['Россия', 'Франция', 'Чехия']\r\n    print(key)\r\n</strong>\r\n</pre>\r\nвыводит (порядок элементов может отличаться):\r\n<pre>\r\n<strong>\r\nРоссия\r\nФранция\r\nЧехия\r\n</strong>\r\n</pre>\r\nСловарный <strong>метод values()</strong> возвращает список значений всех элементов словаря.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\ncapitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}\r\n\r\nfor value in capitals.values():     # итерируем по списку ['Москва', 'Париж', 'Прага']\r\n    print(value)\r\n</strong>\r\n</pre>\r\nвыводит (порядок элементов может отличаться):\r\n<pre>\r\n<strong>\r\nМосква\r\nПариж\r\nПрага\r\n</strong>\r\n</pre>\r\nСловарный <strong>метод items()</strong> возвращает список всех элементов словаря, состоящий из кортежей пар (ключ, значение).\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ncapitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}\r\n\r\nfor item in capitals.items():\r\n    print(item)\r\n</strong>\r\n</pre>\r\nвыводит (порядок элементов может отличаться):\r\n<pre>\r\n<strong>\r\n('Россия', 'Москва')\r\n('Франция', 'Париж')\r\n('Чехия', 'Прага')\r\n</strong>\r\n</pre>\r\nИспользуя магию распаковки кортежей, можно писать такой код:\r\n<pre>\r\n<strong>\r\ncapitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}\r\n\r\nfor key, value in capitals.items():\r\n    print(key, '-', value)\r\n</strong>\r\n</pre>\r\nПриведенный выше код выводит (порядок элементов может отличаться):\r\n<pre>\r\n<strong>\r\nРоссия - Москва\r\nФранция - Париж\r\nЧехия - Прага\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод get()</strong><br><br>\r\nМы можем получить значение в словаре по ключу с помощью индексации, то есть квадратных скобок. Однако, как мы знаем, в случае отсутствия ключа будет происходить ошибка KeyError. Для того чтобы избежать возникновения ошибки в случае отсутствия ключа в словаре, можно использовать метод get(), способный кроме ключа принимать и второй аргумент — значение, которое вернется, если заданного ключа нет. Когда второй аргумент не указан, то метод в случае отсутствия ключа возвращает None.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ninfo = {'name': 'Bob',\r\n        'age': 25,\r\n        'job': 'Dev'}\r\n\r\nprint(info['name'])\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nBob\r\n</strong>\r\n</pre>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ninfo = {'name': 'Bob',\r\n        'age': 25,\r\n        'job': 'Dev'}\r\n\r\nprint(info['salary'])\r\n</strong>\r\n</pre>\r\nприводит к возникновению ошибки:\r\n<pre>\r\n<strong>\r\nKeyError: 'salary'\r\n</strong>\r\n</pre>\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ninfo = {'name': 'Bob',\r\n        'age': 25,\r\n        'job': 'Dev'}\r\n\r\nitem1 = info.get('salary')\r\nitem2 = info.get('salary', 'Информации о зарплате нет')\r\n\r\nprint(item1)\r\nprint(item2)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nNone\r\nИнформации о зарплате нет\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод update()</strong><br><br>\r\n<strong>Метод update()</strong> реализует своеобразную операцию конкатенации для словарей. Он объединяет ключи и значения одного словаря с ключами и значениями другого. При совпадении ключей в итоге сохранится значение словаря, указанного в качестве аргумента метода update(). В Python 3.9 появились операторы | и |=, которые реализуют операцию конкатенации словарей.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ninfo1 = {'name': 'Bob',\r\n        'age': 25,\r\n        'job': 'Dev'}\r\n\r\ninfo2 = {'age': 30,\r\n        'city': 'New York',\r\n        'email': 'bob@web.com'}\r\n\r\ninfo1.update(info2)\r\n\r\nprint(info1)\r\n</strong>\r\n</pre>\r\nвыводит (порядок элементов может отличаться):\r\n<pre>\r\n<strong>\r\n{'name': 'Bob', 'age': 30, 'job': 'Dev', 'city': 'New York', 'email': 'bob@web.com'}\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод setdefault()</strong><br><br>\r\n<strong>Метод setdefault()</strong> позволяет получить значение из словаря по заданному ключу, автоматически добавляя элемент словаря, если он отсутствует.\r\n\r\nМетод принимает два аргумента:<br><br>\r\n\r\n <li>key: ключ, значение по которому следует получить, если таковое имеется в словаре, либо создать.</li>\r\n <li>default: значение, которое будет использовано при добавлении нового элемента в словарь.</li><br><br>\r\nВ зависимости от значений параметров key и default возможны следующие сценарии работы данного метода.<br><br>\r\n\r\n<strong>Сценарий 1</strong>. Если ключ key присутствует в словаре, то метод возвращает значение по заданному ключу (независимо от того, передан параметр default или нет).\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ninfo = {'name': 'Bob',\r\n        'age': 25}\r\n\r\nname1 = info.setdefault('name')           # параметр default не задан           \r\nname2 = info.setdefault('name', 'Max')    # параметр default задан\r\n\r\nprint(name1)\r\nprint(name2)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nBob\r\nBob\r\n</strong>\r\n</pre>\r\n<strong>Сценарий 2</strong>. Если ключ key отсутствует в словаре, то метод вставляет переданное значение default по заданному ключу.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ninfo = {'name': 'Bob',\r\n        'age': 25}\r\n\r\njob = info.setdefault('job', 'Dev')\r\nprint(info)\r\nprint(job)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n{'name': 'Bob', 'age': 25, 'job': 'Dev'}\r\nDev\r\n</strong>\r\n</pre>\r\nПри этом если значение default не передано в метод, то вставится значение None.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ninfo = {'name': 'Bob',\r\n        'age': 25}\r\n\r\njob = info.setdefault('job')\r\nprint(info)\r\nprint(job)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n{'name': 'Bob', 'age': 25, 'job': None}\r\nNone\r\n</strong>\r\n</pre>\r\n\r\n<strong>Оператор del</strong><br><br>\r\nС помощью оператора del можно удалять элементы словаря по определенному ключу. Если удаляемого ключа в словаре нет, возникнет ошибка KeyError.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\ninfo = {'name': 'Sam',\r\n        'age': 28,\r\n        'job': 'Teacher',\r\n        'email': 'timyr-guev@yandex.ru'}\r\n\r\ndel info['email']    # удаляем элемент имеющий ключ email\r\ndel info['job']      # удаляем элемент имеющий ключ job\r\n\r\nprint(info)\r\n</strong>\r\n</pre>\r\nвыводит (порядок элементов может отличаться):\r\n<pre>\r\n<strong>\r\n{'name': 'Sam', 'age': 28}\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод pop()</strong><br><br>\r\nОператор del удаляет из словаря элемент по заданному ключу вместе с его значением. Если требуется получить само значение удаляемого элемента, то нужен метод pop().   \r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\ninfo = {'name': 'Sam',\r\n        'age': 28,\r\n        'job': 'Teacher',\r\n        'email': 'timyr-guev@yandex.ru'}\r\n\r\nemail = info.pop('email')          # удаляем элемент по ключу email, возвращая его значение\r\njob = info.pop('job')              # удаляем элемент по ключу job, возвращая его значение\r\n\r\nprint(email)\r\nprint(job)\r\nprint(info)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\ntimyr-guev@yandex.ru\r\nTeacher\r\n{'name': 'Sam', 'age': 28}\r\n</strong>\r\n</pre>\r\nЕдинственное отличие этого способа удаления от оператора del — он возвращает удаленное значение. В остальном этот способ идентичен оператору del. В частности, если удаляемого ключа в словаре нет, возникнет ошибка KeyError.\r\n\r\n​Чтобы ошибка не появлялась, этому методу можно передать второй аргумент. Он будет возвращен, если указанного ключа в словаре нет. Это позволяет реализовать безопасное удаление элемента из словаря:\r\n<pre>\r\n<strong>\r\nsurname = info.pop('surname', None) \r\n</strong>\r\n</pre>\r\nЕсли ключа surname в словаре нет, то в переменной surname будет храниться значение None.<br><br>\r\n\r\n<strong>Метод popitem()</strong><br><br>\r\nМетод popitem() удаляет из словаря последний добавленный элемент и возвращает удаляемый элемент в виде кортежа (ключ, значение). В версиях Python ниже 3.6 метод popitem() удалял случайный элемент.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\ninfo = {'name': 'Bob',\r\n     'age': 25,\r\n     'job': 'Dev'}\r\n\r\ninfo['surname'] = 'Sinclar'\r\n\r\nitem = info.popitem()\r\n\r\nprint(item)\r\nprint(info)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n('surname', 'Sinclar')\r\n{'name': 'Bob', 'age': 25, 'job': 'Dev'}\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод clear()</strong><br><br>\r\nМетод clear() удаляет все элементы из словаря.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\ninfo = {'name': 'Bob',\r\n        'age': 25,\r\n        'job': 'Dev'}\r\n\r\ninfo.clear()\r\n\r\nprint(info)\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\n{}\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод copy()</strong><br><br>\r\nМетод copy() создает поверхностную копию словаря.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\ninfo = {'name': 'Bob',\r\n        'age': 25,\r\n        'job': 'Dev'}\r\n\r\ninfo_copy = info.copy()\r\n\r\nprint(info_copy)\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\n{'name': 'Bob', 'age': 25, 'job': 'Dev'}\r\n</strong>\r\n</pre>\r\n\r\n<strong>Генераторы словарей</strong><br><br>\r\nПусть требуется создать словарь, ключами которого будут числа от 0 до 5, а значениями – квадраты ключей.\r\n<pre>\r\n<strong>\r\nsquares = {i: i**2 for i in range(6)}\r\n</strong>\r\n</pre>\r\nОбщий вид генератора словаря следующий:\r\n<pre>\r\n<strong>\r\n{ключ: значение for переменная in последовательность}\r\n</strong>\r\n</pre>\r\nгде переменная — имя некоторой переменной, последовательность — последовательность значений, которые она принимает (любой итерируемый объект), ключ: значение — некоторое выражение, как правило, зависящее от использованной в списочном выражении переменной, которой будут заполнены элементы словаря.",
    "slug": "dictionary-data-type"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 13,
  "fields": {
    "lesson": "Множества",
    "content": "<strong>Множества</strong><br><br>\r\nМножество – структура данных, организованная так же, как математические множества.<br><br>\r\n<li>все элементы множества различны (уникальны), два элемента не могут иметь одинаковое значение;</li>\r\n<li>множества неупорядочены, то есть элементы не хранятся в каком-то определенном порядке;</li>\r\n<li>элементы множества должны относиться к неизменяемым типам данных;</li>\r\n<li>хранящиеся в множестве элементы могут иметь разные типы данных.</li>\r\n<li>Индексация и срезы недоступны для множеств.</li>\r\n<li>Операция конкатенации + и умножения на число * недоступны для множеств.</li><br><br>\r\n\r\n<strong>Создание множества</strong><br><br>\r\nЧтобы создать множество, нужно перечислить его элементы через запятую в фигурных скобках:\r\n<pre>\r\n<strong>\r\nnumbers = {2, 4, 6, 8, 10}\r\nlanguages = {\"Python\", \"C#\", \"C++\", \"Java\"}\r\n</strong>\r\n</pre>\r\nМножество numbers состоит из 5 элементов, и каждый из них — целое число.<br>\r\n\r\nМножество languages состоит из 4 элементов, каждый из которых — строка.<br>\r\n\r\nМножества могут содержать значения разных типов данных:\r\n<pre>\r\n<strong>\r\ninfo = {'Timur', 1992, 61.5}\r\n</strong>\r\n</pre>\r\nМножество info содержит строковое значение, целое число и число с плавающей точкой.<br><br>\r\n\r\n<strong>Пустое множество</strong><br><br>\r\nСоздать пустое множество можно с помощью встроенной функции, которая называется set():\r\n<pre>\r\n<strong>\r\nmyset = set()  # пустое множество\r\n</strong>\r\n</pre>\r\nОбратите внимание — создать пустое множество с помощью пустых фигурных скобок нельзя:\r\n<pre>\r\n<strong>\r\nmyset = {}  # создается словарь\r\n</strong>\r\n</pre>\r\nС помощью пустых фигурных скобок создаются словари: так сложилось исторически. Дело в том, что словари появились в Python раньше, чем множества.<br><br>\r\n\r\n<strong>Встроенная функция set()</strong><br><br>\r\nВстроенная <strong>функция set()</strong> помимо создания пустого множества может преобразовывать некоторые типы объектов в множества.<br><br>\r\n\r\nВ функцию set() можно передать один аргумент. Передаваемый аргумент должен быть итерируемым объектом, таким как список, кортеж или строковое значение. Отдельные элементы объекта, передаваемого в качестве аргумента, становятся элементами множества:\r\n<pre>\r\n<strong>\r\nmyset1 = set(range(10))          # множество из элементов последовательности\r\nmyset2 = set([1, 2, 3, 4, 5])    # множество из элементов списка\r\nmyset3 = set('abcd')             # множество из элементов строки\r\nmyset4 = set((10, 20, 30, 40))   # множество из элементов кортежа\r\n</strong>\r\n</pre>\r\nПустое множество также можно создать передав функции set() в качестве аргумента пустой список, строку или кортеж:\r\n<pre>\r\n<strong>\r\nemptyset1 = set([])  # пустое множество из пустого списка\r\nemptyset2 = set('')  # пустое множество из пустой строки\r\nemptyset3 = set(())  # пустое множество из пустого кортежа\r\n</strong>\r\n</pre>\r\n\r\n<strong>Дубликаты при создании множеств</strong><br><br>\r\nМножества не могут содержать повторяющиеся элементы. Если в функцию set() передать аргумент, содержащий повторяющиеся элементы, то в множестве появится только один из этих повторяющихся элементов.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nmyset1 = {2, 2, 4, 6, 6}\r\nmyset2 = set([1, 2, 2, 3, 3])\r\nmyset3 = set(\"aaaaabbbbccccddd\")\r\n\r\nprint(myset1)\r\nprint(myset2)\r\nprint(myset3)\r\n</strong>\r\n</pre>\r\nвыводит (порядок элементов может отличаться):\r\n<pre>\r\n<strong>\r\n{2, 4, 6}\r\n{1, 2, 3}\r\n{\"b\", \"c\", \"d\", \"a\"}\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция len()</strong><br><br>\r\nДлиной множества называется количество его элементов. Чтобы посчитать длину множества, используют встроенную функцию len() (от слова length – длина).\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nmyset1 = {2, 2, 4, 6, 6}\r\nmyset2 = set([1, 2, 2, 3, 3, 4, 4, 5, 5])\r\nmyset3 = set('aaaaabbbbccccddd')\r\n\r\nprint(len(myset1))\r\nprint(len(myset2))\r\nprint(len(myset3))\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\n3\r\n5\r\n4\r\n</strong>\r\n</pre>\r\n\r\n<strong>Оператор принадлежности in</strong><br><br>\r\nОператор in позволяет проверить, содержит ли множество некоторый элемент. Оператор принадлежности in работает очень быстро на множествах – намного быстрее, чем на списках. Поэтому если требуется часто осуществлять поиск в коллекции уникальных данных, то множество – подходящий выбор.\r\n\r\nРассмотрим следующий код:\r\n<pre>\r\n<strong>\r\nnumbers = {2, 4, 6, 8, 10}\r\n\r\nif 2 in numbers:\r\n    print('Множество numbers содержит число 2')\r\nelse:\r\n    print('Множество numbers не содержит число 2')\r\n</strong>\r\n</pre>\r\nТакой код проверяет, содержит ли множество numbers число 2 и выводит соответствующий текст:\r\n<pre>\r\n<strong>\r\nМножество numbers содержит число 2\r\n</strong>\r\n</pre>\r\n\r\n<strong>Встроенные функции sum(), min(), max()</strong><br><br>\r\nВстроенная <strong>функция sum()</strong> принимает в качестве аргумента множество чисел и вычисляет сумму его элементов.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nnumbers = {2, 2, 4, 6, 6}\r\nprint('Сумма всех элементов множества =', sum(numbers))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nСумма всех элементов множества = 12\r\n</strong>\r\n</pre>\r\nВстроенные <strong>функции min() и max()</strong> принимают в качестве аргумента множество и находят минимальный и максимальный элементы соответственно.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nnumbers = {2, 2, 4, 6, 6}\r\nprint('Минимальный элемент =', min(numbers))\r\nprint('Максимальный элемент =', max(numbers))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nМинимальный элемент = 2\r\nМаксимальный элемент = 6\r\n</strong>\r\n</pre>\r\n\r\n<strong>Сравнение множеств</strong><br><br>\r\nМножества можно сравнивать между собой. Равные множества имеют одинаковую длину и содержат равные элементы. Для сравнения множеств используются операторы == и !=.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nmyset1 = {1, 2, 3, 3, 3, 3}\r\nmyset2 = {2, 1, 3}\r\nmyset3 = {1, 2, 3, 4}\r\n\r\nprint(myset1 == myset2)\r\nprint(myset1 == myset3)\r\nprint(myset1 != myset3)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTrue\r\nFalse\r\nTrue\r\n</strong>\r\n</pre>\r\n\r\n<strong>Методы множеств</strong><br><br>\r\n<strong>Метод add()</strong><br><br>\r\nДля добавления нового элемента в множество используется метод add(). Не забывайте, что порядок элементов при выводе множества абсолютно произвольный. Обратите внимание, для использования метода add() требуется предварительно созданное множество, при этом оно может быть пустым.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nnumbers = {1, 1, 2, 3, 5, 8, 3}  # создаем множество\r\n\r\nnumbers.add(21)  # добавляем число 21 в множество\r\nnumbers.add(34)  # добавляем число 34 в множество\r\n\r\nprint(numbers)\r\n</strong>\r\n</pre>\r\nвыводит (порядок элементов может отличаться):\r\n<pre>\r\n<strong>\r\n{1, 2, 3, 34, 5, 8, 21}\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод remove()</strong><br><br>\r\n<strong>Метод remove()</strong> удаляет элемент из множества с генерацией исключения (ошибки) в случае, если такого элемента нет.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nnumbers = {1, 2, 3, 4, 5}\r\n\r\nnumbers.remove(3)\r\nprint(numbers)\r\n</strong>\r\n</pre>\r\nвыводит (порядок элементов может отличаться):\r\n<pre>\r\n<strong>\r\n{1, 2, 4, 5}\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод discard()</strong><br><br>\r\n<strong>Метод discard()</strong> удаляет элемент из множества без генерации исключения (ошибки), если элемент отсутствует.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nnumbers = {1, 2, 3, 4, 5}\r\n\r\nnumbers.discard(3)\r\nprint(numbers)\r\n</strong>\r\n</pre>\r\nвыводит (порядок элементов может отличаться):\r\n<pre>\r\n<strong>\r\n{1, 2, 4, 5}\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод pop()</strong><br><br>\r\n<strong>Метод pop()</strong> удаляет и возвращает случайный элемент из множества с генерацией исключения (ошибки) при попытке удаления из пустого множества. Метод pop() можно воспринимать как неконтролируемый способ удаления элементов по одному из множества.\r\n\r\nРассмотрим программный код:\r\n<pre>\r\n<strong>\r\nnumbers = {1, 2, 3, 4, 5}\r\n\r\nprint('до удаления:', numbers)\r\n\r\nnum = numbers.pop()                 # удаляет случайный элемент множества, возвращая его\r\n\r\nprint('удалённый элемент:', num)\r\n\r\nprint('после удаления:', numbers)\r\n</strong>\r\n</pre>\r\nРезультат работы такого кода случаен, например, такой код может вывести:\r\n<pre>\r\n<strong>\r\nдо удаления: {1, 2, 3, 4, 5}\r\nудалённый элемент: 1\r\nпосле удаления: {2, 3, 4, 5}\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод clear()</strong><br><br>\r\n<strong>Метод clear()</strong> удаляет все элементы из множества. Обратите внимание на то, что пустое множество выводится как set(), а не как {}. С помощью {} выводится пустой словарь.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nnumbers = {1, 2, 3, 4, 5}\r\nnumbers.clear()\r\n\r\nprint(numbers)\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\nset()\r\n</strong>\r\n</pre>\r\nВ результате получили пустое множество.<br><br>\r\n\r\n<strong>Объединение множеств: метод union()</strong><br><br>\r\n<strong>Объединение множеств</strong> – это множество, состоящее из элементов, принадлежащих хотя бы одному из объединяемых множеств. Для этой операции существует метод union(). ​Обратите внимание, метод union() возвращает новое множество в которое входят все элементы множеств myset1 и myset2. Для изменения текущего множества используется <strong>метод update()</strong>.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nmyset1 = {1, 2, 3, 4, 5}\r\nmyset2 = {3, 4, 6, 7, 8}\r\n\r\nmyset3 = myset1.union(myset2)\r\nprint(myset3)\r\n</strong>\r\n</pre>\r\nвыводит (порядок элементов может отличаться):\r\n<pre>\r\n<strong>\r\n{1, 2, 3, 4, 5, 6, 7, 8}\r\n</strong>\r\n</pre>\r\nДля объединения двух множеств можно также использовать оператор |.<br><br>\r\n\r\n<strong>Пересечение множеств: метод intersection()</strong><br><br>\r\nПересечение множеств – это множество, состоящее из элементов, принадлежащих одновременно каждому из пересекающихся множеств. Для этой операции существует метод intersection(). ​Обратите внимание, метод intersection() возвращает новое множество в которое входят общие элементы множеств myset1 и myset2. Для изменения текущего множества используется <strong>метод intersection_update()</strong>.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nmyset1 = {1, 2, 3, 4, 5}\r\nmyset2 = {3, 4, 6, 7, 8}\r\n\r\nmyset3 = myset1.intersection(myset2)\r\nprint(myset3)\r\n</strong>\r\n</pre>\r\nвыводит (порядок элементов может отличаться):\r\n<pre>\r\n<strong>\r\n{3, 4}\r\n</strong>\r\n</pre>\r\nДля пересечения двух множеств можно также использовать оператор &.<br><br>\r\n\r\n<strong>Разность множеств: метод difference()</strong><br><br>\r\n<strong>Разность множеств</strong> – это множество, в которое входят все элементы первого множества, не входящие во второе множество. Для этой операции существует метод difference(). <strong>Метод difference_update()</strong> изменяет исходное множество по разности. Обратите внимание: для операции разности множеств важен порядок, в котором указаны множества. Если поменять местами myset1 и myset2, нас ожидает совсем другой результат: элементы, входящие в множество myset2 и которых нет в множестве myset1. \r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nmyset1 = {1, 2, 3, 4, 5}\r\nmyset2 = {3, 4, 6, 7, 8}\r\n\r\nmyset3 = myset1.difference(myset2)\r\nprint(myset3)\r\n</strong>\r\n</pre>\r\nвыводит (порядок элементов может отличаться):\r\n<pre>\r\n<strong>\r\n{1, 2, 5}\r\n</strong>\r\n</pre>\r\nДля разности двух множеств можно также использовать оператор -.<br><br>\r\n\r\n<strong>Симметрическая разность: метод symmetric_difference()</strong><br><br>\r\n<strong>Симметрическая разность множеств</strong> – это множество, включающее все элементы исходных множеств, не принадлежащие одновременно обоим исходным множествам. Для этой операции существует метод symmetric_difference().\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nmyset1 = {1, 2, 3, 4, 5}\r\nmyset2 = {3, 4, 6, 7, 8}\r\n\r\nmyset3 = myset1.symmetric_difference(myset2)\r\nprint(myset3)\r\n</strong>\r\n</pre>\r\nвыводит (порядок элементов может отличаться):\r\n<pre>\r\n<strong>\r\n{1, 2, 5, 6, 7, 8}\r\n</strong>\r\n</pre>\r\nДля симметрической разности двух множеств можно также использовать оператор ^.<br><br>\r\n\r\n<strong>Метод issubset()</strong><br><br>\r\nДля определения, является ли одно из множеств подмножеством другого, используется <strong>метод issubset()</strong>. Данный метод возвращает значение True, если одно множество является подмножеством другого, и False, если не является.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nset1 = {2, 3}\r\nset2 = {1, 2, 3, 4, 5, 6}\r\n\r\nprint(set1.issubset(set2))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTrue\r\n</strong>\r\n</pre>\r\nВ этом примере set2 содержит все элементы set1. Это означает, что set1 – подмно­жество set2. Это также означает, что set2 – надмножество set1.<br><br>\r\n\r\nДля определения, является ли одно из множеств подмножеством другого, также применяются операторы <= (нестрогое подмножество) и < (строгое подмножество).\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nset1 = {2, 3}\r\nset2 = {1, 2, 3, 4, 5, 6}\r\n\r\nprint(set1 <= set2)\r\n</strong>\r\n</pre>\r\nаналогичен предыдущему.<br><br>\r\n\r\n<strong>Метод issuperset()</strong><br><br>\r\nДля определения, является ли одно из множеств надмножеством другого, используется <strong>метод issuperset()</strong>. Данный метод возвращает значение True, если одно множество является надмножеством другого, в противном случае он возвращает False.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nset1 = {'a', 'b', 'c', 'd', 'e'}\r\nset2 = {'c', 'e'}\r\n\r\nprint(set1.issuperset(set2))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTrue\r\n</strong>\r\n</pre>\r\nВ этом примере set1 содержит все элементы set2. Это означает, что set1 – надмно­жество set2. Это также означает, что set2 – подмножество set1.<br><br>\r\n\r\nДля определения, является ли одно из множеств надмножеством другого, также применяются операторы >= (нестрогое надмножество) и > (строгое надмножество).\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nset1 = {'a', 'b', 'c', 'd', 'e'}\r\nset2 = {'c', 'e'}\r\n\r\nprint(set1 >= set2)\r\n</strong>\r\n</pre>\r\nаналогичен предыдущему.<br><br>\r\n\r\n<strong>Метод isdisjoint()</strong><br><br>\r\nДля определения отсутствия общих элементов в множествах используется <strong>метод isdisjoint()</strong>. Данный метод возвращает значение True, если множества не имеют общих элементов, и  False, когда множества имеют общие элементы.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nset1 = {1, 2, 3, 4, 5}\r\nset2 = {5, 6, 7}\r\nset3 = {7, 8, 9}\r\n\r\nprint(set1.isdisjoint(set2))\r\nprint(set1.isdisjoint(set3))\r\nprint(set2.isdisjoint(set3))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nFalse\r\nTrue\r\nFalse\r\n</strong>\r\n</pre>\r\n\r\nМетоды issuperset(), issubset(), isdisjoint() могут принимать в качестве аргумента не только множество (тип данных set), но и любой итерируемый объект (список, строку, кортеж...). Сами же эти методы могут применяться только ко множеству (тип данных set) или замороженному множеству (тип данных frozenset).<br><br>\r\n\r\n<strong>Генераторы множеств</strong><br><br>\r\nПусть требуется создать множество, содержащее цифры введенного числа:\r\n<pre>\r\n<strong>\r\ndigits = {int(c) for c in input()}\r\n</strong>\r\n</pre>\r\nОбщий вид генератора множеств следующий:\r\n<pre>\r\n<strong>\r\n{выражение for переменная in последовательность},\r\n</strong>\r\n</pre>\r\nгде  выражение — некоторое выражение, как правило, зависящее от использованной в списочном выражении переменной, которым будут заполнены элементы множества переменная — имя некоторой переменной, последовательность — последовательность значений, которые она принимает (любой итерируемый объект).",
    "slug": "set-data-type"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 14,
  "fields": {
    "lesson": "Кортежи",
    "content": "<strong>Кортежи</strong><br><br>\r\n<strong>Кортеж</strong>  — это неизменяемый тип данных в Python, который представляет собой последовательность элементов, разделенных запятыми и заключенных в скобки. Кортежи похожи на списки, но они не могут быть изменены после создания. Это делает кортежи быстрее и более безопасными для многопоточного использования, чем списки. Кортежи полезны, когда вам нужно сохранить группу связанных данных, которые не должны изменяться.<br><br>\r\n\r\nСписки могут делать то же, что кортежи, и даже больше. Но неизменяемость кортежей обеспечивает им особые свойства:<br><br>\r\n\r\n<li>скорость – кортежи быстрее работают, так как из-за неизменяемости хранятся в памяти иначе, и операции с их элементами выполняются заведомо быстрее, чем с компонентами списка. Одна из причин существования кортежей  – производительность. Обработка кортежа выполняется быстрее, чем обработка списка, поэтому кортежи удобны для обработки большого объема неизменяемых данных.</li>\r\n<li>безопасность – неизменяемость превращает их в идеальные константы. Заданные кортежами константы делают код более читаемым и безопасным. Кроме того, в кортеже можно безопасно хранить данные, не опасаясь, что они будут случайно или преднамеренно изменены в программе.</li><br><br>\r\n\r\n<strong>Особенности кортежей</strong><br><br>\r\nКортежи поддерживают те же операции, что и списки, за исключением изменяющих содержимое.<br><br>\r\n\r\nКортежи поддерживают:<br><br>\r\n\r\n<li>доступ к элементу по индексу (только для получения значений элементов);</li>\r\n<li>методы, в частности index(), count();</li>\r\n<li>встроенные функции, в частности len(), sum(), min() и max();</li>\r\n<li>срезы;</li>\r\n<li>оператор принадлежности in;</li>\r\n<li>операторы конкатенации (+) и повторения (*).</li><br><br>\r\n\r\n<strong>Кортеж с одним элементом</strong><br><br>\r\nДля создания кортежа с единственным элементом после значения элемента ставят замыкающую запятую:\r\n<pre>\r\n<strong>\r\nmy_tuple = (1,)\r\nprint(type(my_tuple))  # <class 'tuple'>\r\n</strong>\r\n</pre>\r\nЕсли запятую пропустить, то кортеж создан не будет. Например, приведенный ниже код просто присваивает переменной my_tuple целочисленное значение 1:\r\n<pre>\r\n<strong>\r\nmy_tuple = (1)\r\nprint(type(my_tuple))  # <class 'int'>\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция tuple()</strong><br><br>\r\nВстроенная <strong>функция list()</strong> может применяться для преобразования кортежа в список.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnumber_tuple = (1, 2, 3, 4, 5)\r\nnumber_list = list(number_tuple)\r\nprint(number_list)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n[1, 2, 3, 4, 5]\r\n</strong>\r\n</pre>\r\nВстроенная <strong>функция tuple()</strong>  может применяться для преобразования списка в кортеж.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nstr_list = ['один', 'два', 'три']\r\nstr_tuple = tuple(str_list)\r\nprint(str_tuple)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n('один', 'два', 'три')\r\n</strong>\r\n</pre>\r\nАналогичным образом мы можем создать кортеж на основании строки.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ntext = 'hello python'\r\nstr_tuple = tuple(text)\r\nprint(str_tuple)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n('h', 'e', 'l', 'l', 'o', ' ', 'p', 'y', 't', 'h', 'o', 'n')\r\n</strong>\r\n</pre>\r\nОбратите внимание, что символ пробела содержится в кортеже str_tuple.<br><br>\r\n\r\n<strong>Сравнение кортежей</strong><br><br>\r\nКортежи можно сравнивать между собой.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint((1, 8) == (1, 8))\r\nprint((1, 8) != (1, 10))\r\nprint((1, 9) < (1, 2))\r\nprint((2, 5) < (6,))\r\nprint(('a', 'bc') > ('a', 'de'))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTrue\r\nTrue\r\nFalse\r\nTrue\r\nFalse\r\n</strong>\r\n</pre>\r\nОбратите внимание: операции == и != применимы к любым кортежам, независимо от типов элементов. А вот операции <, >, <=, >= применимы только в том случае, когда соответствующие элементы кортежей имеют один тип.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint((7, 5) < ('java', 'python'))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTypeError: '<' not supported between instances of 'int' and 'str'\r\n</strong>\r\n</pre>\r\nСравнение кортежей происходит последовательно элемент за элементом, а если элементы равны — просматривается следующий элемент.<br><br>\r\n\r\n<strong>Сортировка кортежей</strong><br><br>\r\nКак мы помним, списки имеют метод sort(), который осуществляет сортировку на месте, то есть меняет порядок исходного списка. Поскольку кортежи по своей природе неизменяемы, то встроенного метода sort() они не содержат, тем не менее с помощью встроенной функции sorted() (не путать с списочным методом sort()) мы можем сортировать значения в кортежах.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnot_sorted_tuple = (34, 1, 8, 67, 5, 9, 0, 23)\r\nprint(not_sorted_tuple)\r\n\r\nsorted_tuple = tuple(sorted(not_sorted_tuple))\r\nprint(sorted_tuple)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n(34, 1, 8, 67, 5, 9, 0, 23)\r\n(0, 1, 5, 8, 9, 23, 34, 67)\r\n</strong>\r\n</pre>\r\nОбратите внимание, что функция sorted() возвращает список, но с помощью функции tuple() мы приводим результат сортировки к кортежу.<br><br>\r\n\r\n<strong>Упаковка кортежей</strong><br><br>\r\nУпаковкой кортежа называют присваивание его какой-либо переменной.<br><br>\r\n\r\nПриведенный ниже код автоматически запакует 1, 2, 3 и 'b', в кортежи (1, 2, 3) и ('b', ) и присвоит их значения переменным tuple1 и tuple2:\r\n<pre>\r\n<strong>\r\ntuple1 = 1, 2, 3\r\ntuple2 = 'b',\r\n\r\nprint(type(tuple1))\r\nprint(type(tuple2))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nclass 'tuple'\r\nclass 'tuple'\r\n</strong>\r\n</pre>\r\n\r\n<strong>Распаковка кортежей</strong><br><br>\r\nОбратная операция, смысл которой в том, чтобы присвоить значения элементов кортежа отдельным переменным, называется распаковкой кортежа.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ncolors = ('red', 'green', 'blue', 'cyan')\r\n\r\n(a, b, c, d) = colors\r\n\r\nprint(a)\r\nprint(b)\r\nprint(c)\r\nprint(d)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nred\r\ngreen\r\nblue\r\ncyan\r\n</strong>\r\n</pre>\r\n\r\nМы можем опустить скобки слева от знака равенства:\r\n<pre>\r\n<strong>\r\ncolors = ('red', 'green', 'blue', 'cyan')\r\na, b, c, d = colors\r\n</strong>\r\n</pre>\r\nКоличество переменных должно совпадать с числом элементов в кортеже.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ncolors = ('red', 'green', 'blue', 'cyan')\r\na, b = colors\r\n</strong>\r\n</pre>\r\nприводит к ошибке:\r\n<pre>\r\n<strong>\r\nValueError: too many values to unpack\r\n</strong>\r\n</pre>\r\nАналогично, приведенный ниже код: \r\n<pre>\r\n<strong>\r\ncolors = ('red', 'green', 'blue')\r\na, b, c, d = colors\r\n</strong>\r\n</pre>\r\nприводит к ошибке:\r\n<pre>\r\n<strong>\r\nValueError: not enough values to unpack (expected 4, got 3)\r\n</strong>\r\n</pre>\r\nОднако, если необходимо получить лишь какие-то отдельные значения, то в качестве \"ненужных\" переменных позволено использовать символ нижнего подчеркивания _.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ncolors = ('red', 'green', 'blue')\r\na, b, _ = colors\r\n\r\nprint(a)\r\nprint(b)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nred\r\ngreen\r\n</strong>\r\n</pre>\r\nРаспаковка кортежей очень удобна на практике. По сути мы использовали ее, когда меняли местами значения двух переменных без использования временных переменных.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\na = 7\r\nb = 17\r\na, b = b, a\r\n\r\nprint(a, b)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n17 7\r\n</strong>\r\n</pre>\r\nСначала вычисляются все значения справа, и лишь затем они кладутся в левую часть оператора присваивания. Поэтому можно менять местами значения переменных a и b, написав: a, b = b, a.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\na, b, c = 3, 2, 1\r\nb, a, c = c, a, b\r\n\r\nprint(b, c, a)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n1 2 3\r\n</strong>\r\n</pre>\r\n\r\n<strong>* при распаковке кортежей</strong><br><br>\r\nКак мы знаем, если при распаковке кортежа число элементов слева и справа не совпадает, то возникает ошибка времени исполнения. Есть способ собрать сразу несколько значений в одну переменную. Это делается при помощи звездочки перед именем переменной.\r\n\r\nРассмотрим программный код:\r\n<pre>\r\n<strong>\r\na, b, *tail = 1, 2, 3, 4, 5, 6\r\n</strong>\r\n</pre>\r\nВ этом случае в переменной a будет записана единица, в переменной b — двойка, а в переменной tail — список, состоящий из всех аргументов, которые не попали в предыдущие переменные. В данном случае tail будет равен [3, 4, 5, 6].\r\n\r\nУчтите, что tail всегда будет списком, даже когда в него попадает лишь один элемент или даже ноль.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\na, b, *tail = 1, 2, 3\r\n\r\nprint(tail)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n[3]\r\n</strong>\r\n</pre>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\na, b, *tail = 1, 2\r\n\r\nprint(tail)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n[]\r\n</strong>\r\n</pre>\r\nЗвездочка может быть только у одного аргумента, но необязательно у последнего.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\n*names, surname = ('Стефани', 'Джоанн', 'Анджелина', 'Джерманотта')\r\n\r\nprint(names)\r\nprint(surname)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n['Стефани', 'Джоанн', 'Анджелина']\r\nДжерманотта\r\n</strong>\r\n</pre>\r\nАргумент со звездочкой может стоять и посередине.\r\n<pre>\r\n<strong>\r\nsinger = ('Freddie', 'Bohemian Rhapsody', 'Killer Queen', 'Love of my life', 'Mercury')\r\n\r\nname, *songs, surname = singer\r\n\r\nprint(name)\r\nprint(songs)\r\nprint(surname)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nFreddie\r\n['Bohemian Rhapsody', 'Killer Queen', 'Love of my life']\r\nMercury\r\n</strong>\r\n</pre>\r\n\r\nЕсли вы хотите распаковать единственное значение в кортеже, после имени переменной должна идти запятая.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\na = 1,      # не распаковка, а просто присвоение\r\nb, = 1,     # распаковка\r\n\r\nprint(a)\r\nprint(b)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n(1,)\r\n1\r\n</strong>\r\n</pre>\r\nРаспаковывать можно не только кортеж, правая сторона может быть любой последовательностью (кортеж, строка или список).\r\n<pre>\r\n<strong>\r\ninfo = ['timur', 'beegeek.org']\r\nuser, domain = info    # распаковка списка\r\n\r\nprint(user)\r\nprint(domain)\r\n\r\na, b, c, d = 'math'    # распаковка строки\r\n\r\nprint(a)\r\nprint(b)\r\nprint(c)\r\nprint(d)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\ntimur\r\nbeegeek.org\r\nm\r\na\r\nt\r\nh\r\n</strong>\r\n</pre>",
    "slug": "tuple-data-type"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 15,
  "fields": {
    "lesson": "NoneType",
    "content": "<strong>Пустое значение</strong><br><br>\r\nВо многих языках программирования (Java, C++, C#, JavaScript и т.д.) существует ключевое слово null, которое можно присвоить переменным. Концепция ключевого слова null заключается в том, что оно дает переменной нейтральное или \"нулевое\" поведение.<br><br>\r\n\r\nВ языке Python, слово null заменено на None, поскольку слово null звучит не очень дружелюбно, а None относится именно к требуемой функциональности – это ничего и не имеет поведения.<br><br>\r\n\r\n<strong>Литерал None</strong><br><br>\r\nЛитерал None в Python позволяет представить null переменную, то есть переменную, которая не содержит какого-либо значения. Другими словами, None – это специальная константа, означающая пустоту. Если более точно, то None – это объект специального типа данных NoneType.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nvar = None\r\nprint(type(var))\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\nclass 'NoneType'\r\n</strong>\r\n</pre>\r\nМы можем присвоить значение None любой переменной, однако мы не можем самостоятельно создать другой NoneType объект.<br><br>\r\n\r\nВсе переменные, которым присвоено значение None, ссылаются на один и тот же объект типа NoneType. Создание собственных экземпляров типа NoneType недопустимо. Объекты, существующие в единственном экземпляре, называются синглтонами.<br><br>\r\n\r\n<strong>Проверка на None</strong><br><br>\r\nДля того чтобы проверить значение переменной на None, мы используем либо оператор is, либо оператор проверки на равенство ==.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nvar = None\r\nif var is None:  # используем оператор is\r\n  print('None')\r\nelse:\r\n  print('Not None')\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\nNone\r\n</strong>\r\n</pre>\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nvar = None\r\nif var == None:  # используем оператор ==\r\n  print('None')\r\nelse:\r\n  print('Not None')\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\nNone\r\n</strong>\r\n</pre>\r\nДля сравнения переменной с None всегда используйте оператор is. Для встроенных типов поведение is и == абсолютно одинаково, однако с пользовательскими типами могут возникнуть проблемы, так как в Python есть возможность переопределения операторов сравнения в пользовательских типах.<br><br>\r\n\r\n<strong>Сравнение None с другими типами данных</strong><br><br>\r\nСравнение None с любым объектом, отличным от None, дает значение False.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nprint(None == None)\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\nTrue\r\n</strong>\r\n</pre>\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nprint(None == 17)\r\nprint(None == 3.14)\r\nprint(None == True)\r\nprint(None == [1, 2, 3])\r\nprint(None == 'Beegeek')\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\nFalse\r\nFalse\r\nFalse\r\nFalse\r\nFalse\r\n</strong>\r\n</pre>\r\nВажно понимать, что следующий программный код:\r\n<pre>\r\n<strong>\r\nprint(None == 0)\r\nprint(None == False)\r\nprint(None == '')\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\nFalse\r\nFalse\r\nFalse\r\n</strong>\r\n</pre>\r\nЗначение None не отождествляется со значениями 0, False, ''.\r\n\r\nСравнивать None с другими типами данных можно только на равенство.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nprint(None > 0)\r\nprint(None <= False)\r\n</strong>\r\n</pre>\r\nприводит к ошибке:\r\n<pre>\r\n<strong>\r\nTypeError: '>' not supported between instances of 'NoneType' and 'int' ('bool')\r\n</strong>\r\n</pre>",
    "slug": "nonetype-data-type"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 16,
  "fields": {
    "lesson": "Bool",
    "content": "<strong>Логический тип данных в Python</strong><br><br>\r\nЛогические значения True (истина) и False (ложь) представляют тип данных bool. У этого типа только два возможных значения и два соответствующих литерала: True и False.<br><br>\r\n\r\nРезультатом логического выражения b > a является булево значение, в данном примере False, так как значение в переменной b меньше значения в переменной a.<br><br>\r\n\r\nЛогические выражения можно использовать не только в условном операторе.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nprint(17 > 7)\r\nprint(17 == 7)\r\nprint(17 < 7)\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\nTrue\r\nFalse\r\nFalse\r\n</strong>\r\n</pre>\r\n\r\n<strong>Логические операторы в Python</strong><br><br>\r\nДля создания произвольно сложных логических выражений (условий) мы используем три логические операции:<br><br>\r\n\r\n<li>и (and);</li>\r\n<li>или (or);</li>\r\n<li>не (not).</li><br><br>\r\nЛогические операции используют операнды со значениями True и False и возвращают результат также с логическими значениями. Определённые для объектов типа bool операторы (and, or, not) известны как логические операторы и имеют общеизвестные определения:<br><br>\r\n\r\n<li>a and b даёт True, если оба операнда True, и False, если хотя бы один из них False;</li>\r\n<li>a or b даёт False, если оба операнда False, и True, если хотя бы один из них True;</li>\r\n<li>not a даёт True, если a имеет значение False, и False, если a имеет значение True.</li><br><br>\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\na = True\r\nb = False\r\n\r\nprint('a and b is', a and b)\r\nprint('a or b is', a or b)\r\nprint('not a is', not a)\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\na and b is False\r\na or b is True\r\nnot a is False\r\n</strong>\r\n</pre>\r\n\r\n<strong>Булевы значения как числа</strong><br><br>\r\nЛогические значения в Python можно трактовать как числа. Значению True соответствует число 1, в то время как значению False соответствует 0. Таким образом, мы можем сравнить логические значения с числами:\r\n<pre>\r\n<strong>\r\nprint(True == 1)\r\nprint(False == 0)\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\nTrue\r\nTrue\r\n</strong>\r\n</pre>\r\nМы можем также применять арифметические операции к логическим значениям.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nprint(True + True + True - False)\r\nprint(True + (False / True))\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\n3\r\n1.0\r\n</strong>\r\n</pre>\r\nВозможность трактовать булевы выражения как числа на практике используется не так часто. Однако есть один прием, который может оказаться полезным. Поскольку True равно 1, а False равно 0, сложение логических значений вместе – это быстрый способ подсчета количества значений True. Это может пригодиться, когда требуется подсчитать количество элементов, удовлетворяющих условию.\r\n\r\nСледующий программный код:\r\n<pre>\r\n<strong>\r\nnumbers = [1, 2, 3, 4, 5, 8, 10, 12, 15, 17]\r\nres = 0\r\n\r\nfor num in numbers:\r\n    res += (num % 2 == 0)\r\n\r\nprint(res)\r\n</strong>\r\n</pre>\r\nвыведет количество четных элементов списка numbers, то есть число 5.",
    "slug": "bool-data-type"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 17,
  "fields": {
    "lesson": "Встроенные функции",
    "content": "<strong>Математические функции</strong><br><br>\r\n<strong>Функция abs()</strong><br><br>\r\n<strong>Функция abs()</strong> принимает один аргумент — число, и возвращает его абсолютное значение (модуль). Аргументом может быть целое, вещественное или комплексное число.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(abs(-19))\r\nprint(abs(3.14))\r\nprint(abs(3 + 4j))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n19\r\n3.14\r\n5.0\r\n</strong>\r\n</pre>\r\n</strong>\r\n</pre>\r\n<strong>Функция bin() </strong><br><br>\r\n<strong>Функция bin()</strong> преобразует целое число в двоичную строку с префиксом 0b.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(bin(13))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n0b1101\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция hex() </strong><br><br>\r\n<strong>Функция hex()</strong> преобразует целое число в шестнадцатеричную строку с префиксом 0x.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(hex(63))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n</strong>\r\n0x3f\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция oct()</strong><br><br>\r\n<strong>Функция oct()</strong> преобразует целое число в восьмеричную строку с префиксом 0o.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(oct(44))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n0o54\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция round()</strong><br><br>\r\n<strong>Функция round()</strong> используется для округления чисел. Она принимает два аргумента:<br><br>\r\n<li>number — округляемое число</li>\r\n<li>ndigits — количество знаков после запятой</li>\r\nФункция возвращает число, округленное до ndigits знаков после десятичной точки. Если аргумент ndigits не был передан или равняется None, то функция возвращает ближайшее целое число.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(round(3.4))\r\nprint(round(3.7))\r\nprint(round(3.48, 1))\r\nprint(round(3.41, 1))\r\nprint(round(3.376, 2))\r\nprint(round(3.371, 2))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n3\r\n4\r\n3.5\r\n3.4\r\n3.38\r\n3.37\r\n</strong>\r\n</pre>\r\nОсобенностью функции round() является то, что округление происходит до ближайшего четного (банковское округление). Другими словами, если дробная часть равна 0.5, то результатом округления будет ближайшее четное число.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(round(3.5))\r\nprint(round(4.5))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n4\r\n4\r\n</strong>\r\n</pre>\r\nИмейте в виду, что из-за проблем с точностью чисел с плавающей точкой, в некоторых случаях округление будет осуществляться в большую сторону, а в некоторых – в меньшую.<br><br>\r\n\r\n<strong>Функция pow()</strong><br><br>\r\n<strong>Функция pow()</strong> используется для возведения чисел в произвольную степень. Она может принимать три аргумента:<br><br>\r\n\r\n<li>base — возводимое число</li>\r\n<li>exp — число, являющееся степенью</li>\r\n<li>mod — необязательный аргумент, число, на которое требуется произвести деление с остатком</li>\r\nФункция возвращает число base в степени exp, с опциональным делением с остатком на mod.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(pow(3, 4))\r\nprint(pow(2, 5, 30))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n81\r\n2\r\n</strong>\r\n</pre>\r\n\r\n\r\n<strong>Типы данных</strong><br><br>\r\n<strong>Функция int()</strong><br><br>\r\n<strong>Функция int()</strong> возвращает целое число (тип int), созданное на основе числа или строки. Также функция имеет необязательный аргумент base — основание системы счисления, по умолчанию равное 10. Вызов без аргументов возвращает 0.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(int('37'))\r\nprint(int('111', base=2))\r\nprint(int(19.7))\r\nprint(int())\r\n</strong>\r\n</pre>\r\nвыводит: \r\n<pre>\r\n<strong>\r\n37\r\n7\r\n19\r\n0\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция float()</strong><br><br>\r\n<strong>Функция float()</strong> возвращает вещественное число (тип float), созданное на основе числа или строки. Вызов без аргументов возвращает 0.0.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(float('-13.99'))\r\nprint(float(78))\r\nprint(float())\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n-13.99\r\n78.0\r\n0.0\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция complex()</strong><br><br>\r\n<strong>Функция complex()</strong> используется для создания комплексного числа (тип complex). Она может принимать два аргумента:<br><br>\r\n\r\n<li>real — число или строка. Если число, то оно представляет действительную часть комплексного числа</li>\r\n<li>imag — только число, мнимая часть комплексного числа; по умолчанию равняется нулю</li>\r\nФункция преобразует строку с записью комплексного числа в комплексное число или возвращает комплексное число со значением переданных аргументов: действительной и мнимой частью. Вызов без аргументов возвращает 0j. \r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(complex(4, 9))\r\nprint(complex('11+5j'))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n(4+9j)\r\n(11+5j)\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция bool()</strong><br><br>\r\n<strong>Функция bool()</strong> возвращает логическое значение переданного объекта. Объект будет возвращать False, если:<br><br>\r\n\r\n<li>объект пуст — [], (), {}</li>\r\n<li>объект — False</li>\r\n<li>объект равен 0</li>\r\n<li>объект — None</li>\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(bool('Beegeek'))\r\nprint(bool(17))\r\nprint(bool(['apple', 'cherry']))\r\nprint(bool())\r\nprint(bool(''))\r\nprint(bool(0))\r\nprint(bool([]))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTrue\r\nTrue\r\nTrue\r\nFalse\r\nFalse\r\nFalse\r\nFalse\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция str()</strong>\r\n<strong>Функция str()</strong> возвращает строковое представление объекта (тип str). Вызов без аргументов возвращает пустую строку.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(str(11))\r\nprint(str(set(range(5))))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n11\r\n{0, 1, 2, 3, 4}\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция list()</strong><br><br>\r\n<strong>Функция list()</strong> преобразует итерируемый объект в список (тип list). Вызов без аргументов возвращает пустой список.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(list())\r\nprint(list(range(5)))\r\nprint(list('abcde'))\r\nprint(list([1, 2, 3, 4]))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n[]\r\n[0, 1, 2, 3, 4]\r\n['a', 'b', 'c', 'd', 'e']\r\n[1, 2, 3, 4]\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция tuple()</strong><br><br>\r\n<strong>Функция tuple()</strong> преобразует итерируемый объект в кортеж (тип tuple). Вызов без аргументов возвращает пустой кортеж.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(tuple())\r\nprint(tuple('stepik'))\r\nprint(tuple([1, 2, 3, 4]))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n()\r\n('s', 't', 'e', 'p', 'i', 'k')\r\n(1, 2, 3, 4)\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция set()</strong><br><br>\r\n<strong>Функция set()</strong> преобразует итерируемый объект в множество (тип set). Вызов без аргументов возвращает пустое множество.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(set())\r\nprint(set(map(int, '12345')))\r\nprint(set(['a', 'b', 'a', 'd', 'd']))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nset()\r\n{1, 2, 3, 4, 5}\r\n{'b', 'd', 'a'}\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция frozenset()</strong><br><br>\r\n<strong>Функция frozenset()</strong> преобразует итерируемый объект в неизменяемое множество (тип frozenset). Вызов без аргументов возвращает пустое неизменяемое множество.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(frozenset())\r\nprint(frozenset('beegeek'))\r\nprint(frozenset(set('aaaabbccccccde')))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nfrozenset()\r\nfrozenset({'g', 'e', 'k', 'b'})\r\nfrozenset({'a', 'c', 'e', 'd', 'b'})\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция dict()</strong><br><br>\r\n<strong>Функция dict()</strong> преобразует последовательность пар ключ-значение в словарь (тип dict). Если ключами являются обыкновенные строки, то пары ключ-значение можно указывать в виде именованных аргументов. Вызов без аргументов возвращает пустой словарь.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(dict())\r\nprint(dict(a=1, b=2))\r\nprint(dict([('a', 1), ('b', 2), ('c', 3)]))\r\nprint(dict([('a', 1), ('b', 2)], c=3, d=4))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n{}\r\n{'a': 1, 'b': 2}\r\n{'a': 1, 'b': 2, 'c': 3}\r\n{'a': 1, 'b': 2, 'c': 3, 'd': 4}\r\n</strong>\r\n</pre>\r\n\r\n<strong>Строковые функции</strong><br><br>\r\n<strong>Функция ord()</strong><br><br>\r\n<strong>Функция ord()</strong> возвращает число, представляющее позицию переданного символа в таблице Unicode.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(ord('a'))\r\nprint(ord('B'))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n97\r\n66\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция chr()</strong><br><br>\r\n<strong>Функция chr()</strong> возвращает символ, чья позиция в таблице Unicode соответствует переданному числу.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(chr(97))\r\nprint(chr(66))\r\n</strong>\r\n</pre>\r\nвыводит: \r\n<pre>\r\n<strong>\r\na\r\nB\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функции, работающие с коллекциями</strong><br><br>\r\nСледующий набор функций позволяет обрабатывать итерируемые объекты, например списки, строки, кортежи, множества и т.д.<br><br>\r\n\r\n<strong>Функция min()</strong><br><br>\r\n<strong>Функция min()</strong> возвращает наименьшее значение элемента итерируемого объекта или самое маленькое из двух или более переданных позиционных аргументов. Также функция min() может принимать два необязательных аргумента:<br><br>\r\n\r\n<li>key — функция сортировки</li>\r\n<li>default — значение по умолчанию, если итерируемый объект окажется пустым</li>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(min([1, 2, 5, 7, 34, 6]))\r\nprint(min('a', 'b', 'ab'))\r\nprint(min([-3, 4, -90, 3, 45], key=abs))\r\nprint(min([], default='Empty'))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n1\r\na\r\n-3\r\nEmpty\r\n</strong>\r\n</pre>\r\nЕсли аргумент default не указан, то при передаче в функцию min() пустого итерируемого объекта произойдет ошибка.<br><br>\r\n\r\n<strong>Функция max()</strong><br><br>\r\n<strong>Функция max()</strong> возвращает наибольшее значение элемента итерируемого объекта или самое большое из двух или более переданных позиционных аргументов. Также функция max() может принимать два необязательных аргумента:<br><br>\r\n\r\n<li>key — функция сортировки</li>\r\n<li>default — значение по умолчанию, если итерируемый объект окажется пустым</li>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(max([1, 2, 5, 7, 34, 6]))\r\nprint(max('a', 'b', 'ab'))\r\nprint(max([-3, 4, -90, 3, 45], key=abs))\r\nprint(max([], default='Empty'))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n34\r\nb\r\n-90\r\nEmpty\r\n</strong>\r\n</pre>\r\nЕсли аргумент default не указан, то при передаче в функцию max() пустого итерируемого объекта произойдет ошибка.<br><br>\r\n\r\n<strong>Функция len()</strong><br><br>\r\n<strong>Функция len()</strong> возвращает количество элементов в объекте. Объект может быть строкой, списком, кортежем, словарем, множеством или объектом типа range. \r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(len([1, 2, 3, 4, 5, 6]))\r\nprint(len('abcdefg'))\r\nprint(len(range(10)))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n6\r\n7\r\n10\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция sum()</strong><br><br>\r\n<strong>Функция sum()</strong> возвращает сумму элементов переданного итерируемого объекта. Также функция имеет необязательный аргумент start — начальное значение для суммы (не может быть строкой), по умолчанию равное нулю.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(sum([1, 2, 3, 4, 5, 6]))\r\nprint(sum([], 99))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n21\r\n99\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция reversed()</strong><br><br>\r\n<strong>Функция reversed()</strong> возвращает обратный итератор, то есть возвращает итератор, который перебирает элементы оригинала в обратном порядке.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfor i in reversed([1, 2, 3, 4, 5]):\r\n    print(i, end=' ')\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n5 4 3 2 1\r\n</strong>\r\n</pre>\r\n \r\n<strong>Функция sorted()</strong><br><br>\r\n<strong>Функция sorted()</strong> возвращает список (тип list) с отсортированными элементами переданного итерируемого объекта. При совпадении значений элементов сохраняется их исходный порядок следования. Также функция имеет два необязательных аргумента:<br><br>\r\n\r\n<li>key — функция сортировки</li>\r\n<li>reverse — если установлено значение True, то элементы списка сортируются по убыванию</li>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(sorted([23, 4, 56, 6, 39]))\r\nprint(sorted([23, 4, 56, 6, 39], reverse=True))\r\nprint(sorted(['beegeek', 'step', 'python'], key=len))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n[4, 6, 23, 39, 56]\r\n[56, 39, 23, 6, 4]\r\n['step', 'python', 'beegeek']\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция all()</strong><br><br>\r\n<strong>Функция all()</strong> возвращает значение True, если все элементы в итерируемом объекте истинны, в противном случае она возвращает значение False.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(all([1, 2, 3]))   \r\nprint(all([1, 2, 3, 0, 5]))\r\nprint(all([True, 0, 1]))\r\nprint(all(('', 'red', 'green')))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTrue\r\nFalse\r\nFalse\r\nFalse\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция any()</strong><br><br>\r\n<strong>Функция any()</strong> возвращает True, если какой-либо (любой) элемент в итерируемом объекте является истинным, в противном случае она возвращает значение False.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(any([0, 0, 0]))\r\nprint(any([0, 1, 0]))\r\nprint(any([False, 0, 1]))\r\nprint(any(['', [], 'green']))\r\n</strong>\r\n</pre>\r\n\r\nвыводит:\r\n<pre>\r\n<strong>\r\nFalse\r\nTrue\r\nTrue\r\nTrue\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция enumerate()</strong><br><br>\r\nВстроенная <strong>функция enumerate()</strong> возвращает итератор кортежей, которые состоят из индекса элемента и самого элемента переданного итерируемого объекта. Также функция имеет необязательный аргумент start —  начальное значение индекса, по умолчанию равное нулю.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ncolors = ['red', 'green', 'blue']\r\n\r\nfor pair in enumerate(colors, 1):\r\n    print(pair)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n(1, 'red')\r\n(2, 'green')\r\n(3, 'blue')\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция range()</strong><br><br>\r\n<strong>Функция range()</strong> используется для генерации арифметической последовательности целых чисел с заданным шагом. Она может принимать три аргумента:<br><br>\r\n\r\n<li>start — начало последовательности (включительно)</li>\r\n<li>stop — конец последовательности (не включительно)</li>\r\n<li>step — шаг последовательности</li>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(*range(10))\r\nprint(*range(1, 10))\r\nprint(*range(2, 10, 2))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n0 1 2 3 4 5 6 7 8 9\r\n1 2 3 4 5 6 7 8 9\r\n2 4 6 8\r\n</strong>\r\n</pre>\r\nНа самом деле функция range() генерирует и возвращает объект типа range, который помимо итерации по своим элементам поддерживает:<br><br>\r\n\r\n<li>индексацию</li>\r\n<li>срезы (возвращают новый range объект)</li>\r\n<li>операторы равенства ==, неравенства != и принадлежности in</li>\r\n<li>методы index() и count() (работают так же, как, например, со списками, но быстрее)</li>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nmy_range = range(1, 11)\r\n\r\nprint(my_range[0])\r\nprint(my_range[1:4])\r\nprint(my_range.count(7))\r\nprint(my_range.index(10))\r\nprint(my_range == range(1, 10))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n1\r\nrange(2, 5)\r\n1\r\n9\r\nFalse\r\n</strong>\r\n</pre>\r\nПреимущество типа данных range над списками или кортежами в том, что диапазоны range всегда будут занимать небольшое количество памяти, независимо от размера диапазона, которое он представляет, так как он хранит в памяти только значение start, stop и step, а элементы последовательности вычисляются по мере необходимости.<br><br>\r\n\r\n<strong>Функция zip()</strong><br><br>\r\n<strong>Функция zip()</strong> возвращает итератор кортежей, который объединяет элементы каждой из переданных последовательностей. Количество передаваемых последовательностей может быть произвольным. \r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnumbers = [1, 2, 3]\r\nwords = ['one', 'two', 'three']\r\nromans = ['I', 'II', 'III']\r\n\r\nfor number in zip(numbers, words, romans):\r\n    print(number)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n(1, 'one', 'I')\r\n(2, 'two', 'II')\r\n(3, 'three', 'III')\r\n</strong>\r\n</pre>\r\n\r\n<strong>Другие функции</strong><br><br>\r\n\r\n<strong>Функция id()</strong><br><br>\r\n<strong>Функция id()</strong> возвращает уникальный идентификатор для указанного объекта.<br><br>\r\n\r\nВсе объекты в Python имеют свой уникальный идентификатор. Идентификатор присваивается объекту при его создании. Идентификатор является адресом памяти объекта и будет отличаться при каждом запуске программы. Следует иметь в виду, что некоторые объекты могут иметь один и тот же идентификатор, например: целые числа от −5 до 256, True и False.<br><br>\r\n\r\n<strong>Функция input()</strong><br><br>\r\n<strong>Функция input()</strong> позволяет обеспечить ввод пользовательских данных из консоли. Она может принимать один необязательный аргумент prompt — строку подсказки.<br><br>\r\n\r\n<strong>Функция isinstance()</strong><br><br>\r\n<strong>Функция isinstance()</strong> используется для проверки принадлежности объекта к некоторому типу данных. Она принимает два аргумента:<br><br>\r\n\r\n<li>object — объект, требующий проверки</li>\r\n<li>typeinfo — тип данных или кортеж с типами</li>\r\nФункция возвращает True, если object принадлежит типу данных typeinfo или одному из типов, если был передан кортеж, или False в противном случае.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(isinstance(3, int))\r\nprint(isinstance(3.5, (float, int, str)))\r\nprint(isinstance('Beegeek', str))\r\nprint(isinstance([1, 2, 3], list))\r\nprint(isinstance(True, bool))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTrue\r\nTrue\r\nTrue\r\nTrue\r\nTrue\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция open()</strong><br><br>\r\n<strong>Функция open()</strong> открывает файл для чтения или записи при помощи файлового потока и возвращает файловый объект, который имеет методы, позволяющие читать и записывать информацию различными способами. Она принимает один обязательный аргумент file — абсолютное или относительное значение пути к файлу, а также следующие необязательные аргументы:<br><br>\r\n\r\n<li>mode — строка, которая указывает режим, в котором открывается файл, по умолчанию имеет значение 'r'</li>\r\n<li>encoding — кодировка, используемая для декодирования или кодирования файла</li><br><br>\r\n\r\n<strong>Функция print()</strong><br><br>\r\n<strong>Функция print()</strong> позволяет обеспечить вывод пользовательских данных в текстовый поток. Помимо переменного числа объектов, которые следует вывести, она может принимать необязательные ключевые аргументы:<br><br>\r\n\r\n<li>sep — строка, разделитель объектов, по умолчанию имеет значение ' '</li>\r\n<li>end — строка, которой заканчивается вывод, по умолчанию имеет значение '\\n'</li>\r\n<li>file — файл, в который реализуется вывод, по умолчанию имеет значение sys.stdout</li>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(*[1, 2, 3, 4, 5], sep=', ', end='!')\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n1, 2, 3, 4, 5!\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция type()</strong><br><br>\r\n<strong>Функция type()</strong> возвращает тип данных, к которому относится переданный объект.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(type(3))\r\nprint(type(3.5))\r\nprint(type('Beegeek'))\r\nprint(type([1, 2, 3]))\r\nprint(type(True))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\nstrong\r\nclass 'int'\r\nclass 'float'\r\nclass 'str'\r\nclass 'list'\r\nclass 'bool'\r\n</strong>\r\n</pre>",
    "slug": "built-in-functions"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 18,
  "fields": {
    "lesson": "Функции высшего порядка",
    "content": "<strong>Функции высшего порядка</strong><br><br>\r\n<strong>Функции высшего порядка</strong> – это функции, которые принимают или/и возвращают другие функции.<br><br>\r\n\r\nНапример, встроенные функции min(), max(), sorted() – функции высшего порядка, так как принимают в качестве необязательного аргумента key функцию сравнения элементов.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnumbers = [10, -7, 8, -100, -50, 32, 87, 117, -210]\r\n\r\nprint(max(numbers, key=abs))                   #  указываем функцию abs в качестве компаратора\r\nprint(min(numbers, key=lambda x: x**2))        #  указываем анонимную функцию в качестве компаратора\r\nprint(sorted(numbers, key=lambda x: -x))        #  указываем анонимную функцию в качестве компаратора\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n-210                                           # элемент, модуль которого максимален\r\n-7                                             # элемент, квадрат которого минимален\r\n[117, 87, 32, 10, 8, -7, -50, -100, -210]      # сортировка чисел по убыванию\r\n</strong>\r\n</pre>\r\n\r\nДругим важным примером встроенных функций высшего порядка являются функции map() и filter(), которые принимают обязательный аргумент func, представляющий из себя функцию преобразования, либо фильтрации элементов.<br><br>\r\n\r\n<strong>Функция map()</strong><br><br>\r\nВстроенная <strong>функция map()</strong> преобразует элементы переданного итерируемого объекта в соответствии с некоторой функцией и возвращает объект итератора.\r\n\r\nАргументы функции:<br><br>\r\n\r\n<li>func — функция, которая вызывается для каждого элемента итерируемого объекта</li>\r\n<li>iterable — итерируемый объект</li><br>\r\nФункция map() выполняет пользовательскую функцию func для каждого элемента последовательности iterable. Каждый элемент iterable отправляется в функцию func в качестве аргумента.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nsquares = map(lambda x: x ** 2, range(1, 10))\r\nabsolute = map(abs, [-5, 6, 7, -90, 34, 54, -21])\r\nnumbers = map(lambda s: s.replace('.', ''), ['12.3', '-45.3', '34', '34...90'])\r\ncapitals = map(lambda s: s.capitalize(), ['timur', 'artur', 'ruslan'])\r\n\r\nprint(*squares)\r\nprint(*absolute)\r\nprint(*numbers)\r\nprint(*capitals)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n1 4 9 16 25 36 49 64 81\r\n5 6 7 90 34 54 21\r\n123 -453 34 3490\r\nTimur Artur Ruslan\r\n</strong>\r\n</pre>\r\nОбратите внимание на то, что функция map() возвращает <strong>специальный объект</strong>, который называется <strong>итератором</strong>. По итераторам можно пройтись циклом for или распаковать их. <br><br>\r\n\r\nЕсли в функцию map() передаётся несколько iterable, то функция func должна принимать количество аргументов, соответствующее количеству переданных итерируемых объектов, при этом func будет применяться к элементам всех итерируемых объектов параллельно.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nsumma = map(lambda x, y, z: x + y + z, [1, 2], [3, 4], [5, 6])\r\npowers = map(pow, [2, 3, 4], [4, 2, 3])\r\n\r\nprint(*summa)\r\nprint(*powers)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n9 12\r\n16 9 64\r\n</strong>\r\n</pre>\r\nПри использовании нескольких последовательностей функция map() останавливается, когда исчерпывается самый короткий итерируемый объект.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\npairs = map(lambda x, y: (x, y), ['a', 'b'], [3, 4, 5, 6, 7])\r\n\r\nprint(*pairs)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n('a', 3) ('b', 4)\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция filter()</strong><br><br>\r\nВстроенная <strong>функция filter()</strong> фильтрует элементы переданного итерируемого объекта в соответствии с некоторой функцией и возвращает объект итератора.\r\n\r\nАргументы функции:<br><br>\r\n\r\n<li>func — функция, которая принимает элемент последовательности и возвращает bool значение</li>\r\n<li>iterable — итерируемый объект</li>\r\nФункция filter() фильтрует элементы переданного объекта iterable при помощи функции func. Если фильтрующая функция func вернёт False, то элемент последовательности iterable не попадёт в результирующий итератор.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnums = [9, 3, 45, 67, 12, 90, 87, 12, 45, 67]\r\nnames = ['timur', 'anton', 'Alana', 'ruslan', '', 'Gvido', 'Alika']\r\n\r\nfilter1 = filter(lambda x: x % 2 == 0, nums)\r\nfilter2 = filter(lambda x: x % 2 == 1 and x > 10, nums)\r\nfilter3 = filter(lambda x: len(x) > 0 and x[0].lower() == 'a', names)\r\n\r\nprint(*filter1)\r\nprint(*filter2)\r\nprint(*filter3)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n12 90 12\r\n45 67 87 45 67\r\nanton Alana Alika\r\n</strong>\r\n</pre>\r\nЕсли вместо фильтрующей функции func передать значение None, то каждый элемент последовательности будет проверен на соответствие значению True. Если элемент в логическом контексте возвращает значение False, то он не будет добавлен в результирующий итератор.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndata = [1, 0, 10, '', None, [], [1, 2, 3], ()]\r\n\r\nfiltered_data = filter(None, data)\r\n\r\nprint(*filtered_data)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n1 10 [1, 2, 3]\r\n</strong>\r\n</pre>\r\nПри несложной фильтрации вместо аргумента func часто подставляют анонимную функцию, используя в ней стандартные функции или методы, возвращающие bool значения:<br><br>\r\n\r\n<li>операции сравнения</li>\r\n<li>оператор вхождения in</li>\r\n<li>оператор идентичности is</li>\r\nи т.д.<br><br>\r\nЕсли необходимо произвести более сложную фильтрацию, то для этого необходимо определить обычную функцию с помощью ключевого слова def и передать ее в качестве первого аргумента функции filter().",
    "slug": "higher-order-functions"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 19,
  "fields": {
    "lesson": "Lamda функции",
    "content": "<strong>Анонимные функции</strong><br><br>\r\nВ языке Python для определения функций используется ключевое слово def. Приведенный ниже код определяет функцию hello(), принимающую один аргумент name:\r\n<pre>\r\n<strong>\r\ndef hello(name):\r\n    print(f'Привет, {name}!')\r\n</strong>\r\n</pre>\r\nВызвав функцию следующим образом hello('Гвидо'), получим:\r\n<pre>\r\n<strong>\r\nПривет, Гвидо!\r\n</strong>\r\n</pre>\r\nИногда, бывают ситуации, когда определяемые нами функции используются единственный раз. Для таких функций можно использовать синтаксис <strong>анонимных функций</strong> (лямбда-функций) с помощью ключевого слова lambda. Определенную выше функцию hello() можно записать следующим образом:\r\n<pre>\r\n<strong>\r\nhello = lambda name: print(f'Привет, {name}!')\r\n</strong>\r\n</pre>\r\nВызвав функцию следующим образом hello('Деннис'), получим:\r\n<pre>\r\n<strong>\r\nПривет, Деннис!\r\n</strong>\r\n</pre>\r\nОбщий формат определения анонимной функции: lambda список_параметров: выражение. \r\n\r\nТут список_параметров – список параметров через запятую, выражение – значение, либо код, дающий значение.\r\n\r\nПараметры анонимных функций, в отличие от обычных, не нужно заключать в скобки.\r\n\r\nРассмотрим еще примеры. Приведенный ниже код:\r\n<pre>\r\n<strong>\r\nf1 = lambda: 17                          # функция без параметров\r\nf2 = lambda х, у: х**2 + у**2            # функция с двумя параметрами\r\nf3 = lambda х, у, z: х * у * z           # функция с тремя параметрами\r\n\r\nprint(f1())\r\nprint(f2(6, 8))\r\nprint(f3(5, 10, 30))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n17\r\n100\r\n1500\r\n</strong>\r\n</pre>\r\nОбратите внимание на то, что анонимные функции ограничены всегда одним выражением и <strong>не содержат инструкции return</strong>.<br><br>\r\n\r\nПрименение анонимных функций, как правило, оправдано в следующих ситуациях:<br><br>\r\n\r\n<li>однократное использование функции</li>\r\n<li>передача функций в качестве аргументов другим функциям</li>\r\n<li>возвращение функции в качестве результата другой функции</li>",
    "slug": "lambda-functions"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 20,
  "fields": {
    "lesson": "Функции как объекты",
    "content": "<strong>Функции как объекты</strong><br><br>\r\nВ языке Python функции являются такими же объектами, как и числа, строки, списки и т.д. Поэтому функцию можно записать в переменную. Оказывается, помимо этого, с именем функции можно работать как с самой обыкновенной переменной.\r\n\r\nРассмотрим программный код:\r\n<pre>\r\n<strong>\r\ndef my_func():\r\n    return 17\r\n\r\ninput = my_func\r\nnum = input()\r\nprint(num)\r\n</strong>\r\n</pre>\r\n\r\nСтрока input = my_func подменяет встроенную функцию input(). Теперь вызов функции input() всегда возвращает один и тот же результат – число 17.<br><br>\r\n\r\nНапишем функцию nop(), которая принимает произвольное число позиционных и именованных аргументов, а затем подменим встроенную функцию print().\r\n<pre>\r\n<strong>\r\ndef nop(*rest, **kwargs):\r\n    pass                               # заглушка, функция ничего не делает\r\n\r\nprint = nop\r\nprint('Привет', 'мир')\r\nprint('Stepik', 'Beegeek', 'Python', sep='*', end='')\r\nprint('Stepik', 'Beegeek', 'Python', delimeter='-', endline='\\n')\r\n</strong>\r\n</pre>\r\n\r\nСтрока print = nop подменяет встроенную функцию print(). Теперь вызов функции print(), независимо от переданных аргументов, ничего не делает. Привычная функция print() изменила поведение.<br><br>\r\n\r\nОбратите внимание на то, что в качестве аргументов функции nop() указано произвольное число позиционных и именованных аргументов. Благодаря этому мы можем передавать ей разное число аргументов, как и в старую функцию print(). На самом деле теперь не вызывают ошибки даже те наборы аргументов, которые не работают со встроенной функцией print(): функция print() принимает не любые именованные аргументы, а только небольшой список, функция nop() же (а значит, и переопределенная функция print()) — абсолютно любые.<br><br>\r\n\r\nПодменяя функцию, мы заботимся о том, чтобы ее аргументы соответствовали аргументам исходной функции. Иначе придется переписывать не только функцию, но и ее вызовы, а в таком случае гораздо лучше просто завести новую функцию.<br><br>\r\n\r\nПоскольку функции являются обычными объектами, то мы можем хранить их в структурах данных точно так же, как и другие объекты. Например, мы можем создать список или словарь, содержащий функции.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndef avg(nums):\r\n    return sum(nums)/len(nums)\r\n\r\nfuncs = [len, sum, min, avg]\r\n\r\nprimes = [2, 3, 5, 7, 11]\r\n\r\nfor func in funcs:\r\n    print(func(primes))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n5\r\n28\r\n2\r\n5.6\r\n</strong>\r\n</pre>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfuncs = {'capitalize': str.capitalize, \r\n         'swapcase': str.swapcase, \r\n         'title': str.title, \r\n         'lower': str.lower, \r\n         'upper': str.upper}\r\n\r\nsentence = 'This is the Best course TO study in the world!'\r\n\r\nprint(funcs['upper'](sentence))\r\nprint(funcs['swapcase'](sentence))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTHIS IS THE BEST COURSE TO STUDY IN THE WORLD!\r\ntHIS IS THE bEST COURSE to STUDY IN THE WORLD!\r\n</strong>\r\n</pre>\r\nОбратите внимание на то, что мы можем использовать методы как обычные функции. Для этого нужно указать название типа, затем точку и название метода: type.method.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ntext = 'hello'\r\nnumbers = [1, 2, 3]\r\n\r\ntext_upper = str.upper(text)\r\nlist.append(numbers, 4)\r\n\r\nprint(text_upper)\r\nprint(numbers)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nHELLO\r\n[1, 2, 3, 4]\r\n</strong>\r\n</pre>\r\n\r\n<strong>Атрибуты __name__, __doc__, __defaults__</strong><br><br>\r\nВсе функции содержат специальные атрибуты, которые содержат полезную информацию.\r\n\r\nТри важных атрибута:<br><br>\r\n\r\n<li>__name__ — имя функции</li>\r\n<li>__doc__ — строка документации</li>\r\n<li>__defaults__ — кортеж с аргументами по умолчанию</li>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndef func(name, language='Python', year=1992):\r\n    pass\r\n\r\nprint(func.__name__)          # имя функции\r\nprint(func.__doc__)           # строка документации\r\nprint(func.__defaults__)      # кортеж с аргументами по умолчанию\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nfunc\r\nNone\r\n('Python', 1992)\r\n</strong>\r\n</pre>\r\n<strong>Строка документации (docstring)</strong> — это строковый литерал, который расположен сразу за объявлением функции.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(abs.__doc__)\r\nprint(str.lower.__doc__)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nReturn the absolute value of the argument.\r\nReturn a copy of the string converted to lowercase.\r\n</strong>\r\n</pre>\r\n<strong>Основное назначение комментариев</strong> – пояснить что делает код, как он работает. Основное назначение строк документации – описать в целом для чего предназначен объект, какие аргументы принимает, и что возвращает.<br><br>\r\n\r\nДля описания строки документации обычно используют тройные кавычки, в которых размещается соответствующая информация.\r\n\r\nПриведенный ниже код: \r\n<pre>\r\n<strong>\r\ndef square(n):\r\n    '''Принимает число и возвращает его квадрат.'''\r\n    return n**2\r\n\r\ndef average(*args):\r\n    '''Принимает несколько чисел и возвращает их среднее арифметическое значение.'''\r\n    return sum(args)/len(args)\r\n\r\nprint(square.__doc__)\r\nprint(average.__doc__)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nПринимает число и возвращает его квадрат.\r\nПринимает несколько чисел и возвращает их среднее арифметическое значение.\r\n</strong>\r\n</pre>\r\nМы можем использовать как тройные двойные кавычки \"\"\", так и тройные одинарные кавычки ''' для создания строк документации. Тройные кавычки используются для многострочных строк.<br><br>\r\n\r\nОбратите внимание на то, что в строку документации попадает только первая строка после определения функции (инструкция def):\r\n<pre>\r\n<strong>\r\n\r\ndef sum_squares(nums):\r\n    '''Принимает список чисел и возвращает сумму квадратов его элементов.'''\r\n    total = 0\r\n    '''Это уже не относится к строке документации.'''\r\n    for i in nums:\r\n        total += i ** 2\r\n    return total\r\n\r\nprint(sum_squares.__doc__)\r\n</strong>\r\n</pre>\r\nвыводит: \r\n<pre>\r\n<strong>\r\nПринимает список чисел и возвращает сумму квадратов его элементов.\r\n</strong>\r\n</pre>\r\n\r\n<strong>Переопределение (подмена) функций достаточно мощный механизм, однако и опасный. Никогда не стоит переопределять встроенные функции.</strong><br><br>\r\n\r\nНе забывайте, что <strong>значения по умолчанию</strong> (__defaults__) для аргументов функции конструируются только один раз при создании функции. Поэтому всегда является плохой идеей использовать изменяемые типы данных (list, set, dict и т.д.) в качестве значений по умолчанию.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndef append(element, seq=[]):\r\n    seq.append(element)\r\n\r\nprint(append.__defaults__)\r\nappend(10)\r\nprint(append.__defaults__)\r\nappend(20)\r\nprint(append.__defaults__)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n([],)\r\n([10],)\r\n([10, 20],)\r\n</strong>\r\n</pre>\r\nДля решения указанной выше проблемы можно использовать следующий код:\r\n<pre>\r\n<strong>\r\ndef append(element, seq=None):\r\n    if seq is None:\r\n        seq=[]\r\n    seq.append(element)\r\n</strong>\r\n</pre>\r\n\r\nУ объектов функций есть дополнительный атрибут __dict__, являющийся словарем и использующийся для динамического наделения функций дополнительным функционалом. Устанавливать и получать значения из данного атрибута можно, используя два синтаксиса:<br><br>\r\n\r\n<li>в стиле словаря: func.__dict__['attr'] = value</li>\r\n<li>через точечную нотацию: func.attr = value</li>\r\nДоступ к словарю атрибутов функции можно получить как из тела функции, так и извне.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndef greet():\r\n    greet.age = 17\r\n\r\nprint(greet.__dict__)\r\n\r\ngreet.value = 777\r\ngreet.numbers = [1, 2, 3]\r\ngreet.name = 'Timur'\r\n\r\nprint(greet.__dict__)\r\n\r\ngreet()\r\n\r\nprint(greet.__dict__)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n{}\r\n{'value': 777, 'numbers': [1, 2, 3], 'name': 'Timur'}\r\n{'value': 777, 'numbers': [1, 2, 3], 'name': 'Timur', 'age': 17}\r\n</strong>\r\n</pre>\r\nЕсли никакие атрибуты функции никогда не устанавливались, то словарь атрибутов функции __dict__ будет пустой.<br><br>\r\n\r\nСловарь атрибутов может быть использован для кэширования уже вычисленных значений функции.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndef fib(num):\r\n    if num < 2:\r\n        return num\r\n    return fib(num - 1) + fib(num - 2)\r\n</strong>\r\n</pre>\r\nмногократно вычисляет числа Фибоначчи.",
    "slug": "functions-object"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 21,
  "fields": {
    "lesson": "Вложенные функции, замыкания",
    "content": "<strong>Вложенные функции</strong><br><br>\r\nPython позволяет определять функции внутри других функций. Их называют вложенными функциями или внутренними функциями.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndef speak(text):\r\n    def whisper(t):                      # объявляем вложенную функцию\r\n        return t.lower() + '...'\r\n    return whisper(text)                 # вызываем вложенную функцию и возвращаем ее результат\r\n\r\nprint(speak('Hello, World'))         \r\n</strong>\r\n</pre>\r\nопределяет вложенную функцию whisper() внутри функции speak() и выводит:\r\n<pre>\r\n<strong>\r\nhello, world...\r\n</strong>\r\n</pre>\r\nКаждый раз, когда мы вызываем функцию speak(), она определяет новую внутреннюю функцию whisper(), а затем вызывает ее. При этом функция whisper() не существует вне родительской функции speak().\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nwhisper('Hello')\r\n</strong>\r\n</pre>\r\nприводит к возникновению ошибки:\r\n<pre>\r\n<strong>\r\nNameError: name 'whisper' is not defined\r\n</strong>\r\n</pre>\r\nРовно как и приведенный ниже код:\r\n<pre>\r\n<strong>\r\nspeak.whisper('Hello')\r\n</strong>\r\n</pre>\r\nприводит к возникновению ошибки:\r\n<pre>\r\n<strong>\r\nAttributeError: 'function' object has no attribute 'whisper'\r\n</strong>\r\n</pre>\r\nЕсли нам нужно получить доступ к вложенной функции whisper() извне, то мы можем <strong>вернуть ее (вложенную функцию)</strong> вызывающей стороне родительской функции.<br><br>\r\n\r\nФункция высшего порядка get_speak_func() определяет две вложенные функции whisper() и yell(). В зависимости от аргумента volume, переданного родительской функции get_speak_func(), она выбирает и возвращает вызывающей стороне одну из вложенных функций:\r\n<pre>\r\n<strong>\r\ndef get_speak_func(volume):\r\n    def whisper(text):\r\n        return text.lower() + '...'\r\n    def yell(text):\r\n        return text.upper() + '!'\r\n\r\n    if volume > 0.5:\r\n        return yell\r\n    else:\r\n        return whisper\r\n</strong>\r\n</pre>\r\n\r\nОбратите внимание на то, что функция get_speak_func() на самом деле не вызывает одну из своих вложенных функций — она просто выбирает подходящую функцию на основе аргумента volume, а затем возвращает объект этой функции.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nwhisper = get_speak_func(0.3)     # функция whisper()\r\nyell = get_speak_func(0.7)        # функция yell()\r\n\r\nprint(whisper('Hello'))           # говорим шепотом\r\nprint(yell('Hello'))              # кричим\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nhello...\r\nHELLO!\r\n</strong>\r\n</pre>\r\nТаким образом, функции не только могут принимать поведение через аргументы, но также могут возвращать поведение.<br><br>\r\n\r\n<strong>Замыкания</strong><br><br>\r\nВложенные функции могут захватывать и переносить с собой часть состояния родительской функции.<br><br>\r\n\r\nПерепишем немного функцию get_speak_func(), чтобы новая версия сразу принимала два аргумента volume и text:\r\n<pre>\r\n<strong>\r\ndef get_speak_func(text, volume):\r\n    def whisper():\r\n        return text.lower() + '...'\r\n    def yell():\r\n        return text.upper() + '!'\r\n    \r\n    if volume > 0.5:\r\n        return yell\r\n    else:\r\n        return whisper\r\n</strong>\r\n</pre>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nyell = get_speak_func('Hello, World', 0.7)\r\n\r\nprint(yell())\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nHELLO, WORLD!\r\n</strong>\r\n</pre>\r\nТеперь вложенные функции whisper() и yell() не имеют параметра text. Они его получают и используют через родительскую функцию get_speak_func(). Функции, которые делают это, <strong>называются замыканиями</strong>. Замыкание запоминает значения из включающей его области, даже если поток программы больше не находится в этой области.<br><br>\r\n\r\nТаким образом, <strong>замыкание</strong> — это особый вид функции. Она определена в теле другой функции и создаётся каждый раз во время её выполнения. Синтаксически это выглядит как функция, находящаяся целиком в теле другой функции. При этом вложенная функция содержит ссылки на локальные переменные внешней функции. Каждый раз при выполнении внешней функции происходит создание нового экземпляра внутренней функции, с новыми ссылками на переменные внешней функции.\r\n<pre>\r\n<strong>\r\ndef closure():\r\n    count = 0\r\n    def inner():\r\n        nonlocal count\r\n        count += 1\r\n        print(count)\r\n    return inner\r\n\r\nstart = closure()\r\nanother = closure()             # другое замыкание, со своими локальными значениями\r\n\r\nstart()                         # выводит 1\r\nstart()                         # выводит 2\r\n\r\nanother()                       # выводит 1\r\n\r\nstart()                         # выводит 3\r\n</strong>\r\n</pre>\r\nЗамыкания очень полезны при решении многих задач. С их помощью функции могут не только возвращать поведение, но и предварительно настраивать это поведение.<br><br>\r\n\r\nРассмотрим несколько примеров, в которых используются замыкания.<br><br>\r\n\r\nПример 1. В этом примере функция greeting_creator() служит фабрикой для создания и настройки функции приветствия. Обратите внимание на то, что вложенная функция greet() может обращаться к аргументу greeting_word своей родительской функции greeting_creator().\r\n<pre>\r\n<strong>\r\ndef greeting_creator(greeting_word):\r\n    def greet(name):\r\n        return f'{greeting_word}, {name}'\r\n\r\n    return greet\r\n</strong>\r\n</pre>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nsay_hi = greeting_creator('Hi')\r\nsay_hello = greeting_creator('Hello')\r\n\r\nprint(say_hi('Timur'))\r\nprint(say_hello('Soslan'))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nHi, Timur\r\nHello, Soslan\r\n</strong>\r\n</pre>\r\nПример 2. В этом примере функции make_adder() и multiplier_of() служат фабриками для создания и настройки функций «сумматора» и «мультипликатора». Обратите внимание на то, что вложенные функции add() и mult() могут обращаться к аргументу n своих родительских функций make_adder() и multiplier_of().\r\n<pre>\r\n<strong>\r\ndef make_adder(n):\r\n    def add(x):\r\n        return x + n\r\n    return add\r\n\r\ndef multiplier_of(n):\r\n    def mult(x):\r\n        return x * n\r\n    return mult\r\n</strong>\r\n</pre>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nplus_3 = make_adder(3)\r\nplus_5 = make_adder(5)\r\nmultiply_3 = multiplier_of(3)\r\nmultiply_5 = multiplier_of(5)\r\n\r\nprint(plus_3(10), plus_3(100))\r\nprint(plus_5(10), plus_5(100))\r\nprint(multiply_3(10), multiply_3(100))\r\nprint(multiply_5(10), multiply_5(100))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n13 103\r\n15 105\r\n30 300\r\n50 500\r\n</strong>\r\n</pre>\r\nИмейте в виду, что вложенные функции, которые возвращает родительская функция, могут быть анонимными. Приведенный выше код можно переписать в виде:\r\n<pre>\r\n<strong>\r\ndef make_adder(n):\r\n    return lambda x: x + n\r\n\r\ndef multiplier_of(n):\r\n    return lambda x: x * n\r\n</strong>\r\n</pre>\r\nПример 3. В этом примере функция line_generator() служит фабрикой для создания и настройки линейной функции вида y=kx+b. Обратите внимание на то, что вложенная функция func() может обращаться к аргументам k и b своей родительской функции line_generator().\r\n<pre>\r\n<strong>\r\ndef line_generator(k, b):\r\n    def func(x):\r\n        return k * x + b\r\n    return func\r\n</strong>\r\n</pre>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nline_func_1 = line_generator(2, 5)        # получаем функцию y = 2*x + 5\r\nline_func_2 = line_generator(-6, 9)       # получаем функцию y = -6*x + 9\r\n\r\nprint(line_func_1(10))                    # печатаем значение 2*10 + 5\r\nprint(line_func_2(4))                     # печатаем значение -6*4 + 9\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n25\r\n-15\r\n</strong>\r\n</pre>\r\nОбратите внимание на то, что во всех предыдущих примерах наши вложенные функции (замыкания) использовали нелокальные переменные, которые являлись параметрическими для родительской функции. Вложенные функции могут обращаться ко всем локальным переменным родительской функции, независимо от того, были они определены во внешней функции или пришли из аргументов внешней функции. Параметрические переменные тоже считаются локальными переменными.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndef f(x):\r\n    z = 2\r\n    def g(y):\r\n        return z*x + y    # обращение к нелокальной переменной z и параметрической переменной x\r\n    return g\r\n\r\nh = f(5)\r\nprint(h(1))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n11\r\n</strong>\r\n</pre>\r\n<strong>Нелокальные переменные</strong><br><br>\r\nПри поиске переменной с указанным именем приоритет (правило разрешения имен) следующий:<br><br>\r\n\r\n<li>сначала ищем локальную переменную</li>\r\n<li>если не нашли локальную, ищем нелокальную</li>\r\n<li>если не нашли нелокальную, ищем глобальную</li>\r\n<li>и в самом конце — встроенную в язык</li><br>\r\n<strong>Промежуточная область видимости</strong>, которая доступна вложенным функциям, называется <strong>нелокальной</strong>. Если вложенность функций больше двух уровней, нелокальная переменная ищет в «ближайшей» области видимости, т. е. в функции вложенностью на один меньше. Если не находит, поиск переходит в самую ближнюю из внешних областей видимости, затем в чуть более далекую — и так далее, пока не найдется нужное имя. Фактически интерпретатор ищет там, «где поближе».<br><br>\r\n\r\n<strong>Ключевое слово nonlocal</strong><br><br>\r\nКак мы уже знаем, вложенная функция видит переменные в родительской функции, которые называются нелокальными или свободными переменными.\r\n\r\nРассмотрим следующий код:\r\n<pre>\r\n<strong>\r\ndef outer_function():\r\n    num = 5\r\n    def inner_function():      # определяем вложенную функцию\r\n        num += 10\r\n        print(num)\r\n    inner_function()           # вызываем вложенную функцию\r\n        \r\nouter_function()\r\n</strong>\r\n</pre>\r\nТакой код приводит к возникновению ошибки:\r\n<pre>\r\n<strong>\r\nUnboundLocalError: local variable 'num' referenced before assignment\r\n</strong>\r\n</pre>\r\nДело в том, что вложенная функция не просто обращается (получает значение) к переменной num, но и пытается его изменить! Внутренняя функция видит переменные в объемлющей функции, но, если она хочет такую переменную изменить, должна объявить ее <strong>nonlocal</strong>.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndef outer_function():\r\n    num = 5\r\n    def inner_function():      # определяем вложенную функцию\r\n        nonlocal num\r\n        num += 10\r\n        print(num)\r\n    inner_function()           # вызываем вложенную функцию\r\n        \r\nouter_function()\r\n</strong>\r\n</pre>\r\nвыводит значение:\r\n<pre>\r\n<strong>\r\n15\r\n</strong>\r\n</pre>\r\n\r\n<strong>Атрибут __closure__</strong><br><br>\r\nВсе функции содержат специальный атрибут __closure__, который представляет из себя кортеж, содержащий данные, связанные с вложенными областями видимости, то есть с нелокальными переменными.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndef outer_function(arg):\r\n    num = 5\r\n    name = 'Timur'\r\n    numbers = [1, 2, 3]\r\n    def inner_function():      # определяем вложенную функцию\r\n        print(arg)\r\n        print(num)\r\n        print(numbers)\r\n    return inner_function      # возвращаем вложенную функцию\r\n        \r\ninner = outer_function('python')\r\n\r\nfor var in inner.__closure__:\r\n    print(var.cell_contents)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\npython\r\n5\r\n[1, 2, 3]\r\n</strong>\r\n</pre>\r\nОбратите внимание на то, что кортеж __closure__ содержит внутри себя специальный тип данных. Для получения самого значения захваченной переменной нужно использовать атрибут cell_contents.<br><br>\r\n\r\n<strong>Когда использовать замыкания</strong><br><br>\r\nКонцепция замыканий, то есть функций, захватывающих нелокальные переменные, находят много применений при написании кода. Замыкания хороши для:<br><br>\r\n\r\n<li>воздержания от жестко закодированных констант</li>\r\n<li>воздержания от использования глобальных переменных</li>\r\n<li>воздержания от создания ненужных типов данных (классов)</li>\r\n<li>замыкания нужны для реализации декораторов, о которых мы поговорим чуть позже</li>\r\n<li>Сокрытие данных основное преимущество замыканий.</li><br>\r\n\r\nВложенные (внутренние) функции позволяют избавиться от глобальных переменных. Такая техника позволяет сделать внешнюю для функции переменную, но при этом спрятанную от посторонних глаз, в отличие от глобальной. Такие переменные нужны в первую очередь для того, чтобы хранить какие-то данные, относящиеся к функции, между вызовами функции. Локальные переменные стираются при выходе из функции, глобальные — сохраняются, но видны всему свету, а нелокальные — идеальное сочетание закрытости и «сохраняемости».<br><br>\r\n\r\nЕсли функция использует глобальные переменные, это тоже замыкание. Но чаще всего замыканием называют все-таки функцию, которая использует нелокальные переменные. Такая функция как бы «таскает за собой» свои внешние переменные, но никому их не показывает.",
    "slug": "functions-closures"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 22,
  "fields": {
    "lesson": "Аннотации типов",
    "content": "<strong>Аннотации типов</strong><br><br>\r\nРаньше на Python писали в основном небольшие скрипты, но в последнее время язык стал значительно популярнее и сегодня на Python написано много сложных систем из сотен тысяч строк кода. В таких обстоятельствах документирующее свойство системы типов становится очень полезным. В достаточно крупной кодовой базе при отсутствии информации о типах очень сложно угадать, какие именно объекты используются в программе.<br><br>\r\n\r\nПо этим соображениям, в Python 3.5 появились <strong>аннотации типов</strong>, которые представляют собой специальный синтаксис для объявления типов параметров функций и их возвращаемых значений (PEP 484). В Python 3.6 эта возможность была расширена — стало можно объявлять типы переменных вообще в любом месте программы (PEP 526). С каждой новой версией языка эта функциональность улучшается, и писать аннотации типов становится всё проще, удобнее и естественнее.<br><br>\r\n\r\nНужно отметить, что аннотации типов — это именно возможность, а не обязанность. У программиста есть выбор — добавлять информацию о типах или нет. Таким образом Python пытается усидеть на двух стульях — остаться языком с динамической типизацией и дать возможность для статического анализа написанных программ.<br><br>\r\n\r\nПрограммист при написании кода расставляет информацию о типах переменных, параметров и возвращаемых значений функций. Это никак не влияет на выполнение программы. Python сам по себе никак не использует эту информацию, он лишь перекладывает её в специальные атрибуты функций или переменных, делая доступной для сторонних утилит. То есть, если указано, что функция принимает строковый аргумент, то это никак не помешает вызвать её с целым числом или списком — в зависимости от тела функции, она может отработать, а может завершиться ошибкой, но сама возможность вызова с любыми типами аргументов никак не ограничивается.<br><br>\r\n\r\n<strong>Простые типы</strong><br><br>\r\nРассмотрим определение функции greet(), которая по задумке принимает строковый аргумент name и возвращает строковое значение приветствия:\r\n<pre>\r\n<strong>\r\ndef greet(name):\r\n    return f'Hello {name}!'\r\n</strong>\r\n</pre>\r\nС помощью аннотаций типов можем переписать функцию в виде:\r\n<pre>\r\n<strong>\r\ndef greet(name: str) -> str:\r\n    return f'Hello {name}!'\r\n</strong>\r\n</pre>\r\nКак мы видим, типы параметров, записываются после имени параметра через знак двоеточия, а тип возвращаемого значения функции записывается после знака \"стрелки\". Теперь программист просто взглянув на сигнатуру функции может понять, что функция принимает строку и возвращает строку. При этом можно понять, что если передать в неё другой тип, то она не сможет корректно отработать.<br><br>\r\n\r\nЕсли некоторый аргумент имеет значение по умолчанию, то его тип должен предшествовать значению по умолчанию:\r\n<pre>\r\n<strong>\r\ndef greet(name: str = 'world') -> str:\r\n    return f'Hello, {name}!'\r\n</strong>\r\n</pre>\r\nТочно так же можно использовать и любые другие базовые (не являющиеся коллекциями) типы в Python:  int,  float,  bool,  str,  NoneType.\r\n\r\nПриведем несколько примеров.<br><br>\r\n\r\nПример 1. Функция print_hello() принимает два аргумента типа str и bool и возвращает значение None.\r\n<pre>\r\n<strong>\r\ndef print_hello(name: str, upper: bool = False) -> None:\r\n    if upper:\r\n        name = name.upper()\r\n    print(f'Hello, {name}')\r\n</strong>\r\n</pre>\r\nПример 2. Функция avg() принимает три аргумента типа int и возвращает значение float:\r\n<pre>\r\n<strong>\r\ndef avg(num1: int, num2: int, num3: int) -> float:\r\n    return (num1 + num2 + num3) / 3\r\n</strong>\r\n</pre>\r\nКак уже было сказано выше, помимо специального синтаксиса для объявления параметров функций и их возвращаемых значений в Python 3.6 стало можно объявлять типы переменных вообще в любом месте программы.<br><br>\r\n\r\nВот так можно добавить аннотации типов к переменным в любом месте кода (Python 3.6+):\r\n<pre>\r\n<strong>\r\nname: str = 'Timur'\r\nage: int = 29\r\nheight: float = 171.5\r\nis_married: bool = False\r\n</strong>\r\n</pre>\r\n\r\nМожно также аннотировать переменные, не назначая им сразу значения:\r\n<pre>\r\n<strong>\r\nsurname: str\r\ngender: bool\r\n</strong>\r\n</pre>\r\n<strong>Типы коллекции</strong><br><br>\r\nПерейдем к более сложным типам, таким как списки, кортежи, словари и множества. Можно добавлять аннотации типов, используя сами имена классов list, tuple, set, dict:\r\n<pre>\r\n<strong>\r\ndef sum_square(nums: list) -> int:\r\n    total = 0\r\n    for i in nums:\r\n        total += i ** 2\r\n    return total\r\n</strong>\r\n</pre>\r\nЭто не слишком информативно, потому что кроме самого типа list было бы ещё полезно знать, какие данные он в себе содержит. В нашем примере непонятно, списком каких типов является параметр nums.\r\n\r\nВ приведенном ниже коде:\r\n<pre>\r\n<strong>\r\nnumbers: list\r\nperson: tuple\r\nprices: dict\r\nanswers: set\r\n</strong>\r\n</pre>\r\nтакже неизвестно, какие данные должны храниться в коллекциях numbers, person, prices и answers.<br><br>\r\n\r\n<strong>В Python до версии 3.9</strong> для этого придётся использовать отдельные типы из модуля typing. Делается это при помощи квадратных скобок:\r\n<pre>\r\n<string>\r\nfrom typing import List\r\n\r\ndef sum_square(nums: List[int]) -> int:\r\n    total = 0\r\n    for i in nums:\r\n        total += i ** 2\r\n    return total\r\n</strong>\r\n</pre>\r\nили \r\n<pre>\r\n<strong>\r\nfrom typing import List, Tuple, Dict, Set\r\n\r\nnumbers: List[int]                                # тип всех элементов списка\r\nperson: Tuple[str, int, bool]                     # тип каждого элемента кортежа\r\nprices: Dict[str, int]                            # тип ключей, тип значений\r\nanswers: Set[float]                               # тип всех элементов множества\r\n</strong>\r\n</pre>\r\nОбратите внимание на то, что типы из модуля typing указываются с заглавной буквы.<br><br>\r\n\r\n<strong>Начиная с Python 3.9</strong> можно использовать стандартные классы в точно таких же целях, ничего ниоткуда не импортируя:\r\n<pre>\r\n<strong>\r\nnumbers: list[int]                                # тип всех элементов списка\r\nperson: tuple[str, int, bool]                     # тип каждого элемента кортежа\r\nprices: dict[str, int]                            # тип ключей, тип значений\r\nanswers: set[float]                               # тип всех элементов множества\r\n</strong>\r\n</pre>\r\n\r\n<strong>Атрибут __annotations__</strong><br><br>\r\nДоступ к использованным в функции аннотациям можно получить через атрибут __annotations__, в котором аннотации представлены в виде словаря, где ключами являются названия параметров, а значениями – их типы. При этом, возвращаемое функцией значение хранится в записи с ключом return.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndef avg(num1: int, num2: int, num3: int) -> float:\r\n    return (num1 + num2 + num3) / 3\r\n\r\nprint(avg.__annotations__)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n{'num1': <class 'int'>, 'num2': <class 'int'>, 'num3': <class 'int'>, 'return': <class 'float'>}\r\n</strong>\r\n</pre>\r\n\r\n<strong>Полезные типы модуля typing</strong><br><br>\r\nМногие типы из модуля typing позволяют работать с несколькими типами одновременно. К наиболее часто используемым типам модуля typing относятся:<br><br>\r\n\r\n<li>Union</li>\r\n<li>Optional</li>\r\n<li>Any</li>\r\n<li>NoReturn</li><br><br>\r\n\r\n<strong>Тип Union</strong><br><br>\r\nЧасто возникает ситуация, когда нужно объединить несколько типов, например, для того, чтобы указать, что функция может принимать и целые и вещественные числа. Этого можно достичь при помощи специального типа Union из модуля typing.<br><br>\r\n\r\nФункция add_or_concatenate() должна принимать аргументы типов int, float, str и возвращает один из трех типов int, float, str:\r\n<pre>\r\n<strong>\r\nfrom typing import Union\r\n\r\ndef add_or_concatenate(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str]:\r\n    return a + b\r\n</strong>\r\n</pre>\r\nПриведенный выше код можно записать в виде:\r\n<pre>\r\n<strong>\r\nfrom typing import Union\r\n\r\nNumberOrStr = Union[int, float, str]\r\n\r\ndef add_or_concatenate(a: NumberOrStr, b: NumberOrStr) -> NumberOrStr:\r\n    return a + b\r\n</strong>\r\n</pre>\r\nОсобенности типа Union:<br><br>\r\n\r\n<li>аргументы указываемые в квадратных скобках должны быть типами, причем необходимо указать хотя бы один тип</li>\r\n<li>запись Union[Union[int, str], float] эквивалентна записи Union[int, str, float]</li>\r\n<li>запись Union[int] эквивалентна записи int</li>\r\n<li>запись Union[int, str, int] эквивалентна записи Union[int, str]</li>\r\n<li>запись Union[int, str] эквивалентна записи Union[str, int]</li><br><br>\r\n\r\n<strong>Тип Optional</strong><br><br>\r\nТакже очень часто возникает ситуация, когда возможно либо значение определенного типа, либо None. Мы можем использовать тип Union следующим образом:\r\n<pre>\r\n<strong>\r\nfrom typing import Union\r\n\r\nname: Union[str, None]\r\n</strong>\r\n</pre>\r\nОднако это настолько частая ситуация, что для этого даже сделали отдельный тип Optional:\r\n<pre>\r\n<strong>\r\nfrom typing import Optional\r\n\r\nname: Optional[str]\r\n</strong>\r\n</pre>\r\nПо сути name: Union[str, None] и name: Optional[str] это одно и то же, но второй вариант читается проще.<br><br>\r\n\r\n<strong>Тип Any</strong><br><br>\r\nМожет возникнуть ситуация, когда не получается указать какой-либо конкретный тип, потому что, функция может принимать на вход абсолютно что угодно. Для этих случаев тоже есть специальный тип Any:\r\n<pre>\r\n<strong>\r\nfrom typing import Any\r\n\r\ndef func(arg: Any) -> Any:\r\n    return arg\r\n</strong>\r\n</pre>\r\nТаким образом любой тип совместим с типом Any, как и Any совместим с любым типом.\r\n\r\nОчень соблазнительно везде вставлять тип Any, но настоятельно рекомендуется использовать его только в крайних случаях, потому что чрезмерное его использование сводит пользу от аннотаций типов на нет.<br><br>\r\n\r\n<strong>Тип NoReturn</strong><br><br>\r\nСпециальный тип NoReturn указывает, что функция никогда не возвращает значение:\r\n<pre>\r\n<strong>\r\nfrom typing import NoReturn\r\n\r\ndef stop() -> NoReturn:\r\n    raise RuntimeError('no way')\r\n</strong>\r\n</pre>\r\nНе путайте тип NoReturn с типом None, который указывает на то, что функция возвращает конкретное значение — None.",
    "slug": "type-hiting"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 23,
  "fields": {
    "lesson": "Декораторы",
    "content": "<strong>Определение декоратора</strong><br><br>\r\nИногда нам нужно модифицировать существующую функцию, не меняя при этом ее исходный код.\r\n\r\n<strong>Декоратор</strong> — это функция, которая принимает другую функцию, расширяет ее поведение, не изменяя ее явно, и возвращает новую функцию.<br><br>\r\n\r\nПрежде чем понять, как работают декораторы и начать создавать их, вспомним некоторые важные особенности функций:<br><br>\r\n\r\n<li>функции являются объектами первого класса, то есть функции можно передавать и использовать в качестве аргументов;</li>\r\n<li>функции можно определять внутри других функций;</li>\r\n<li>вложенные функции могут использовать локальные переменные родительских функций;</li>\r\n<li>функции могут возвращать другие функции в качестве результата.</li><br>\r\n\r\nТеперь, владея этими знаниями, создадим простой декоратор null_decorator(), который возвращает исходную функцию без каких-либо изменений:\r\n<pre>\r\n<strong>\r\ndef null_decorator(func):\r\n    return func\r\n</strong>\r\n</pre>\r\nКак мы видим, null_decorator() — это функция высшего порядка, которая принимает другую функцию в качестве аргумента и возвращает эту же функцию, не изменяя ее.\r\n\r\nПрименим данный декоратор для декорирования функции say().\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndef say():\r\n    print('Привет Мир!')\r\n\r\nsay = null_decorator(say)      # декорируем функцию\r\n\r\nsay()                          # вызываем декорированную функцию\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nПривет Мир!\r\n</strong>\r\n</pre>\r\nПриведенный выше null_decorator() пока что не выглядит особо полезным, однако можно написать более интересный декоратор, который меняет поведение декорируемой функции.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndef sample_decorator(func):          # определяем декоратор\r\n    def wrapper():\r\n        print('Начало функции')\r\n        func()\r\n        print('Конец функции')\r\n    return wrapper\r\n\r\ndef say():\r\n    print('Привет Мир!')\r\n\r\nsay = sample_decorator(say)          # декорируем функцию\r\n\r\nsay()                                # вызываем декорированную функцию\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nНачало функции\r\nПривет Мир!\r\nКонец функции\r\n</strong>\r\n</pre>\r\nЗдесь sample_decorator() является функцией-декоратором. Как можно заметить, она является функцией высшего порядка, так как принимает функцию в качестве аргумента, а также возвращает функцию. Внутри sample_decorator() мы определили другую функцию — обёртку, которая обёртывает передаваемую функцию say() и затем изменяет её поведение. Декоратор возвращает эту обёртку.\r\n\r\nДекорирование функции say() происходит в следующей строке:\r\n<pre>\r\n<strong>\r\nsay = sample_decorator(say)\r\n</strong>\r\n</pre>\r\nПосле декорирования переменная say указывает на внутреннюю функцию wrapper(). Важно понимать то, что при вызове функции sample_decorator(say) с переданной в качестве аргумента функцией say() возвращается вложенная функция wrapper() в качестве результата. Функция wrapper(), в свою очередь, имеет ссылку на переданную в качестве аргумента функцию say() и вызывает эту функцию между двумя вызовами встроенной функции print().\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(say)                         # до декорирования\r\nsay = sample_decorator(say)\r\nprint(say)                         # после декорирования\r\n</strong>\r\n</pre>\r\nвыводит (адрес может отличаться):\r\n<pre>\r\n<strong>\r\n<function say at 0x00000122AD3F0F70>\r\n<function sample_decorator.<locals>.wrapper at 0x00000122AD3F1090>\r\n</strong>\r\n</pre>\r\nТаким образом, после декорирования мы получаем совершено другую функцию, которая расширяет функционал начальной функции.\r\n\r\nПроще говоря: декораторы обертывают функцию, изменяя ее поведение.<br><br>\r\n\r\n\r\n<strong>Специальный синтаксис применения декораторов</strong><br><br>\r\nСпособ, который декорирует функцию say(), — многословен, приходится набирать имя функции несколько раз. Кроме того, декорирование скрывается под определением функции. Вместо этого Python позволяет использовать декораторы более простым способом с помощью символа @.\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndef null_decorator(func):\r\n    return func\r\n\r\ndef say():\r\n    print('Привет Мир!')\r\n\r\nsay = null_decorator(say)            # декорируем функцию\r\n\r\nsay()\r\n</strong>\r\n</pre>\r\nможно переписать в виде:\r\n<pre>\r\n<strong>\r\ndef null_decorator(func):\r\n    return func\r\n\r\n@null_decorator                      # декорируем функцию\r\ndef say():\r\n    print('Привет Мир!')\r\n\r\nsay()\r\n</strong>\r\n</pre>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndef sample_decorator(func):          # определяем декоратор\r\n    def wrapper():\r\n        print('Начало функции')\r\n        func()\r\n        print('Конец функции')\r\n    return wrapper\r\n\r\ndef say():\r\n    print('Привет Мир!')\r\n\r\nsay = sample_decorator(say)          # декорируем функцию\r\n\r\nsay()                                # вызываем декорированную функцию\r\n</strong>\r\n</pre>\r\nможно переписать в виде:\r\n<pre>\r\n<strong>\r\ndef sample_decorator(func):          # определяем декоратор\r\n    def wrapper():\r\n        print('Начало функции')\r\n        func()\r\n        print('Конец функции')\r\n    return wrapper\r\n\r\n@sample_decorator                    # декорируем функцию\r\ndef say():\r\n    print('Привет Мир!')\r\n\r\nsay()\r\n</strong>\r\n</pre>\r\nПросто добавив @sample_decorator перед определением функции say(), мы модифицировали её поведение. Однако, как вы уже могли догадаться, запись с @ является всего лишь синтаксическим сахаром для записи:\r\n<pre>\r\n<strong>\r\nsay = sample_decorator(say)\r\n</strong>\r\n</pre>\r\nИными словами, выражение @sample_decorator вызывает функцию sample_decorator() с say в качестве аргумента и присваивает имени say возвращаемую функцию.<br><br>\r\n\r\nОбратите внимание, что использование синтаксиса @ декорирует функцию сразу во время определения. Это затрудняет доступ к недекорированной функции. Поэтому мы можем декорировать некоторые функции вручную, чтобы сохранить возможность вызывать и недекорированную версию функции.<br><br>\r\n\r\n<strong>Изменение поведения функции</strong><br><br>\r\nДекоратор может менять поведение декорируемой функции. Напишем декоратор, который преобразует строковый результат декорированной функции в верхний регистр.\r\n<pre>\r\n<strong>\r\ndef uppercase_decorator(func):\r\n    def wrapper():\r\n        original_result = func()\r\n        modified_result = original_result.upper()\r\n        return modified_result\r\n\r\n    return wrapper\r\n</strong>\r\n</pre>\r\nВместо того чтобы просто возвращать исходную функцию, как это делал null_decorator(), декоратор uppercase_decorator() определяет и возвращает новую функцию wrapper(). Функция wrapper(), являясь замыканием, имеет доступ к недекорированной функции func и может выполнять дополнительный код до и после вызова функции func.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\n@uppercase_decorator\r\ndef greet():\r\n    return 'Hello world!'\r\n\r\nprint(greet())\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nHELLO WORLD!\r\n</strong>\r\n</pre>\r\nВ отличие от null_decorator(), наш новый декоратор uppercase_decorator() возвращает другой объект функции, в чем несложно убедиться.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndef greet():\r\n    return 'Hello world!'\r\n\r\nprint(greet)\r\ngreet = uppercase_decorator(greet)     # ручное декорирование\r\nprint(greet)\r\n</strong>\r\n</pre>\r\nвыводит (адрес может отличаться):\r\n<pre>\r\n<strong>\r\n<function greet at 0x000001CF72B40F70>\r\n<function uppercase_decorator.<locals>.wrapper at 0x000001CF72B41090>\r\n</strong>\r\n</pre>\r\nДекоратор uppercase_decorator() сам по себе является функцией. Единственный способ повлиять на новое поведение функции, которую он декорирует, — это заменить исходную функцию замыканием. Вот почему декоратор uppercase_decorator() определяет и возвращает другую функцию wrapper(), которую затем можно вызвать позже, запустить исходную функцию и изменить ее результат.<br><br>\r\n\r\n<strong>Применение нескольких декораторов</strong><br><br>\r\nМы можем без каких-либо проблем применять к функции несколько различных декораторов. Это накапливает их эффекты, и делает декораторы очень полезными на практике. Декораторы применяются в порядке снизу вверх.<br><br>\r\n\r\nГлубокие уровни наложения декораторов в итоге могут повлиять на производительность, поскольку они продолжают добавлять вложенные вызовы функций. Обычно на практике это не создает проблем, но об этом следует помнить, если вы работаете с кодом, требующим высокой производительности.<br><br>\r\n\r\n<strong>Декорирование функций, принимающих аргументы</strong>\r\nИзменим функцию greet() так, чтобы она принимала аргумент name:\r\n<pre>\r\n<strong>\r\ndef greet(name):\r\n    return f'Hello {name}!'\r\n</strong>\r\n</pre>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(greet('Timur'))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nHello Timur!\r\n</strong>\r\n</pre>\r\nПопробуем применить наш декоратор bold() к новой функции greet().\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\n@bold\r\ndef greet(name):\r\n    return f'Hello {name}!'\r\n\r\nprint(greet('Timur'))\r\n</strong>\r\n</pre>\r\nприводит к возникновению ошибки:\r\n<pre>\r\n<strong>\r\nTypeError: bold.<locals>.wrapper() takes 0 positional arguments but 1 was given\r\n</strong>\r\n</pre>\r\nПроблема в том, что внутренняя функция wrapper() не принимает никаких аргументов, а мы пытались ей передать один аргумент Timur. Эту проблему можно исправить, позволив wrapper() принять один аргумент, но тогда она не будет работать для функций, которые не принимают аргументов или принимают больше одного аргумента.<br><br>\r\n\r\nРешение заключается в использовании *args и **kwargs во внутренней функции, что позволит ей принимать произвольное число позиционных и именованных аргументов:\r\n<pre>\r\n<strong>\r\ndef bold(func):\r\n    def wrapper(*args, **kwargs):\r\n        return 'b' + func(*args, **kwargs) + 'b'\r\n\r\n    return wrapper\r\n</strong>\r\n</pre>\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\n@bold\r\ndef greet1(name):\r\n    return f'Hello {name}!'\r\n\r\n@bold\r\ndef greet2():\r\n    return 'Hello world!'\r\n\r\n@bold\r\ndef greet3(name, surname):\r\n    return f'Hello {name} {surname}!'\r\n\r\nprint(greet1('Timur'))\r\nprint(greet2())\r\nprint(greet3('Timur', 'Guev'))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nbHello Timur!b\r\nbHello world!b\r\nbHello Timur Guev!b\r\n</strong>\r\n</pre>\r\nВ примере выше вложенная функция wrapper() принимает произвольное число позиционных и именованных аргументов и передает их в декорируемую функцию func(). Теперь декоратор @bold будет работать как для функций, которые вообще не принимают аргументы, так и для функций которые принимают произвольное количество позиционных и именованных аргументов.<br><br>\r\n\r\n<strong>Возврат значений из декорируемой функции</strong><br><br>\r\nВ Python все функции возвращают значение. Даже если тело функции не содержит явно инструкции return, она вернет значение None. Нужно быть очень внимательным к декорированию функций, которые возвращают значения, которые затем используются.\r\n\r\nДопустим, мы написали следующий декоратор:\r\n<pre>\r\n<strong>\r\ndef talk(func):\r\n    def wrapper(*args, **kwargs):\r\n        dash = '-' * 15\r\n        print(dash)\r\n        func(*args, **kwargs)           # вызываем декорируемую функцию\r\n        print(dash)\r\n\r\n    return wrapper\r\n</strong>\r\n</pre>\r\nИ мы хотим декорировать простую функцию, которая возвращает значение:\r\n<pre>\r\n<strong>\r\n@talk\r\ndef greet(name):\r\n    return f'Hello {name}!'\r\n</strong>\r\n</pre>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nprint(greet('Timur'))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n---------------\r\n---------------\r\nNone\r\n</strong>\r\n</pre>\r\nДекоратор съел возвращаемое значение из функции greet(), так как вложенная функция wrapper() явно не возвращает какого-либо значения, и в итоге вызов декорируемой функции greet('Timur') в примере выше вернул значение None.<br><br>\r\n\r\nЧтобы исправить этот недочет, необходимо сделать так, чтобы вложенная функция wrapper() возвращала задекорированное значение, которое, в свою очередь, возвращает функция. Изменим декоратор talk() следующим образом:\r\n<pre>\r\n<strong>\r\ndef talk(func):\r\n    def wrapper(*args, **kwargs):\r\n        dash = '-' * 15\r\n        result = func(*args, **kwargs)\r\n        return dash + '\\n' + result + '\\n' + dash\r\n\r\n    return wrapper\r\n</strong>\r\n</pre>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\n@talk\r\ndef greet(name):\r\n    return f'Hello {name}!'\r\n\r\nprint(greet('Timur'))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n---------------\r\nHello Timur!\r\n---------------\r\n</strong>\r\n</pre>\r\nТеперь декоратор работает так, как и ожидалось.<br><br>\r\n\r\n<strong>Сохранение атрибутов __name__ и __doc__ для декорируемой функции</strong><br><br>\r\nКак мы уже знаем, все функции содержат специальные атрибуты __name__ и __doc__, которые содержат полезную информацию:<br><br>\r\n\r\n<li>__name__ — имя функции</li>\r\n<li>__doc__ — строка документации</li><br>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndef greet(name):\r\n    '''Функция приветствия пользователя.'''\r\n    return f'Hello {name}!'\r\n\r\nprint(greet.__name__)\r\nprint(greet.__doc__)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\ngreet\r\nФункция приветствия пользователя.\r\n</strong>\r\n</pre>\r\nРассмотрим применение декоратора bold к функции greet().\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndef bold(func):\r\n    def wrapper(*args, **kwargs):\r\n        return '<b>' + func(*args, **kwargs) + '</b>'\r\n    return wrapper\r\n\r\n@bold\r\ndef greet(name):\r\n    '''Функция приветствия пользователя.'''\r\n    return f'Hello {name}!'\r\n\r\nprint(greet.__name__)\r\nprint(greet.__doc__)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nwrapper\r\nNone\r\n</strong>\r\n</pre>\r\nПосле того как к функции greet() был применен декоратор, её атрибуты __name__ и __doc__ изменились на имя и строку документации внутренней функции wrapper() декоратора bold. Хотя чисто технически это верно, это не очень хорошо.\r\n\r\nОдно из решений такой проблемы выглядит следующим образом:\r\n<pre>\r\n<strong>\r\ndef bold(func):\r\n    def wrapper(*args, **kwargs):\r\n        return '<b>' + func(*args, **kwargs) + '</b>'\r\n    wrapper.__name__ = func.__name__\r\n    wrapper.__doc__ = func.__doc__\r\n    return wrapper\r\n\r\n@bold\r\ndef greet(name):\r\n    '''Функция приветствия пользователя.'''\r\n    return f'Hello {name}!'\r\n\r\nprint(greet.__name__)\r\nprint(greet.__doc__)\r\n</strong>\r\n</pre>\r\nТакой код выводит:\r\n<pre>\r\n<strong>\r\ngreet\r\nФункция приветствия пользователя.\r\n</strong>\r\n</pre>\r\nТеперь у функции greet() атрибуты __name__ и __doc__ не перетираются после применения декоратора.<br><br>\r\n\r\n<strong>Применение декоратора functools.wraps</strong><br><br>\r\nРешение проблемы связанное с перетиранием атрибутов __name__ и __doc__ является рабочим, однако каждый раз писать в декораторе строки кода, которые восстанавливают значения данных атрибутов, не очень хорошо.<br><br>\r\n\r\nДля решения проблемы перетирания данных атрибутов на практике используют другой декоратор, который находится в модуле functools и называется wraps. Таким образом, чтобы предотвратить перетирание атрибутов __name__ и __doc__ декорируемой функции, декораторы должны использовать декоратор functools.wraps, который сохраняет информацию о первоначальной функции.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport functools\r\n\r\ndef bold(func):\r\n    @functools.wraps(func)\r\n    def wrapper(*args, **kwargs):\r\n        return '<b>' + func(*args, **kwargs) + '</b>'\r\n    return wrapper\r\n\r\n@bold\r\ndef greet(name):\r\n    '''Функция приветствие пользователя.'''\r\n    return f'Hello {name}!'\r\n\r\nprint(greet.__name__)\r\nprint(greet.__doc__)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\ngreet\r\nФункция приветствие пользователя.\r\n</strong>\r\n</pre>\r\nТеперь у функции greet() атрибуты __name__ и __doc__ не перетираются после применения декоратора bold.<br><br>\r\n\r\n<strong>Шаблон декоратора общего назначения</strong><br><br>\r\nВсе декораторы в большинстве случаев делают примерно одно и то же. Наиболее частый шаблон декоратора выглядит следующим образом:\r\n<pre>\r\n<strong>\r\nimport functools\r\n\r\ndef decorator(func):\r\n    @functools.wraps(func)\r\n    def wrapper(*args, **kwargs):\r\n        # Что-то выполняется до вызова декорируемой функции\r\n        value = func(*args, **kwargs)\r\n        # декорируется возвращаемое значение функции\r\n        # или что-то выполняется после вызова декорируемой функции\r\n        return value\r\n    return wrapper\r\n</strong>\r\n</pre>\r\n На основе этого шаблона можно строить декораторы общего назначения.",
    "slug": "decorators-functions"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 24,
  "fields": {
    "lesson": "Типы данных date и time",
    "content": "<strong>Тип данных date</strong><br><br>\r\nТип данных (класс) date используется для представления данных о дате и включает информацию о годе, месяце и дне. Чтобы иметь возможность использовать этот тип данных, необходимо предварительно его импортировать из модуля datetime:\r\n<pre>\r\n<strong>\r\nfrom datetime import date\r\n</strong>\r\n</pre>\r\nПри создании новой даты (тип данных date) нужно указать год, месяц и день.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import date\r\n\r\nmy_date = date(1992, 10, 6)    # тип date: год + месяц + день\r\n\r\nprint(my_date)\r\nprint(type(my_date))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n1992-10-06\r\nclass 'datetime.date'\r\n</strong>\r\n</pre>\r\nКонструктор типа date сначала принимает год, затем месяц, а уже потом день. Мы также можем использовать именованные аргументы, нарушая указанный порядок date(day=6, month=10, year=1992).<br><br>\r\n\r\nУказывая аргументы day, month, year, не следует забывать про ограничения. К примеру, нельзя указать значение day, большее 31, или значение month, большее 12.<br><br>\r\n\r\nИногда приходится работать не только с общими сведениями о дате, но и с отдельными ее составляющими, такими как год, месяц или день. Получить доступ к ним можно с помощью атрибутов:<br><br>\r\n\r\n<li>year — год даты</li>\r\n<li>month — месяц даты</li>\r\n<li>day — день даты</li><br>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import date\r\n\r\nmy_date = date(1992, 10, 6)\r\n\r\nprint('Год =', my_date.year)\r\nprint('Месяц =', my_date.month)\r\nprint('День =', my_date.day)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nГод = 1992\r\nМесяц = 10\r\nДень = 6\r\n</strong>\r\n</pre>\r\nЕсли необходимо получить информацию о текущей дате на компьютере, на котором выполняется программа, то используется встроенный <strong>метод today()</strong>.\r\n\r\nПриведенный ниже код вычисляет дату написания этого урока 😀:\r\n<pre>\r\n<strong>\r\nfrom datetime import date\r\n\r\ncreation_date = date.today()\r\nprint(creation_date)\r\n</strong>\r\n</pre>\r\nи выводит:\r\n<pre>\r\n<strong>\r\n2021-08-09\r\n</strong>\r\n</pre>\r\nС помощью встроенного <strong>метода weekday()</strong> можно определить день недели (нумерация начинается с 0):\r\n<pre>\r\n<strong>\r\n0 = понедельник\r\n1 = вторник\r\n2 = среда\r\n3 = четверг\r\n4 = пятница\r\n5 = суббота\r\n6 = воскресенье\r\n</strong>\r\n</pre>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import date\r\n\r\ndate1 = date(2022, 10, 15)\r\ndate2 = date(1999, 12, 26)\r\n\r\nprint(date1.weekday())\r\nprint(date2.weekday())\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n5      # суббота\r\n6      # воскресенье\r\n</strong>\r\n</pre>\r\nЕсли требуется определить день недели с нумерацией, начиная с 1, то используется <strong>метод isoweekday()</strong>.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import date\r\n\r\ndate1 = date(2022, 10, 15)\r\ndate2 = date(1999, 12, 26)\r\n\r\nprint(date1.isoweekday())\r\nprint(date2.isoweekday())\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n6      # суббота\r\n7      # воскресенье\r\n</strong>\r\n</pre>\r\nДля получения минимально и максимально возможных дат (в рамках типа данных date) используются <strong>атрибуты min и max</strong>.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import date\r\n\r\nprint(date.min)\r\nprint(date.max)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n0001-01-01\r\n9999-12-31\r\n</strong>\r\n</pre>\r\n<strong>Методы fromordinal() и toordinal()</strong> позволяют создать дату из номера дня, начиная с 0001-01-01, и наоборот, преобразовать дату в номер дня.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import date\r\n\r\ndate1 = date.fromordinal(365)     # дата, соответствуюшая номеру дня 365\r\ndate2 = date(1999, 12, 26)\r\n\r\nprint(date1)\r\nprint(date2.toordinal())          # номер дня, соответствующий дате 1999-12-26\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n0001-12-31\r\n730114\r\n</strong>\r\n</pre>\r\n\r\n<strong>Тип данных time</strong><br><br>\r\nТип данных (класс) time используется для представления данных о времени и включает информацию о часах, минутах, секундах и микросекундах. Данный тип данных полностью игнорирует информацию о дате.<br><br>\r\n\r\nПри создании времени (тип данных time) нужно указать часы, минуты, секунды и микросекунды.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import time\r\n\r\nmy_time = time(11, 20, 54, 1234)    # тип time: часы + минуты + секунды + микросекунды\r\n\r\nprint(my_time)\r\nprint(type(my_time))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n11:20:54.001234\r\nclass 'datetime.time'\r\n</strong>\r\n</pre>\r\nКонструктор типа time сначала принимает часы, затем минуты, секунды, а уже потом микросекунды. Мы можем использовать именованные аргументы (hour, minute, second, microsecond), нарушая указанный порядок. <br><br>\r\n\r\nУказывая аргументы hour, minute, second, microsecond, не следует забывать про ограничения. К примеру, нельзя указать значение hour, большее 23, или значение second, большее 59.<br><br>\r\n\r\nВ отличие от дат (тип данных date), чтобы создать объект типа time, необязательно указывать все его атрибуты в конструкторе. Недостающие данные о времени автоматически заполняются нулями.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import time\r\n\r\ntime1 = time(11, 20, 54, 1234)\r\ntime2 = time(11, 20, 54)\r\ntime3 = time(11, 20)\r\ntime4 = time(11)\r\ntime5 = time()\r\ntime6 = time(minute=23, second=56)\r\n\r\nprint(time1, time2, time3, time4, time5, sep='\\n')\r\nprint(time6)\r\n</strong>\r\n</pre>\r\n выводит:\r\n<pre>\r\n<strong>\r\n11:20:54.001234\r\n11:20:54\r\n11:20:00\r\n11:00:00\r\n00:00:00\r\n00:23:56\r\n</strong>\r\n</pre>\r\nТак же, как и при работе с типом данных date, пользуясь типом time, можно получать доступ к отдельным значениям созданного времени: часам, минутам, секундам и микросекундам. Получить доступ к ним можно с помощью атрибутов:<br><br>\r\n\r\n<li>hour — часы времени</li>\r\n<li>minute — минуты времени</li>\r\n<li>second — секунды времени</li>\r\n<li>microsecond — микросекунды времени</li><br>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import time\r\n\r\nmy_time = time(11, 20, 54, 1234)\r\n\r\nprint('Часы =', my_time.hour)\r\nprint('Минуты =', my_time.minute)\r\nprint('Секунды =', my_time.second)\r\nprint('Микросекунды =', my_time.microsecond)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nЧасы = 11\r\nМинуты = 20\r\nСекунды = 54\r\nМикросекунды = 1234\r\n</strong>\r\n</pre>\r\n\r\n<strong>Сравнение дат и времени</strong><br><br>\r\nДату (тип date) и время (тип time) можно сравнивать с помощью операторов ==, !=, <, >, <= и  >=.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import date, time\r\n\r\ndate1 = date(2022, 10, 15)\r\ndate2 = date(1999, 12, 26)\r\n\r\ntime1 = time(13, 10, 5)\r\ntime2 = time(21, 32, 59)\r\n\r\nprint(date1 < date2)\r\nprint(time1 < time2)\r\n</strong>\r\n</pre>\r\nвыводит\r\n<pre>\r\n<strong>\r\nFalse\r\nTrue\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функции str() и repr()</strong><br><br>\r\nНа практике часто используются две встроенные функции str() и repr(). С их помощью можно получить строковое представление объекта.<br><br>\r\n\r\nВстроенная <strong>функция str()</strong> возвращает объект в неформальном (понятном человеку) строковом представлении.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import date, time\r\n\r\nmy_date = date(2021, 12, 31)\r\nmy_time = time(11, 20, 54)\r\n\r\nprint(my_date)\r\nprint(my_time)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n2021-12-31\r\n11:20:54\r\n</strong>\r\n</pre>\r\nПо сути мы наблюдаем результат работы функции str(), которая вызывается за кулисами и преобразует указанные объекты в читаемый для человека вид.<br><br>\r\n\r\nПриведенный ниже код использует явный вызов функции str() и идентичен коду выше.\r\n<pre>\r\n<strong>\r\nfrom datetime import date, time\r\n\r\nmy_date = date(2021, 12, 31)\r\nmy_time = time(11, 20, 54)\r\n\r\nprint(str(my_date))\r\nprint(str(my_time))\r\n</strong>\r\n</pre>\r\nВстроенная <strong>функция repr()</strong> возвращает объект в формальном (понятном интерпретатору) строковом представлении.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import date, time\r\n\r\nmy_date = date(2021, 12, 31)\r\nmy_time = time(11, 20, 54)\r\n\r\nprint(repr(my_date))\r\nprint(repr(my_time))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\ndatetime.date(2021, 12, 31)\r\ndatetime.time(11, 20, 54)\r\n</strong>\r\n</pre>\r\nДля встроенных типов данных при печати одиночного значения объекта явно вызывать функцию str() не требуется, однако при печати списка таких объектов это требуется.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import date\r\n\r\ndates = [date(2021, 12, 31), date(2019, 10, 6), date(2022, 11, 8)]   # список дат\r\n\r\nprint(dates)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n[datetime.date(2021, 12, 31), datetime.date(2019, 10, 6), datetime.date(2022, 11, 8)]\r\n</strong>\r\n</pre>\r\nЕсли мы хотим вывести содержимое списка в человеческом виде, то нужно прибегнуть к распаковке, в этом случае функция str() будет вызываться для каждого элемента списка за кулисами.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import date\r\n\r\ndates = [date(2021, 12, 31), date(2019, 10, 6), date(2022, 11, 8)]\r\n\r\nprint(*dates, sep='\\n')\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n2021-12-31\r\n2019-10-06\r\n</strong>\r\n</pre>\r\n2022-11-08",
    "slug": "data-time"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 25,
  "fields": {
    "lesson": "Форматирование даты и времени",
    "content": "<strong>Форматирование даты и времени</strong><br><br>\r\nПо умолчанию вывод даты и времени осуществляется в ISO формате:<br><br>\r\n\r\n<li>дата имеет вид: YYYY-MM-DD</li>\r\n<li>время имеет вид: HH:MM:SS или HH:MM:SS.ffffff</li><br><br>\r\nДля форматированного вывода даты и времени используется метод strftime() (для обоих типов date и time).\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import date, time\r\n\r\nmy_date = date(2021, 8, 10)\r\nmy_time = time(7, 18, 34)\r\n\r\nprint(my_date)                             # вывод в ISO формате\r\nprint(my_time)                             # вывод в ISO формате\r\n\r\nprint(my_date.strftime('%d/%m/%y'))        # форматированный вывод даты\r\nprint(my_date.strftime('%A %d, %B %Y'))    # форматированный вывод даты\r\nprint(my_time.strftime('%H.%M.%S'))        # форматированный вывод времени\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n2021-08-10\r\n07:18:34\r\n10/08/21\r\nTuesday 10, August 2021\r\n07.18.34\r\n</strong>\r\n</pre>\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import date, time\r\n\r\nmy_date = date(2021, 8, 10)\r\nmy_time = time(7, 18, 34)\r\n\r\nprint(my_date.strftime('%a %A %w %d %b %B %m %y %Y %H %I %p %M %S %f %z %Z %j %U %W %c %x %X'))\r\nprint(my_time.strftime('%a %A %w %d %b %B %m %y %Y %H %I %p %M %S %f %z %Z %j %U %W %c %x %X'))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTue Tuesday 2 10 Aug August 08 21 2021 00 12 AM 00 00 000000   222 32 32 Tue Aug 10 00:00:00 2021 08/10/21 00:00:00\r\nMon Monday 1 01 Jan January 01 00 1900 07 07 AM 18 34 000000   001 00 01 Mon Jan  1 07:18:34 1900 01/01/00 07:18:34\r\n</strong>\r\n</pre>\r\nОбратите внимание, что при форматировании даты все временные характеристики сбрасываются в минимально возможные (нулевые значения). Аналогично при форматировании времени все характеристики даты сбрасываются в минимально возможные.<br><br>\r\n\r\n<strong>Использование локализации</strong><br><br>\r\nДля того чтобы использовать конкретную локализацию (перевод на язык), нужно использовать модуль locale.\r\n\r\nПриведенный ниже код устанавливает русскую локализацию:\r\n<pre>\r\n<strong>\r\nfrom datetime import date\r\nimport locale\r\n\r\nlocale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8')\r\n\r\nmy_date = date(2021, 8, 10)\r\nprint(my_date.strftime(\"%A %d, %B %Y\"))    # форматированный вывод даты в русской локализации\r\n</strong>\r\n</pre>\r\nи выводит:\r\n<pre>\r\n<strong>\r\nвторник 10, Август 2021\r\n</strong>\r\n</pre>\r\nДля установки английской локализации используется код:\r\n<pre>\r\n<strong>\r\nimport locale\r\n\r\nlocale.setlocale(locale.LC_ALL, 'en_EN.UTF-8')\r\n</strong>\r\n</pre>\r\n\r\n<strong>Преобразование строки в дату с помощью метода fromisoformat()</strong><br><br>\r\nСамостоятельное преобразование данных из строки в объекты типа date и time оказывается довольно неудобным. Код получается достаточно громоздким и плохо расширяемым.<br><br>\r\n\r\nДля того чтобы преобразовать строку из ISO формата в объект даты (date) или в объект времени (time), можно использовать <strong>метод fromisoformat()</strong>.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import date, time\r\n\r\nmy_date = date.fromisoformat('2020-01-31')\r\nmy_time = time.fromisoformat('10:20:30')\r\n\r\nprint(my_date)\r\nprint(my_time)\r\nprint(type(my_date))\r\nprint(type(my_time))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n2020-01-31\r\n10:20:30\r\nclass 'datetime.date'\r\nclass 'datetime.time'\r\n</strong>\r\n</pre>\r\nМетод fromisoformat() полезен на практике, однако у него есть серьезное ограничение: он работает только с датой и временем, записанными в ISO формате.\r\n\r\n   Метод fromisoformat() был добавлен только в Python 3.7. Ранее он недоступен.",
    "slug": "format-data-time"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 26,
  "fields": {
    "lesson": "Тип данных datetime",
    "content": "<strong>Тип данных datetime</strong><br><br>\r\nТипы данных date и time позволяют работать по отдельности с датами и временами. Однако на практике чаще требуется работать одновременно и с датой, и со временем. Для таких целей используется тип данных datetime из одноименного модуля datetime.<br><br>\r\n\r\nЧтобы иметь возможность использовать этот тип данных, необходимо предварительно его импортировать из модуля datetime:\r\n<pre>\r\n<strong>\r\nfrom datetime import datetime\r\n</strong>\r\n</pre>\r\nПри создании новой даты-времени (тип datetime) нужно указать год, месяц, день, часы, минуты, секунды и микросекунды. При этом год, месяц и день являются обязательными, а часы, минуты, секунды и микросекунды необязательными.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import datetime\r\n\r\nmy_datetime = datetime(1992, 10, 6, 9, 40, 23, 51204)    # создаем полную дату-время\r\nonly_date = datetime(2021, 12, 31)                       # создаем дату-время с нулевой временной информацией\r\n\r\nprint(my_datetime)\r\nprint(only_date)\r\nprint(type(my_datetime))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n1992-10-06 09:40:23.051204\r\n2021-12-31 00:00:00\r\nclass 'datetime.datetime'\r\n</strong>\r\n</pre>\r\n\r\nКонструктор типа datetime сначала принимает год, месяц, день, часы, минуты, секунды, а уже потом микросекунды. Мы также можем использовать именованные аргументы, нарушая указанный порядок datetime(day=6, month=10, year=1992, second=23, minute=40, microsecond=51204, hour=9).<br><br>\r\n\r\nТак же, как и при работе с типами date и time, пользуясь типом datetime, можно получать доступ к отдельным значениям созданной даты-времени: годам, месяцам, дням, часам, минутам, секундам и микросекундам. Получить доступ к ним можно с помощью атрибутов:<br><br>\r\n\r\n<li>year — год</li>\r\n<li>month — месяц</li>\r\n<li>day — день</li>\r\n<li>hour — час</li>\r\n<li>minute — минуты</li>\r\n<li>second — секунды</li>\r\n<li>microsecond — микросекунды</li><br>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import datetime\r\n\r\nmy_datetime = datetime(1992, 10, 6, 9, 40, 23, 51204)\r\n\r\nprint('Год =', my_datetime.year)\r\nprint('Месяц =', my_datetime.month)\r\nprint('День =', my_datetime.day)\r\nprint('Часы =', my_datetime.hour)\r\nprint('Минуты =', my_datetime.minute)\r\nprint('Секунды =', my_datetime.second)\r\nprint('Микросекунды =', my_datetime.microsecond)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nГод = 1992\r\nМесяц = 10\r\nДень = 6\r\nЧасы = 9\r\nМинуты = 40\r\nСекунды = 23\r\nМикросекунды = 51204\r\n</strong>\r\n</pre>\r\n\r\n<strong>Методы combine(), date(), time()</strong><br><br>\r\nСформировать новый объект типа datetime можно с помощью двух разных объектов, представляющих дату и время (date и time). Для этого используется <strong>метод combine()</strong>.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import date, time, datetime\r\n\r\nmy_date = date(1992, 10, 6)\r\nmy_time = time(10, 45, 17)\r\nmy_datetime = datetime.combine(my_date, my_time)\r\n\r\nprint(my_datetime)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n1992-10-06 10:45:17\r\n</strong>\r\n</pre>\r\nЕсли, наоборот, нужно получить из даты-времени (тип datetime) по отдельности дату (тип date) и время (тип time), то используются <strong>методы date() и time()</strong> соответственно.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import datetime\r\n\r\nmy_datetime = datetime(2022, 10, 7, 14, 15, 45)\r\nmy_date = my_datetime.date()                     # получаем только дату (тип date)\r\nmy_time = my_datetime.time()                     # получаем только время (тип time)\r\n\r\nprint(my_datetime, type(my_datetime))\r\nprint(my_date, type(my_date))\r\nprint(my_time, type(my_time))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n2022-10-07 14:15:45 class 'datetime.datetime'\r\n2022-10-07 class 'datetime.date'\r\n14:15:45 class 'datetime.time'\r\n</strong>\r\n</pre>\r\n\r\n<strong>Методы now(), utcnow(), today()</strong><br><br>\r\nДля того, чтобы получить текущее время на момент исполнения программы, используются <strong>методы now() и utcnow()</strong> для локального и UTC времени соответственно.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import datetime\r\n\r\ndatetime_now = datetime.now()\r\ndatetime_utcnow = datetime.utcnow()\r\n\r\nprint(datetime_now)           # текущее локальное время (московское) на момент запуска программы\r\nprint(datetime_utcnow)        # текущее UTC время на момент запуска программы\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n2021-08-13 08:03:43.224568\r\n2021-08-13 05:03:43.224568\r\n</strong>\r\n</pre>\r\nВсемирное координированное время (Coordinated Universal Time, UTC) — стандарт, по которому общество регулирует часы и время. Московское время соответствует UTC+3.<br><br>\r\n\r\nС выходом Python 3.12 метод utcnow() устарел и подготовлен к удалению в будущих версиях языка, поэтому вместо него рекомендуется использовать метод now(), указав в качестве аргумента константу UTC модуля datetime.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import datetime, UTC\r\n\r\nprint(datetime.now(UTC))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n2024-08-11 10:39:54.528918+00:00\r\n</strong>\r\n</pre>\r\n<strong>Метод today()</strong> аналогичен методу now(). Для получения локальной даты-времени рекомендуется использовать именно метод now().<br><br>\r\n\r\n<strong>Метод timestamp()</strong><br><br>\r\nМетод timestamp() позволяет преобразовать объект типа datetime в количество секунд, прошедших с момента начала эпохи. Начало эпохи — это полночь 1 января 1970 года (00:00:00 UTC). Данный метод возвращает значение типа float.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import datetime\r\n\r\nmy_datetime = datetime(2021, 10, 13, 8, 10, 23)\r\n\r\nprint(my_datetime.timestamp())\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n1634101823.0\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод fromtimestamp()</strong><br><br>\r\nМетод fromtimestamp() позволяет преобразовать количество секунд, прошедших с момента начала эпохи, в объект типа datetime. Данный метод является обратным по отношению к методу timestamp().\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import datetime\r\n\r\nmy_datetime = datetime.fromtimestamp(1634101823.0)\r\n\r\nprint(my_datetime)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n2021-10-13 08:10:23\r\n</strong>\r\n</pre>\r\nОбратите внимание на то, что метод fromtimestamp() по умолчанию возвращает объект datetime в вашем часовом поясе.<br><br>\r\n\r\n<strong>Форматирование даты-времени</strong><br><br>\r\nПо умолчанию объекты типа datetime (как и объекты типа date и time) выводятся в специальном формате, который называется ISO 8601. Данное представление не всегда удовлетворяет нашим запросам.<br><br>\r\n\r\nЧтобы преобразовать дату-время в строку нужного формата, следует воспользоваться методом strftime(), указав ему в качестве аргумента параметры форматирования.\r\n<pre>\r\n<strong>\r\nfrom datetime import datetime\r\n\r\nmy_datetime = datetime(2021, 8, 10, 18, 20, 34)\r\n\r\nprint(my_datetime)                                            # вывод в ISO формате\r\nprint(my_datetime.strftime('%d.%m.%y --- %H::%M::%S'))\r\nprint(my_datetime.strftime('%d/%m/%y'))\r\nprint(my_datetime.strftime('%A %d, %B %Y'))\r\nprint(my_datetime.strftime('%H:%M:%S'))\r\n</strong>\r\n</pre>\r\nвыводит\r\n<pre>\r\n<strong>\r\n2021-08-10 18:20:34\r\n10.08.21 --- 18::20::34\r\n10/08/21\r\nTuesday 10, August 2021\r\n18:20:34\r\n</strong>\r\n</pre>\r\nДля форматированного вывода объектов типов date, time, datetime используется один и тот же метод strftime().<br><br>\r\n\r\n<strong>Преобразование строки в дату-время</strong><br><br>\r\nКак уже было сказано в прошлом уроке, преобразовать данные из строки в объект типа datetime можно двумя способами:<br><br>\r\n\r\n<li>ручным преобразованием</li>\r\n<li>с помощью метода strptime()</li><br><br>\r\nРучной подход основан на использовании метода split():\r\n<pre>\r\n<strong>\r\nfrom datetime import datetime\r\n\r\ndatetime_str = input('Введите дату/время в формате ДД.ММ.ГГГГ ЧЧ:ММ:СС')\r\n\r\ndate_str, time_str = datetime_str.split(' ')\r\n\r\ndate_info = [int(i) for i in date_str.split('.')]\r\ntime_info = [int(i) for i in time_str.split(':')]\r\n\r\nmy_datetime = datetime(date_info[2], date_info[1], date_info[0], time_info[0], time_info[1], time_info[2])\r\n\r\nprint(my_datetime)\r\n</strong>\r\n</pre>\r\nНа практике для преобразования строки в объект datetime редко используется ручной подход. Вместо него используется метод strptime(), который преобразует строку (первый аргумент) в объект datetime согласно переданному формату (второй аргумент).\r\n\r\nПриведенный ниже код работает аналогично коду выше:\r\n<pre>\r\n<strong>\r\nfrom datetime import datetime\r\n\r\ndatetime_str = input('Введите дату/время в формате ДД.ММ.ГГГГ ЧЧ:ММ:СС')\r\n\r\nmy_datetime = datetime.strptime(datetime_str, '%d.%m.%Y %H:%M:%S')\r\n\r\nprint(my_datetime)\r\n</strong>\r\n</pre>\r\nРассмотрим примеры работы данного метода.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import datetime\r\n\r\ndatetime0 = datetime.strptime('10.08.2034 13:55:59', '%d.%m.%Y %H:%M:%S')\r\ndatetime1 = datetime.strptime('10/08/21', '%d/%m/%y')\r\ndatetime2 = datetime.strptime('Tuesday 10, August 2021', '%A %d, %B %Y')\r\ndatetime3 = datetime.strptime('18.20.34', '%H.%M.%S')\r\ndatetime4 = datetime.strptime('2021/08/10', '%Y/%m/%d')\r\ndatetime5 = datetime.strptime('10.08.2021 (Tuesday, August)', '%d.%m.%Y (%A, %B)')\r\ndatetime6 = datetime.strptime('Year: 2021, Month: 08, Day: 10, Hour: 18.', 'Year: %Y, Month: %m, Day: %d, Hour: %H.')\r\n\r\nprint(datetime0, datetime1, datetime2, datetime3, datetime4, datetime5, datetime6, sep='\\n')\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n2034-08-10 13:55:59\r\n2021-08-10 00:00:00\r\n2021-08-10 00:00:00\r\n1900-01-01 18:20:34\r\n2021-08-10 00:00:00\r\n2021-08-10 00:00:00\r\n2021-08-10 18:00:00\r\n</strong>\r\n</pre>\r\nОбратите внимание на то, что первый аргумент должен соответствовать формату второго аргумента. Если он не соответствует, то возникает исключение ValueError.\r\n\r\nВ результате выполнения кода:\r\n<pre>\r\n<strong>\r\nfrom datetime import datetime\r\n\r\nmy_datetime = datetime.strptime('10/08/2034 13:55:59', '%d.%m.%Y %H:%M:%S')\r\n\r\nprint(my_datetime)\r\n</strong>\r\n</pre>\r\nмы получим:\r\n<pre>\r\n<strong>\r\nValueError: time data '10/08/2034 13:55:59' does not match format '%d.%m.%Y %H:%M:%S'\r\n</strong>\r\n</pre>",
    "slug": "type-datetime"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 27,
  "fields": {
    "lesson": "Тип данных timedelta",
    "content": "<strong>Тип данных timedelta</strong><br><br>\r\nТип данных timedelta представляет собой временной интервал (разница между двумя объектами datetime или date) и используется для удобного выполнения различных манипуляций над типами datetime или date.<br><br>\r\n\r\nПри создании объекта timedelta можно указать следующие аргументы:<br><br>\r\n\r\n<li>недели (weeks)</li>\r\n<li>дни (days)</li>\r\n<li>часы (hours)</li>\r\n<li>минуты (minutes)</li>\r\n<li>секунды (seconds)</li>\r\n<li>миллисекунды (milliseconds)</li>\r\n<li>микросекунды (microseconds)</li><br><br>\r\nМы можем выбрать любые их сочетания для задания временного интервала, при этом все аргументы являются необязательными и по умолчанию равны 0.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import timedelta\r\n\r\ndelta = timedelta(days=7, hours=20, minutes=7, seconds=17)\r\n\r\nprint(delta)\r\nprint(type(delta))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n7 days, 20:07:17\r\nclass 'datetime.timedelta'\r\n</strong>\r\n</pre>\r\nАргументы могут быть целыми числами или числами с плавающей запятой, а также могут быть как положительными, так и отрицательными. Используйте именованные аргументы, вместо позиционных, чтобы избежать ошибок.<br><br>\r\n\r\nТип timedelta внутренне хранит только сочетание days, seconds, microseconds, а остальные переданные в конструктор аргументы конвертируются в эти единицы:\r\n\r\n<li>milliseconds преобразуется в 1000 microseconds</li>\r\n<li>minutes преобразуется в 60 seconds</li>\r\n<li>hours преобразуется в 3600 seconds</li>\r\n<li>weeks преобразуется в 7 days</li><br><br>\r\nАтрибуты days, seconds и microseconds затем нормализуются так, чтобы представление было уникальным:\r\n<pre>\r\n<strong>\r\n0 <= microseconds < 1000000\r\n0 <= seconds < 3600*24 (количество секунд в одном дне)\r\n-999999999 <= days <= 999999999\r\n</strong>\r\n</pre>\r\nВ следующем примере показано, как любые аргументы, кроме days, seconds, microseconds, объединяются и нормализуются в три результирующих сочетания.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import timedelta\r\n\r\ndelta1 = timedelta(days=50, seconds=27, microseconds=10, milliseconds=29000, minutes=5, hours=8, weeks=2)\r\ndelta2 = timedelta(weeks=1, hours=23, minutes=61)\r\ndelta3 = timedelta(hours=25)\r\ndelta4 = timedelta(minutes=300)\r\n\r\nprint(delta1, delta2, delta3, delta4, sep='\\n')\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n64 days, 8:05:56.000010\r\n8 days, 0:01:00\r\n1 day, 1:00:00\r\n5:00:00\r\n</strong>\r\n</pre>\r\n   Обратите внимание на то, что если во временном интервале (timedelta) значение days равно нулю, то оно не выводится.<br><br>\r\n\r\nТакже временной интервал (timedelta) может быть отрицательным.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import timedelta\r\n\r\ndelta1 = timedelta(minutes=-40)\r\ndelta2 = timedelta(seconds=-10, weeks=-2)\r\n\r\nprint(delta1)\r\nprint(delta2)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n-1 day, 23:20:00\r\n-15 days, 23:59:50\r\n</strong>\r\n</pre>\r\n\r\n<strong>Атрибуты days, seconds, microseconds и метод total_seconds()</strong><br><br>\r\nКак уже было сказано, тип timedelta внутренне хранит только сочетание days, seconds, microseconds, которые можно получить с помощью одноименных атрибутов.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import timedelta\r\n\r\ndelta = timedelta(days=50, seconds=27, microseconds=10, milliseconds=29000, minutes=5, hours=8, weeks=2)\r\n\r\nprint('Количество дней =', delta.days)\r\nprint('Количество секунд =', delta.seconds)\r\nprint('Количество микросекунд =', delta.microseconds)\r\n\r\nprint('Общее количество секунд =', delta.total_seconds())\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nКоличество дней = 64\r\nКоличество секунд = 29156\r\nКоличество микросекунд = 10\r\nОбщее количество секунд = 5558756.00001\r\n</strong>\r\n</pre>\r\n<strong>Метод total_seconds()</strong> возвращает общее количество секунд, содержащееся во временном интервалеtimedelta.<br><br>\r\n\r\nОбратите внимание на то, что у типа timedelta нет атрибутов hours и minutes, позволяющих получить количество часов и минут соответственно. Достать часы и минуты можно так:\r\n<pre>\r\n<strong>\r\ndef hours_minutes(td):\r\n    return td.seconds // 3600, (td.seconds // 60) % 60\r\n</strong>\r\n</pre>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import timedelta\r\n\r\ndef hours_minutes(td):\r\n    return td.seconds // 3600, (td.seconds // 60) % 60\r\n\r\ndelta = timedelta(days=7, seconds=125, minutes=10, hours=8, weeks=2)\r\n\r\nhours, minutes = hours_minutes(delta)\r\n\r\nprint(delta)\r\nprint(hours)\r\nprint(minutes)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n21 days, 8:12:05\r\n8\r\n12\r\n</strong>\r\n</pre>\r\n\r\n<strong>Сравнение временных интервалов</strong><br><br>\r\nВременные интервалы (тип timedelta) можно сравнивать (==, !=, <, >, <=, >=), как и любые другие типы данных.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import timedelta\r\n\r\ndelta1 = timedelta(weeks=1)\r\ndelta2 = timedelta(hours=24*7)\r\ndelta3 = timedelta(minutes=24*7*59)\r\n\r\nprint(delta1 == delta2)\r\nprint(delta1 != delta3)\r\nprint(delta1 < delta3)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTrue\r\nTrue\r\nFalse\r\n</strong>\r\n</pre>\r\nОператоры сравнения == или != всегда возвращают значение bool, независимо от типа сравниваемого объекта.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import timedelta\r\n\r\ndelta1 = timedelta(seconds=57)\r\ndelta2 = timedelta(hours=25, seconds=2)\r\n\r\nprint(delta1 != 57)\r\nprint(delta2 == '5')\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTrue\r\nFalse\r\n</strong>\r\n</pre>\r\nДля всех других операторов сравнения, таких как <, >, <=, >=, когда объект timedelta сравнивается с объектом другого типа, возникает ошибка (исключение) TypeError.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import timedelta\r\n\r\ndelta1 = timedelta(seconds=57)\r\ndelta2 = timedelta(hours=25, seconds=2)\r\n\r\nprint(delta2 > delta1)     # тут все ок\r\nprint(delta2 > 5)\r\n</strong>\r\n</pre>\r\nприводит к возникновению ошибки:\r\n<pre>\r\n<strong>\r\nTypeError: '>' not supported between instances of 'datetime.timedelta' and 'int'\r\n</strong>\r\n</pre>\r\n\r\n<strong>Операции над временными интервалами timedelta</strong><br><br>\r\nТип данных timedelta поддерживает многие математические операции. Допустимо:<br><br>\r\n\r\n<li>сложение временных интервалов</li>\r\n<li>вычитание временных интервалов</li>\r\n<li>умножение временного интервала на число</li>\r\n<li>деление временного интервала на число</li>\r\n<li>деление временного интервала на временной интервал</li><br><br>\r\n\r\n<strong>Сумма и разность временных интервалов</strong><br><br>\r\nС помощью операторов + и - мы можем находить сумму и разность временных интервалов (тип timedelta).\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import timedelta\r\n\r\ndelta1 = timedelta(days=5) + timedelta(seconds=3600)  # 5 дней + 1 час\r\ndelta2 = timedelta(days=5) - timedelta(seconds=3600)  # 5 дней - 1 час\r\n\r\nprint(delta1)\r\nprint(delta2)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n5 days, 1:00:00\r\n4 days, 23:00:00\r\n</strong>\r\n</pre>\r\n\r\n<strong>Умножение временного интервала на число</strong><br><br>\r\nС помощью оператора * мы можем умножать временной интервал (тип timedelta) на целое или вещественное число (типы int и float).\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import timedelta\r\n\r\ndelta1 = 48 * timedelta(hours=1)\r\ndelta2 = timedelta(weeks=1) * (3/7)\r\n\r\nprint(delta1)\r\nprint(delta2)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n2 days, 0:00:00\r\n3 days, 0:00:00\r\n</strong>\r\n</pre>\r\nБудьте осторожны с умножением временного интервала на вещественное число (тип float), так как может возникнуть округление.<br><br>\r\n\r\n<strong>Деление временных интервалов на число</strong><br><br>\r\nС помощью операторов / и // мы можем делить временной интервал (тип timedelta) на целое или вещественное число (типы int и float).\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import timedelta\r\n\r\ndelta = timedelta(hours=1, minutes=6)\r\ndelta1 = delta / 2\r\ndelta2 = delta // 5\r\n\r\nprint(delta1)\r\nprint(delta2)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n0:33:00\r\n0:13:12\r\n</strong>\r\n</pre>\r\n\r\n<strong>Деление временного интервала на временной интервал</strong><br><br>\r\nС помощью операторов / и // мы также можем делить один временной интервал (тип timedelta) на другой. По сути происходит деление общей длительности одного интервала на общую длительность другого интервала.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import timedelta\r\n\r\ndelta1 = timedelta(weeks=1) / timedelta(hours=5)       # обычное деление, результат float\r\ndelta2 = timedelta(weeks=1) // timedelta(hours=5)      # целочисленное деление, результат int\r\n\r\nprint(delta1)\r\nprint(delta2)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n33.6\r\n33\r\n</strong>\r\n</pre>\r\n   Общая длительность временного интервала вычисляется с помощью метода total_seconds().<br><br>\r\n\r\nМы также можем использовать оператор нахождения остатка от деления %, при этом остаток вычисляется как объект timedelta.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import timedelta\r\n\r\ndelta1 = timedelta(weeks=1) % timedelta(hours=5)         # 3 часа\r\ndelta2 = timedelta(hours=1) % timedelta(minutes=7)       # 4 минуты\r\n\r\nprint(delta1)\r\nprint(delta2)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n3:00:00\r\n0:04:00\r\n</strong>\r\n</pre>\r\nРассмотрим следующую задачу: рабочая смена длится 7 часов 30 минут, сколько полных смен в 3-х сутках?<br><br>\r\n\r\nРешение. Приведенный ниже код решает поставленную задачу:\r\n<pre>\r\n<strong>\r\nfrom datetime import timedelta\r\n\r\nall_time = timedelta(days=3)\r\nsmena = timedelta(hours=7, minutes=30)\r\n\r\nprint(all_time // smena)\r\nprint(all_time % smena)\r\n</strong>\r\n</pre>\r\nи выводит:\r\n<pre>\r\n<strong>\r\n9\r\n4:30:00\r\n</strong>\r\n</pre>\r\nТаким образом, в 3-х сутках помещается 9 полных смен и еще останется 4 часа 30 минут.<br><br>\r\n\r\n<strong>Операции над datetime и date</strong><br><br>\r\nК объектам типа datetime и date можно прибавлять (вычитать) временные интервалы (тип timedelta), тем самым формируя новые объекты.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom datetime import datetime, date, timedelta\r\n\r\nmy_datetime1 = datetime(2021, 1, 1, 12, 15, 20) + timedelta(weeks=1, hours=25)\r\nmy_datetime2 = datetime(2021, 1, 1, 12, 15, 20) - timedelta(weeks=1, hours=25)\r\n\r\nmy_date1 = date(2021, 1, 1) + timedelta(hours=49)\r\nmy_date2 = date(2021, 1, 1) - timedelta(hours=49)\r\n\r\nprint(my_datetime1, my_datetime2, my_date1, my_date2, sep='\\n')\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n2021-01-09 13:15:20\r\n2020-12-24 11:15:20\r\n2021-01-03\r\n2020-12-30\r\n</strong>\r\n</pre>\r\n   Обратите внимание на то, что при прибавлении временного интервала к дате (тип date) неполные сутки отбрасываются.<br><br>\r\n\r\nОбъект типа timedelta также возникает при вычитании двух дат (тип date) или дат-времён (тип datetime).\r\n<pre>\r\n<strong>\r\nПриведенный ниже код:\r\n\r\nfrom datetime import datetime, date, timedelta\r\n\r\ndelta1 = datetime(2021, 1, 1, 12, 15, 20) - datetime(2020, 5, 1, 10, 5, 10)\r\ndelta2 = date(2020, 2, 29) - date(2019, 9, 1)\r\ndelta3 = date(2019, 9, 1) - date(2020, 2, 29)\r\n\r\nprint(delta1)\r\nprint(delta2)\r\nprint(delta3)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n245 days, 2:10:10\r\n181 days, 0:00:00\r\n-181 days, 0:00:00\r\n</strong>\r\n</pre>",
    "slug": "type-timedelta"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 28,
  "fields": {
    "lesson": "Модуль time",
    "content": "<strong>Модуль time</strong><br><br>\r\n\r\nРабота функций модуля time основывается на общепринятой системе описания времени. Согласно ее концепции, текущее время представляется в виде обыкновенного вещественного значения в секундах, прошедших с момента начала эпохи и до сегодняшнего дня. С тех пор это число постоянно растет, позволяя людям работать с различными видами дат в максимально точном представлении. Начало эпохи — это полночь 1 января 1970 года (00:00:00 UTC), когда счетчик секунд имел полностью нулевое значение.<br><br>\r\n\r\nМодуль time из стандартной библиотеки языка Python содержит массу полезных функций для работы со временем. С его помощью можно получать информацию о текущих дате и времени, выводить эти сведения в необходимом формате, а также управлять ходом выполнения программы, добавляя задержки по таймеру.<br><br>\r\n\r\nМодуль time предоставляет только функции, позволяющие работать со временем.<br><br>\r\n\r\nИспользование модуля time дает возможность:<br><br>\r\n\r\n<li>отображать информацию о времени, прошедшем с начала эпохи</li>\r\n<li>преобразовывать значение системного времени к удобному виду</li>\r\n<li>прерывать выполнение программы (установка паузы) на заданное количество секунд</li>\r\n<li>измерять время выполнения программы целиком или ее отдельных модулей</li><br><br>\r\nОбратите внимание, если требуется сравнивать или производить арифметические операции со временем, то нужно использовать модуль datetime, а не time.<br><br>\r\n\r\n<strong>Функция time()</strong><br><br>\r\nДля того чтобы получить количество секунд, прошедших с момента начала эпохи, необходимо использовать одноименную функцию time() из модуля time.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport time\r\n\r\nseconds = time.time()    # получаем количество прошедших секунд в виде float числа\r\nprint('Количество секунд с начала эпохи =', seconds)\r\n</strong>\r\n</pre>\r\nвыводит (на момент запуска 31 августа 2021 года):\r\n<pre>\r\n<strong>\r\nКоличество секунд с начала эпохи = 1630387918.354396\r\n</strong>\r\n</pre>\r\nТаким образом, с 1 января 1970 года прошло уже более 1.6 миллиардов секунд.<br><br>\r\n\r\nВ Python 3.7 добавили функцию<strong> time_ns()</strong>, которая возвращает целочисленное значение, представляющее то же время, прошедшее с эпохи, но в наносекундах, а не в секундах.<br><br>\r\n\r\n<strong>Функция ctime()</strong><br><br>\r\nПредставление времени на основе количества прошедших секунд с момента начала эпохи не очень удобно для человека (хотя и удобно для компьютера). Для того чтобы получить текущую дату в более удобном для человека виде, нужно использовать функцию ctime(). Функция ctime() принимает в качестве аргумента количество секунд, прошедших с начала эпохи, и возвращает строку, представляющую собой местное (локальное) время.<br><br>\r\n\r\nПредставление времени в зависимости от вашего физического местоположения называется местным (локальным) временем и использует концепцию часовых поясов.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport time\r\n\r\nseconds = 1630387918.354396\r\nlocal_time = time.ctime(seconds)\r\n\r\nprint('Местное время:', local_time)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nМестное время: Tue Aug 31 08:31:58 2021\r\n</strong>\r\n</pre>\r\nТаким образом, функция ctime() возвращает строковое представление о местном (локальном) времени, которое включает в себя:<br><br>\r\n\r\n<li>день недели: Tue (Tuesday)</li>\r\n<li>название месяца: Aug (August)</li>\r\n<li>день месяца: 31</li>\r\n<li>часы, минуты, секунды: 08:31:58</li>\r\n<li>год: 2021</li><br><br>\r\n\r\nВызывать функцию ctime() можно и без аргументов, в этом случае в качестве аргумента подставляется значение вызова функции time(). Таким образом, приведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport time\r\n\r\nlocal_time = time.ctime()              # вызов функции без аргумента\r\nprint('Местное время:', local_time)\r\n</strong>\r\n</pre>\r\nравнозначен коду:\r\n<pre>\r\n<strong>\r\nimport time\r\n\r\nseconds = time.time()\r\nlocal_time = time.ctime(seconds)\r\nprint('Местное время:', local_time)\r\n</strong>\r\n</pre>\r\nОбратите внимание на то, что результат работы функции ctime() зависит от вашего географического положения.<br><br>\r\n\r\n<strong>Функция sleep()</strong><br><br>\r\nФункция sleep() используется для добавления задержки в выполнении программы. Эта функция принимает в качестве аргумента количество секунд (secs) и добавляет задержку в выполнении программы на указанное количество секунд.\r\n\r\nРассмотрим программный код:\r\n<pre>\r\n<strong>\r\nimport time \r\n\r\nprint('Before the sleep statement')\r\ntime.sleep(3)\r\nprint('After the sleep statement')\r\n</strong>\r\n</pre>\r\nЕсли вы запустите приведенный выше код, то увидите, что вторая печать выполняется примерно через 3 секунды.<br><br>\r\n\r\nАргумент secs может быть числом с плавающей точкой (float), для указания более точного времени приостановки. Например, мы можем сделать задержку на 700 миллисекунд, что составляет 0.7 секунды, как показано ниже:\r\n<pre>\r\n<strong>\r\nimport time \r\n\r\nprint('Before the sleep statement')\r\ntime.sleep(0.7)\r\nprint('After the sleep statement')\r\n</strong>\r\n</pre>\r\nВремя приостановки может быть дольше, чем запрошено, на произвольную величину из-за планирования других действий в операционной системе.<br><br>\r\n\r\nИногда может потребоваться задержка на разное количество секунд. Сделать это можно следующим образом:\r\n<pre>\r\n<strong>\r\nimport time\r\n\r\nfor i in [0.7, 0.5, 1.0, 2.5, 3.3]:\r\n    print(f'Waiting for {i} seconds')\r\n    time.sleep(i)\r\nprint('The end')\r\n</strong>\r\n</pre>\r\nТакая программа будет выполняться примерно 0.7+0.5+1.0+2.5+3.3=8.0 секунд.<br><br>\r\n\r\nФункция sleep() нередко используется для тестирования кода и намеренного внесения задержек на различных этапах выполнения программы.<br><br>\r\n\r\n<strong>Измерение времени выполнения программы</strong><br><br>\r\nОчень часто нам бывает необходимо измерить время выполнения всей программы, либо отдельных ее частей. Чтобы найти данную величину, достаточно посчитать разницу в секундах между точкой старта и местом, где она завершает свою работу.<br><br>\r\n\r\nВ следующем примере демонстрируется применение функции time() для получения текущего времени, чтобы в итоге выявить, как долго работал блок кода.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport time\r\n\r\nstart_time = time.time()\r\n\r\nfor i in range(5): \r\n    print(i)\r\n    time.sleep(1)\r\n\r\nend_time = time.time()\r\n\r\nelapsed_time = end_time - start_time\r\nprint(f'Время работы программы = {elapsed_time}')\r\n</strong>\r\n</pre>\r\nвыводит (время работы программы может незначительно отличаться):\r\n<pre>\r\n<strong>\r\n0\r\n1\r\n2\r\n3\r\n4\r\nВремя работы программы = 5.022884845733643\r\n</strong>\r\n</pre>\r\nНесмотря на простоту вышеописанного подхода, использовать его в серьезных целях, где требуется точный и независимый от операционной системы (ОС) результат, не рекомендуется. Все дело в том, что числовое значение времени, получаемое таким образом, может иметь погрешности за счет внутренних особенностей работы компьютера, в среде которого выполняется программа. Более того, системные часы могут быть подкорректированы вручную пользователем во время выполнения программы.<br><br>\r\n\r\nМожет случиться такая ситуация, что очередной вызов функции time() вернет значение меньше, чем значение, полученное при предыдущем вызове.<br><br>\r\n\r\n<strong>Функция monotonic()</strong><br><br>\r\nДля измерения времени выполнения программы идеально подходит функция monotonic(), доступная на всех ОС (начиная с Python 3.5), так как ее результат не зависит от корректировки системных часов.<br><br>\r\n\r\nФункция monotonic_ns() похожа на monotonic(), но возвращает время в наносекундах. Работает не на всех операционных системах.<br><br>\r\n\r\nИспользуемый таймер в функции monotonic() никогда не вернет при повторном вызове значение, которое будет меньше значения, полученного при предыдущем вызове. Это позволяет избежать многих ошибок, а также неожиданного поведения.<br><br>\r\n\r\nВ следующем примере демонстрируется применение функции monotonic() для получения текущего времени, чтобы в итоге выявить, как долго работал блок кода.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport time\r\n\r\nstart_time = time.monotonic()\r\n\r\nfor i in range(5): \r\n    print(i)\r\n    time.sleep(0.5)\r\n\r\nend_time = time.monotonic()\r\n\r\nelapsed_time = end_time - start_time\r\nprint(f'Время работы программы = {elapsed_time}')\r\n</strong>\r\n</pre>\r\nвыводит (время работы программы может незначительно отличаться):\r\n<pre>\r\n<strong>\r\n0\r\n1\r\n2\r\n3\r\n4\r\nВремя работы программы = 2.547000000020489\r\n</strong>\r\n</pre>\r\nПринцип работы и применения функции monotonic() такой же, как и у функции time(). Однако функция monotonic() дает результат, который обладает гарантированной точностью и не зависит от внешних условий.<br><br>\r\n\r\n<strong>Функция perf_counter()</strong><br><br>\r\nДля самого точного измерения времени выполнения программы следует использовать функцию perf_counter(). Данная функция использует таймер с наибольшим доступным разрешением, что делает эту функцию отличным инструментом для измерения времени выполнения кода на коротких интервалах.<br><br>\r\n\r\nВ следующем примере демонстрируется применение функции perf_counter() для получения текущего времени, чтобы в итоге выявить, как долго работал блок кода.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport time\r\n\r\nstart_time = time.perf_counter()\r\n\r\nfor i in range(5): \r\n    print(i)\r\n    time.sleep(1)\r\n\r\nend_time = time.perf_counter()\r\n\r\nelapsed_time = end_time - start_time\r\nprint(f'Время работы программы = {elapsed_time}')\r\n</strong>\r\n</pre>\r\nвыводит (время работы программы может незначительно отличаться):\r\n<pre>\r\n<strong>\r\n0\r\n1\r\n2\r\n3\r\n4\r\nВремя работы программы = 5.042140900040977\r\n</strong>\r\n</pre>\r\nВ Python версии 3.7 добавлена функция perf_counter_ns() – работает так же, но длительность выводится в наносекундах, что удобнее для совсем малых интервалов времени и быстро исполняемых команд.",
    "slug": "module-time"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 29,
  "fields": {
    "lesson": "Модуль calendar",
    "content": "<strong>Модуль calendar</strong><br><br>\r\nПо умолчанию модуль calendar следует григорианскому календарю, где понедельник является первым днем недели (имеет номер 0), а воскресенье — последним днем недели (имеет номер 6). В отличие от уже изученных модулей datetime и time, которые также предоставляют функции, связанные с календарем, модуль calendar предоставляет основные функции, связанные с отображением и манипулированием календарями.<br><br>\r\n\r\nПрежде чем использовать модуль calendar, его необходимо подключить с помощью выражения:\r\n<pre>\r\n<strong>\r\nimport calendar\r\n</strong>\r\n</pre>\r\n\r\n<strong>Атрибуты модуля calendar</strong><br><br>\r\nВ отличие от функций, которые выполняют определенную работу, в модуле calendar есть полезные атрибуты, которые возвращают константные (общепринятые) значения, полезные при решении практических задач.<br><br>\r\n\r\n<strong>Атрибут day_name</strong><br><br>\r\nАтрибут calendar.day_name возвращает итерируемый объект, содержащий названия дней недели на английском языке.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport calendar\r\n\r\nfor name in calendar.day_name:\r\n    print(name)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nMonday\r\nTuesday\r\nWednesday\r\nThursday\r\nFriday\r\nSaturday\r\nSunday\r\n</strong>\r\n</pre>\r\n   Обратите внимание, что при обращении к атрибуту мы не ставим скобки, которые ставим при вызове функции.<br><br>\r\n\r\nДля локализации на русский язык мы используем код:\r\n<pre>\r\n<strong>\r\nimport calendar, locale\r\n\r\nlocale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8')\r\n\r\nfor name in calendar.day_name:\r\n    print(name)\r\n</strong>\r\n</pre>\r\nкоторый выводит:\r\n<pre>\r\n<strong>\r\nпонедельник\r\nвторник\r\nсреда\r\nчетверг\r\nпятница\r\nсуббота\r\nвоскресенье\r\n</strong>\r\n</pre>\r\nОбратите внимание, что на русском языке названия дней недели выводятся с маленькой буквы. Для того чтобы сделать первую букву заглавной, можно использовать строковый метод title().<br><br>\r\n\r\nДля преобразования итерируемого объекта в список мы используем следующий код: \r\n<pre>\r\n<strong>\r\nimport calendar\r\n\r\nnames = list(calendar.day_name)\r\nprint(names)\r\n</strong>\r\n</pre>\r\nкоторый выводит:\r\n<pre>\r\n<strong>\r\n['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\r\n</strong>\r\n</pre>\r\n\r\n<strong>Атрибут day_abbr</strong><br><br>\r\nАтрибут calendar.day_abbr возвращает итерируемый объект, содержащий сокращенные названия дней недели.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport calendar, locale\r\n\r\nfor name in calendar.day_abbr:\r\n    print(name)\r\n\r\nlocale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8')\r\n\r\nfor name in calendar.day_abbr:\r\n    print(name)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nMon\r\nTue\r\nWed\r\nThu\r\nFri\r\nSat\r\nSun\r\nПн\r\nВт\r\nСр\r\nЧт\r\nПт\r\nСб\r\nВс\r\n</strong>\r\n</pre>\r\n   Обратите внимание, что на русском языке сокращенные названия дней недели выводятся с большой буквы.<br><br>\r\n\r\n<strong>Атрибут month_name</strong><br><br>\r\nАтрибут calendar.month_name возвращает итерируемый объект, содержащий названия месяцев года.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport calendar, locale\r\n\r\nenglish_names = list(calendar.month_name)\r\nprint(english_names)\r\n\r\nlocale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8')\r\n\r\nrussian_names = list(calendar.month_name)\r\nprint(russian_names)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n['', 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']\r\n['', 'Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь']\r\n</strong>\r\n</pre>\r\nОбратите внимание, что атрибут month_name соответствует обычному соглашению, что январь – это месяц номер 1, поэтому список имеет длину в 13 элементов, первый из которых – пустая строка.<br><br>\r\n\r\n<strong>Атрибут month_abbr</strong><br><br>\r\nАтрибут calendar.month_abbr возвращает итерируемый объект, содержащий сокращенные названия месяцев года.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport calendar, locale\r\n\r\nenglish_names = list(calendar.month_abbr)\r\nprint(english_names)\r\n\r\nlocale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8')\r\n\r\nrussian_names = list(calendar.month_abbr)\r\nprint(russian_names)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n['', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\r\n['', 'янв', 'фев', 'мар', 'апр', 'май', 'июн', 'июл', 'авг', 'сен', 'окт', 'ноя', 'дек']\r\n</strong>\r\n</pre>\r\n\r\n<strong>Атрибуты номеров дней недели</strong><br><br>\r\nДля получения номеров дней недели можно использовать атрибуты: MONDAY, TUESDAY, ..., SUNDAY.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport calendar\r\n\r\nprint(calendar.MONDAY)\r\nprint(calendar.TUESDAY)\r\nprint(calendar.WEDNESDAY)\r\nprint(calendar.THURSDAY)\r\nprint(calendar.FRIDAY)\r\nprint(calendar.SATURDAY)\r\nprint(calendar.SUNDAY)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n0\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функции модуля calendar</strong><br><br>\r\nМодуль calendar содержит множество полезных функций. Приведем основные из них.<br><br>\r\n\r\n<strong>Функция setfirstweekday()</strong><br><br>\r\nПо умолчанию в модуле calendar понедельник является первым днем недели (имеет номер 0), а воскресенье – последним днем недели (имеет номер 6).<br><br>\r\n\r\n<strong>Функция setfirstweekday()</strong> позволяет изменить поведение по умолчанию и устанавливает заданный день недели в качестве начала недели.\r\n\r\nНапример, чтобы установить первый будний день воскресенье, мы используем код:\r\n<pre>\r\n<strong>\r\nimport calendar\r\n\r\ncalendar.setfirstweekday(calendar.SUNDAY)     # эквивалентно calendar.setfirstweekday(6)\r\n</strong>\r\n</pre>\r\nНа практике следует использовать константы calendar.MONDAY, calendar.TUESDAY, ...,calendar.SUNDAY , а не значения 0, 1, ..., 6.<br><br>\r\n\r\n<strong>Функция firstweekday()</strong><br><br>\r\n<strong>Функция firstweekday()</strong> возвращает целое число, означающее день недели, установленное в качестве начала недели.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport calendar\r\n\r\nprint(calendar.firstweekday())\r\ncalendar.setfirstweekday(calendar.SUNDAY)\r\nprint(calendar.firstweekday())\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n0\r\n6\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция isleap()</strong><br><br>\r\nМодуль calendar содержит <strong>функцию isleap()</strong>, которая осуществляет проверку високосного года.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport calendar\r\n\r\nprint(calendar.isleap(2020))\r\nprint(calendar.isleap(2021))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTrue\r\nFalse\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция leapdays()</strong><br><br>\r\n<strong>Функция leapdays(y1, y2)</strong> возвращает количество високосных лет в диапазоне от y1 до y2 (исключая), где y1 и y2 – годы.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport calendar\r\n\r\nprint(calendar.leapdays(2020, 2025))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n2\r\n</strong>\r\n</pre>\r\nтак как в нужном диапазоне [2020;2025) находятся два високосных года: \r\n2020 и 2024.<br><br>\r\n\r\n   Эта функция работает для диапазонов, охватывающих смену столетий.<br><br>\r\n\r\n<strong>Функция weekday()</strong><br><br>\r\n<strong>Функция weekday(year, month, day)</strong> возвращает день недели в виде целого числа (где 0 – понедельник, 6 – воскресенье) для заданной даты. Аргументы функции year – год начиная с 1970, month – месяц в диапазоне 1−12, day – число в диапазоне 1−31.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport calendar\r\n\r\nprint(calendar.weekday(2021, 9, 1))     # среда\r\nprint(calendar.weekday(2021, 9, 2))     # четверг\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n2\r\n3\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция monthrange()</strong><br><br>\r\n<strong>Функция monthrange(year, month)</strong> возвращает день недели первого дня месяца и количество дней в месяце в виде кортежа для указанного года year и месяца month.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport calendar\r\n\r\nprint(calendar.monthrange(2022, 1))     # январь 2022 года\r\nprint(calendar.monthrange(2021, 9))     # сентябрь 2021 года\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n(5, 31)\r\n(2, 30)\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция monthcalendar()</strong><br><br>\r\n<strong>Функция monthcalendar(year, month)</strong> возвращает матрицу, представляющую календарь на месяц. Каждая строка матрицы представляет неделю.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport calendar\r\n\r\nprint(*calendar.monthcalendar(2021, 9), sep='\\n')\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n[0, 0, 1, 2, 3, 4, 5]\r\n[6, 7, 8, 9, 10, 11, 12]\r\n[13, 14, 15, 16, 17, 18, 19]\r\n[20, 21, 22, 23, 24, 25, 26]\r\n[27, 28, 29, 30, 0, 0, 0]\r\n</strong>\r\n</pre>\r\nОбратите внимание на то, что дни, которые не входят в указанный месяц, представлены нулями. При этом каждая неделя начинается с понедельника, если не установлено другое функцией ​​setfirstweekday().<br><br>\r\n\r\n<strong>Функция month()</strong><br><br>\r\n<strong>Функция month(year, month, w=0, l=0)</strong> возвращает календарь на месяц в многострочной строке. Аргументами функции являются: year (год), month (месяц), w (ширина столбца даты) и l (количество строк, отводимые на неделю).<br><br>\r\n\r\n   Аргументы w и l имеют значения по умолчанию, поэтому их можно не передавать явно при вызове функции.<br><br>\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport calendar\r\n\r\nprint(calendar.month(2021, 9))\r\nprint(calendar.month(2021, 10))\r\nprint(calendar.month(2021, 9, w=3))\r\nprint(calendar.month(2021, 9, l=2))\r\nprint(calendar.month(2021, 9, w=5, l=2))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n   September 2021\r\nMo Tu We Th Fr Sa Su\r\n       1  2  3  4  5\r\n 6  7  8  9 10 11 12\r\n13 14 15 16 17 18 19\r\n20 21 22 23 24 25 26\r\n27 28 29 30\r\n\r\n    October 2021\r\nMo Tu We Th Fr Sa Su\r\n             1  2  3\r\n 4  5  6  7  8  9 10\r\n11 12 13 14 15 16 17\r\n18 19 20 21 22 23 24\r\n25 26 27 28 29 30 31\r\n\r\n       September 2021\r\nMon Tue Wed Thu Fri Sat Sun\r\n          1   2   3   4   5\r\n  6   7   8   9  10  11  12\r\n 13  14  15  16  17  18  19\r\n 20  21  22  23  24  25  26\r\n 27  28  29  30\r\n\r\n   September 2021\r\n\r\nMo Tu We Th Fr Sa Su\r\n\r\n       1  2  3  4  5\r\n\r\n 6  7  8  9 10 11 12\r\n\r\n13 14 15 16 17 18 19\r\n\r\n20 21 22 23 24 25 26\r\n\r\n27 28 29 30\r\n\r\n\r\n              September 2021\r\n\r\n Mon   Tue   Wed   Thu   Fri   Sat   Sun\r\n\r\n               1     2     3     4     5\r\n\r\n   6     7     8     9    10    11    12\r\n\r\n  13    14    15    16    17    18    19\r\n\r\n  20    21    22    23    24    25    26\r\n\r\n  27    28    29    30\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция calendar()</strong><br><br>\r\nФункция calendar(year, w=2, l=1, c=6, m=3) возвращает календарь на весь год в виде многострочной строки. Аргументами функции являются: year (год),  w (ширина столбца даты), l (количество строк, отводимые на неделю), c (количество пробелов между столбцом месяца) и  m (количество столбцов).<br><br>\r\n\r\n    Аргументы w, l, c, m имеют значения по умолчанию, поэтому их можно не передавать явно при вызове функции.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport calendar\r\n\r\nprint(calendar.calendar(2021))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n                                  2021\r\n\r\n      January                   February                   March\r\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\r\n             1  2  3       1  2  3  4  5  6  7       1  2  3  4  5  6  7\r\n 4  5  6  7  8  9 10       8  9 10 11 12 13 14       8  9 10 11 12 13 14\r\n11 12 13 14 15 16 17      15 16 17 18 19 20 21      15 16 17 18 19 20 21\r\n18 19 20 21 22 23 24      22 23 24 25 26 27 28      22 23 24 25 26 27 28\r\n25 26 27 28 29 30 31                                29 30 31\r\n\r\n       April                      May                       June\r\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\r\n          1  2  3  4                      1  2          1  2  3  4  5  6\r\n 5  6  7  8  9 10 11       3  4  5  6  7  8  9       7  8  9 10 11 12 13\r\n12 13 14 15 16 17 18      10 11 12 13 14 15 16      14 15 16 17 18 19 20\r\n19 20 21 22 23 24 25      17 18 19 20 21 22 23      21 22 23 24 25 26 27\r\n26 27 28 29 30            24 25 26 27 28 29 30      28 29 30\r\n                          31\r\n\r\n        July                     August                  September\r\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\r\n          1  2  3  4                         1             1  2  3  4  5\r\n 5  6  7  8  9 10 11       2  3  4  5  6  7  8       6  7  8  9 10 11 12\r\n12 13 14 15 16 17 18       9 10 11 12 13 14 15      13 14 15 16 17 18 19\r\n19 20 21 22 23 24 25      16 17 18 19 20 21 22      20 21 22 23 24 25 26\r\n26 27 28 29 30 31         23 24 25 26 27 28 29      27 28 29 30\r\n                          30 31\r\n\r\n      October                   November                  December\r\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\r\n             1  2  3       1  2  3  4  5  6  7             1  2  3  4  5\r\n 4  5  6  7  8  9 10       8  9 10 11 12 13 14       6  7  8  9 10 11 12\r\n11 12 13 14 15 16 17      15 16 17 18 19 20 21      13 14 15 16 17 18 19\r\n18 19 20 21 22 23 24      22 23 24 25 26 27 28      20 21 22 23 24 25 26\r\n25 26 27 28 29 30 31      29 30                     27 28 29 30 31\r\n</strong>\r\n</pre>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport calendar, locale\r\n\r\nlocale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8')\r\n\r\nprint(calendar.calendar(2022, m=4))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n                                               2022\r\n\r\n       Январь                   Февраль                     Март                     Апрель\r\nПн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс\r\n                1  2          1  2  3  4  5  6          1  2  3  4  5  6                   1  2  3\r\n 3  4  5  6  7  8  9       7  8  9 10 11 12 13       7  8  9 10 11 12 13       4  5  6  7  8  9 10\r\n10 11 12 13 14 15 16      14 15 16 17 18 19 20      14 15 16 17 18 19 20      11 12 13 14 15 16 17\r\n17 18 19 20 21 22 23      21 22 23 24 25 26 27      21 22 23 24 25 26 27      18 19 20 21 22 23 24\r\n24 25 26 27 28 29 30      28                        28 29 30 31               25 26 27 28 29 30\r\n31\r\n\r\n        Май                       Июнь                      Июль                     Август\r\nПн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс\r\n                   1             1  2  3  4  5                   1  2  3       1  2  3  4  5  6  7\r\n 2  3  4  5  6  7  8       6  7  8  9 10 11 12       4  5  6  7  8  9 10       8  9 10 11 12 13 14\r\n 9 10 11 12 13 14 15      13 14 15 16 17 18 19      11 12 13 14 15 16 17      15 16 17 18 19 20 21\r\n16 17 18 19 20 21 22      20 21 22 23 24 25 26      18 19 20 21 22 23 24      22 23 24 25 26 27 28\r\n23 24 25 26 27 28 29      27 28 29 30               25 26 27 28 29 30 31      29 30 31\r\n30 31\r\n\r\n      Сентябрь                  Октябрь                    Ноябрь                   Декабрь\r\nПн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс\r\n          1  2  3  4                      1  2          1  2  3  4  5  6                1  2  3  4\r\n 5  6  7  8  9 10 11       3  4  5  6  7  8  9       7  8  9 10 11 12 13       5  6  7  8  9 10 11\r\n12 13 14 15 16 17 18      10 11 12 13 14 15 16      14 15 16 17 18 19 20      12 13 14 15 16 17 18\r\n19 20 21 22 23 24 25      17 18 19 20 21 22 23      21 22 23 24 25 26 27      19 20 21 22 23 24 25\r\n26 27 28 29 30            24 25 26 27 28 29 30      28 29 30                  26 27 28 29 30 31\r\n                          31\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функции prmonth(), prcal()</strong><br><br>\r\n<strong>Функция prmonth(theyear, themonth, w=0, l=0)</strong> печатает календарь на месяц, возвращенный функцией month(theyear, themonth, w=0, l=0).<br><br>\r\n\r\n<strong>Функция prcal(year, w=0, l=0, c=6, m=3)</strong> печатает календарь на весь год, возвращенный функцией calendar(year, w=0, l=0, c=6, m=3).\r\n\r\nСледующий код:\r\n<pre>\r\n<strong>\r\nimport calendar\r\n\r\ncalendar.prmonth(2021, 9)\r\ncalendar.prcal(2021)\r\nэквивалентен коду:\r\n\r\nimport calendar\r\n\r\nprint(calendar.month(2021, 9))\r\nprint(calendar.calendar(2021))\r\n</strong>\r\n</pre>\r\nи выводит:\r\n<pre>\r\n<strong>\r\n   September 2021\r\nMo Tu We Th Fr Sa Su\r\n       1  2  3  4  5\r\n 6  7  8  9 10 11 12\r\n13 14 15 16 17 18 19\r\n20 21 22 23 24 25 26\r\n27 28 29 30\r\n                                  2021\r\n\r\n      January                   February                   March\r\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\r\n             1  2  3       1  2  3  4  5  6  7       1  2  3  4  5  6  7\r\n 4  5  6  7  8  9 10       8  9 10 11 12 13 14       8  9 10 11 12 13 14\r\n11 12 13 14 15 16 17      15 16 17 18 19 20 21      15 16 17 18 19 20 21\r\n18 19 20 21 22 23 24      22 23 24 25 26 27 28      22 23 24 25 26 27 28\r\n25 26 27 28 29 30 31                                29 30 31\r\n\r\n       April                      May                       June\r\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\r\n          1  2  3  4                      1  2          1  2  3  4  5  6\r\n 5  6  7  8  9 10 11       3  4  5  6  7  8  9       7  8  9 10 11 12 13\r\n12 13 14 15 16 17 18      10 11 12 13 14 15 16      14 15 16 17 18 19 20\r\n19 20 21 22 23 24 25      17 18 19 20 21 22 23      21 22 23 24 25 26 27\r\n26 27 28 29 30            24 25 26 27 28 29 30      28 29 30\r\n                          31\r\n\r\n        July                     August                  September\r\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\r\n          1  2  3  4                         1             1  2  3  4  5\r\n 5  6  7  8  9 10 11       2  3  4  5  6  7  8       6  7  8  9 10 11 12\r\n12 13 14 15 16 17 18       9 10 11 12 13 14 15      13 14 15 16 17 18 19\r\n19 20 21 22 23 24 25      16 17 18 19 20 21 22      20 21 22 23 24 25 26\r\n26 27 28 29 30 31         23 24 25 26 27 28 29      27 28 29 30\r\n                          30 31\r\n\r\n      October                   November                  December\r\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\r\n             1  2  3       1  2  3  4  5  6  7             1  2  3  4  5\r\n 4  5  6  7  8  9 10       8  9 10 11 12 13 14       6  7  8  9 10 11 12\r\n11 12 13 14 15 16 17      15 16 17 18 19 20 21      13 14 15 16 17 18 19\r\n18 19 20 21 22 23 24      22 23 24 25 26 27 28      20 21 22 23 24 25 26\r\n25 26 27 28 29 30 31      29 30                     27 28 29 30 31\r\n\r\n</strong>\r\n</pre>",
    "slug": "module-calendar"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 30,
  "fields": {
    "lesson": "Работа с файлами",
    "content": "<strong>Работа с файлами в Python</strong><br><br>\r\nВысокоуровневый язык программирования Python предоставляет своим пользователям массу полезных средств для взаимодействия с файлами. Встроенные функции и методы позволяют создавать файлы, читать из них данные, а также всячески манипулировать их содержимым.<br><br>\r\n\r\n<strong>Открытие файла</strong><br><br>\r\nДля открытия файлов в Python существует функция open(). Она создает файловый объект и связывает его с файлом на диске. Общий формат применения функции open():\r\n<pre>\r\n<strong>\r\nфайловая_переменная = open(имя_файла, режим_доступа)\r\n</strong>\r\n</pre>\r\nЗдесь:<br><br>\r\n\r\n<li>файловая переменная – имя переменной, которая ссылается на файловый объект;</li>\r\n<li>имя_файла – строковый литерал, задающий имя файла;</li>\r\n<li>режим_доступа – строковый литерал, задающий режим доступа (чтение, запись, и т.д.), в котором файл будет открыт.</li><br><br>\r\n\r\nПредположим, файл students.txt содержит данные о студентах, и мы хотим открыть его для чтения.\r\n\r\nЭто можно сделать с помощью строки кода:\r\n<pre>\r\n<strong>\r\nstudent_file = open('students.txt', 'r')\r\n</strong>\r\n</pre>\r\nПо умолчанию режим доступа (второй аргумент функции open()) определен для чтения (литерал 'r'), поэтому файл students.txt можно открыть для чтения так:\r\n<pre>\r\n<strong>\r\nstudent_file = open('students.txt')   # по умолчанию режим доступа для чтения ('r')\r\n</strong>\r\n</pre>\r\nВ результате исполнения этой инструкции будет открыт файл students.txt и переменная student_file будет ссылаться на файловый объект, который можно использовать для чтения данных из файла.<br><br>\r\n\r\nОбратите внимание, что в переменную student_file в примере выше не попадает содержимое файла students.txt. Фактически это ссылка на файл, ее еще называют дескриптор файла.<br><br>\r\n\r\nПредположим, надо создать файл с именем sales.txt и записать в него данные о продажах. Это можно сделать с помощью строки кода:\r\n<pre>\r\n<strong>\r\nsales_file = open('sales.txt', 'w')\r\n</strong>\r\n</pre>\r\nПосле исполнения этого кода будет создан файл sales.txt и переменная sales_file будет ссылаться на файловый объект, который можно использовать для записи в него данных.<br><br>\r\n\r\n<strong>Кодировка</strong><br><br>\r\nОткрыть файл, содержащий только латиницу и цифры, можно так:\r\n<pre>\r\n<strong>\r\nfile = open('info.txt', 'r')\r\n</strong>\r\n</pre>\r\nПри работе с текстом на русском языке нужно указать кодировку, для этого служит параметр encoding:\r\n<pre>\r\n<strong>\r\nfile = open('info.txt', 'r', encoding='utf-8')\r\n</strong>\r\n</pre>\r\n<strong>Указание кодировки</strong> при открытии файла – хороший тон. Рекомендуем придерживаться этого правила.\r\n\r\nЧтобы получить кодировку открытого файла, используют файловое свойство encoding.<br><br>\r\n\r\n<strong>Закрытие файлов</strong><br><br>\r\nПосле окончания работы с файлом его необходимо закрыть. Для этого есть несколько причин:\r\n\r\n<li>если файл изменялся, это позволит корректно его сохранить;</li>\r\n<li>если открытый файл потребуется другим программам, ваша программа может его блокировать;</li>\r\n<li>не стоит держать в памяти лишние, уже не нужные данные;</li>\r\n<li>удалить открытый кем-то файл проблематично.</li><br>\r\nДля закрытия файла используется файловый метод close():\r\n<pre>\r\n<strong>\r\nfile = open('info.txt', 'r')    # открываем файл с именем info.txt для чтения\r\n\r\n                                # работаем с содержимым файла info.txt\r\n\r\nfile.close()                    # закрываем файл после окончания работы\r\n</strong>\r\n</pre>\r\nЧтобы проверить открыт файл или закрыт можно использовать файловое свойство (атрибут) closed.<br><br>\r\n\r\n<strong>Чтение содержимого файла</strong><br><br>\r\nКак уже сказано, при открытии файла с помощью функции open() в файловую переменную попадает не содержимое файла, а ссылка на файл (дескриптор файла).\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfile = open('info.txt', 'w', encoding='utf-8')    # открываем файл для записи\r\n\r\nprint(file)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n<_io.TextIOWrapper name='info.txt' mode='w' encoding='utf-8'>\r\n</strong>\r\n</pre>\r\nДля чтения содержимого открытого для чтения файла используются три файловых метода:<br><br>\r\n\r\n<li>read() – читает все содержимое файла;</li>\r\n<li>readline() – читает одну строку из файла;</li>\r\n<li>readlines() – читает все содержимое файла и возвращает список строк.</li><br><br>\r\n\r\n<strong>Менеджер контекста</strong><br><br>\r\nКак уже сказано, важно своевременно закрывать файлы с помощью метода close(). Закрытие файлов вручную, а также отдача закрытия на откуп среде исполнения, обладают существенным недостатком: если между открытием файла и его закрытием произойдёт ошибка, в лучшем случае файл окажется открыт слишком долго, а в худшем случае часть данных не сохранится.<br><br>\r\n\r\nХочется иметь возможность автоматически закрывать файл сразу после окончания работы с ним и осуществлять закрытие даже при возникновении ошибки. Файловые объекты уже умеют работать в таком режиме, но для этого их нужно использовать как менеджеры контекста.<br><br>\r\n\r\n<strong>Менеджер контекста</strong> — объект, реализующий одноименный протокол. Объекты, реализующие этот протокол, позволяют использовать следующий специальный синтаксис:\r\n<pre>\r\n<strong>\r\nwith object as name:\r\n    # Здесь нам доступен ресурс name.\r\n    # Это тело with-блока.\r\n# А здесь ресурс name уже освобождён, даже если в теле with-блока произошла ошибка.\r\n</strong>\r\n</pre>\r\nВесь код в теле with-блока работает \"в контексте\". Чаще всего контекст подразумевает выделение некоего ресурса, например, файла. По выходу из контекста ресурс автоматически освобождается, даже если при выполнении блока возникло исключение.<br><br>\r\n\r\nКак только закончится код, оформленный с отступами в with (аналогичные отступы в циклах или функциях), это будет означать, что контекст закончился, и Python автоматически закроет файл.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfile = open('languages.txt', 'r', encoding='utf-8')\r\n\r\nfor line in file:\r\n    print(line)\r\n\r\nfile.close()              # ручное закрытие файла\r\n\r\nprint('Файл закрыт')\r\n</strong>\r\n</pre>\r\nможно переписать в виде:\r\n<pre>\r\n<strong>\r\nwith open('languages.txt', 'r', encoding='utf-8') as file:\r\n    for line in file:\r\n        print(line)\r\n                          # автоматическое закрытие файла\r\nprint('Файл закрыт')\r\n</strong>\r\n</pre>\r\nОбратите внимание: при использовании менеджера контекста не требуется использовать метод close().<br><br>\r\nПри работе с файлами желательно всегда использовать менеджер контекста. Это делает программу надежнее.<br><br>\r\n\r\n<strong>Запись данных в файлы</strong><br><br>\r\nДля записи используются два файловых метода:<br><br>\r\n\r\n<li>write() – записывает переданную строку в файл;</li>\r\n<li>writelines() – записывает переданный список строк в файл.</li><br><br>\r\n\r\n<strong>Запись в файл с помощью функции print()</strong><br><br>\r\nДля записи данных в файл можно также использовать встроенную функцию print(). Для этого нужно передать ей еще один именованный аргумент file, указывающий на открытый файл. При этом функция print() автоматически добавляет переход на новую строку.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nwith open('philosophers.txt', 'w', encoding='utf-8') as output:\r\n    print('Джoн Локк', file=output)\r\n    print('Дэвид Хьюм', file=output)\r\n    print('Эдмyнд Берк', file=output)\r\n</strong>\r\n</pre>\r\nсоздает файл philosophers.txt с содержимым:\r\n<pre>\r\n<strong>\r\nДжoн Локк\r\nДэвид Хьюм\r\nЭдмyнд Берк\r\n</strong>\r\n</pre>",
    "slug": "working-with-files"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 31,
  "fields": {
    "lesson": "Потоковый ввод stdin и вывод stdout",
    "content": "<strong>Потоковый ввод</strong><br><br>\r\nВ Python существует один очень полезный встроенный объект, который называется поток ввода (sys.stdin).<br><br>\r\n\r\n<strong>Поток ввода (sys.stdin)</strong> — это специальный объект в программе, куда попадает весь текст, который ввёл пользователь. Потоком его называют потому, что данные хранятся в нем до тех пор, пока программа их не прочитала. Таким образом, данные поступают в программу и временно сохраняются в потоке ввода (sys.stdin), а программа может забрать их оттуда, например, с помощью встроенной функции input(). В момент прочтения данные пропадают из потока ввода, так как он хранит их до тех пор, пока они не будут прочитаны.<br><br>\r\n\r\nПоток ввода (sys.stdin) — является итератором, который невозможно перезапустить. Как и любой итератор, он может двигаться только вперёд. Как только данные прочитаны, они удаляются из потока ввода безвозвратно.<br><br>\r\n\r\nЭлементы, которые выдает этот итератор — это строки, введённые пользователем. Если пользовательский ввод закончен, то итератор прекращает работу. Пока пользователь не ввёл последнюю строку, мы не знаем, сколько элементов в итераторе.<br><br>\r\n\r\nЧтобы работать с потоком ввода (sys.stdin), необходимо подключить модуль sys стандартной командой import sys.<br><br>\r\n\r\nНапишем программу, которая дублирует каждую введённую пользователем строку.\r\n<pre>\r\n<strong>\r\nimport sys\r\n\r\nfor line in sys.stdin:\r\n    print(line.strip('\\n'))\r\n</strong>\r\n</pre>\r\nСтроковый метод strip('\\n') отрезает от строки line символ перевода строки, поскольку функция print сама переводит строку.<br><br>\r\n\r\nПока есть данные в потоке ввода sys.stdin (то есть пока пользователь их вводит) программа будет записывать вводимые строки в переменную line, убирать символы перевода строки и выводить их на печать.<br><br>\r\n\r\nЕсли запустить такую программу, то она будет работать вечно. Чтобы показать, что ввод закончен, недостаточно нажать Enter — компьютер не знает, завершил ли пользователь работу или будет ещё что-то вводить (при этом Enter превратится в пустую строку). Для завершения ввода необходимо ввести Ctrl + D (если работаете в консоли Linux или IDE PyCharm), либо Ctrl + Z, затем Enter (если работаете в консоли Windows).<br><br>\r\n\r\n<strong>Читаем входные данные в одну строку</strong><br><br>\r\nС помощью потока ввода (sys.stdin) можно в одну строчку кода прочитать весь пользовательский ввод в список.<br><br>\r\n\r\nРеализуется это с помощью списочного выражения:\r\n<pre>\r\n<strong>\r\nimport sys\r\n\r\ndata = [line.strip() for line in sys.stdin]\r\n</strong>\r\n</pre>\r\nили с помощью функции высшего порядка map():\r\n<pre>\r\n<strong>\r\nimport sys\r\n\r\ndata = list(map(str.strip, sys.stdin))\r\n</strong>\r\n</pre>\r\nОбратите внимание, что мы ничего не знаем о количестве введенных строк. Раньше приходилось в задачах сначала указывать количество строк, а уже затем сами строки.\r\n\r\nРассмотрим программный код, который дважды вызывает функцию input():\r\n<pre>\r\n<strong>\r\nname, surname = input(), input()\r\n</strong>\r\n</pre>\r\nЕсли такой программе передать только одну строку, то выполнение программы завершится с ошибкой:\r\n<pre>\r\n<strong>\r\nEOFError: EOF when reading a line.\r\n</strong>\r\n</pre>\r\nпоскольку второй вызов функции input() не смог ничего прочитать.<br><br>\r\n\r\nТаким образом если мы не знаем, в какой момент надо прекратить ввод, то воспользоваться функцией input() не удастся. В таких случаях остаётся только работать с потоковым вводом (sys.stdin).<br><br>\r\n\r\n<strong>Методы read() и readlines()</strong><br><br>\r\nКак уже было сказано выше, мы можем обойти циклом for итератор sys.stdin. Кроме того, можно считать все строки из итератора (с сохранением символов перевода строки) в список с помощью метода readlines():\r\n<pre>\r\n<strong>\r\nimport sys\r\n\r\ndata = sys.stdin.readlines()\r\n</strong>\r\n</pre>\r\nОбратите внимание на то, что символ перехода на новую строку (\\n) сохраняется в считанных строках.\r\n\r\nЕсли разделять на строки нет необходимости, то считать многострочный текст из стандартного потока ввода в текстовую переменную можно с помощью метода read():\r\n<pre>\r\n<strong>\r\nimport sys\r\n\r\ndata = sys.stdin.read()\r\n</strong>\r\n</pre>\r\n\r\n<strong>Потоковый вывод</strong><br><br>\r\nАналогичным образом можно работать с потоковым выводом (sys.stdout). По умолчанию функция print() перенаправляет вывод данных именно в sys.stdout, хотя нам ничего не мешает самостоятельно писать в него.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport sys\r\n\r\nprint('Hello')\r\nsys.stdout.write('world!')\r\nprint('from')\r\nsys.stdout.write('python\\n')\r\nprint('Bye-bye')\r\n</strong>\r\n</pre>\r\nвыведет:\r\n<pre>\r\n<strong>\r\nHello\r\nworld!from\r\npython\r\nBye-bye\r\n</strong>\r\n</pre>\r\nОбратите внимание на то, что функция print() добавляет перевод на новую строку, а явная запись данных в sys.stdout с помощью метода write() нет. Чтобы добавить перевод на новую строку, мы используем стандартный символ \\n.\r\n\r\nТакже нужно иметь в виду, что при использовании потока вывода sys.stdout нам нужно самостоятельно преобразовывать данные к строковому типу данных (функция print() это делает автоматически).\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport sys\r\n\r\nsys.stdout.write(17)\r\n</strong>\r\n</pre>\r\nприводит к возникновению ошибки.\r\n\r\nИсправленная версия кода:\r\n<pre>\r\n<strong>\r\nimport sys\r\n\r\nsys.stdout.write(str(17))     # преобразуем данные в строку\r\n</strong>\r\n</pre>\r\n\r\nПо умолчанию функция input() читает данные из потока ввода sys.stdin, а функция print() печатает данные в поток вывода sys.stdout.<br><br>\r\n\r\nФункция print() — это удобная обертка (wrapper) вокруг метода sys.stdout.write(). Функцию input() часто можно рассматривать как обертку (wrapper) вокруг sys.stdin.readline().<br><br>\r\n\r\nОбъекты sys.stdin и sys.stdout являются файловыми объектами, предоставляемыми ОС. Им доступны все соответствующие методы (read(), readline(), readlines(), write(), writelines()). В общем случае, когда программа запускается в интерактивном сеансе, stdin является клавиатурным вводом, а stdout является выводом на экран, но оболочка может использоваться для перенаправления из обычных файлов или вывода на канал и ввода в другие программы.<br><br>",
    "slug": "stdin-stdout"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 32,
  "fields": {
    "lesson": "Работа с csv файлами",
    "content": "<strong>Формат CSV</strong><br><br>\r\nCSV (от англ. Comma-Separated Values — значения, разделённые запятыми) — текстовый формат, предназначенный для представления табличных данных. Строка таблицы соответствует строке текста, которая содержит одно или несколько полей, разделенных запятыми.<br><br>\r\n\r\nФормат данных csv, в котором разделителем является символ табуляции, называют tsv (англ. tab separated values — «значения, разделенные табуляцией»).<br><br>\r\n\r\ntsv — текстовый формат для представления табличных данных. Каждая запись в таблице — строка текстового файла. Каждое поле записи отделяется от других символом табуляции, а точнее — горизонтальной табуляции.<br><br>\r\n\r\ntsv и csv — формы более общего формата dsv (англ. delimiter separated values — «значения, разграниченные разделителем»).<br><br>\r\n\r\n<strong>Модуль csv</strong><br><br>\r\nНесмотря на то что csv формат очень прост и мы можем работать с ним, как с обычным текстовым файлом, на практике используется встроенный модуль csv.\r\n\r\nВ данном модуле есть два основных объекта: reader и writer, созданные, чтобы читать и создавать csv файлы соответственно.<br><br>\r\n\r\n<strong>Чтение данных с помощью reader</strong><br><br>\r\nДля импорта модуля мы используем строку кода:\r\n<pre>\r\n<strong>\r\nimport csv\r\n</strong>\r\n</pre>\r\n    Этот модуль входит в стандартную библиотеку, и его не нужно устанавливать каким‑то особенным способом.\r\n\r\nРассмотрим  файл products.csv, содержащий информацию о товарах интернет магазина:\r\n<pre>\r\n<strong>\r\nkeywords,price,product_name\r\nСадовый стул,1699,ВЭДДО\r\nСадовый стул,2999,ЭПЛАРО\r\nСадовый табурет,1699,ЭПЛАРО\r\nСадовый стол,1999,ТЭРНО\r\nСкладной стол,7499,ЭПЛАРО\r\nНастил,1299,РУННЕН\r\nСтеллаж,1299,ХИЛЛИС\r\nКружка,39,СТЕЛЬНА\r\nМолочник,299,ВАРДАГЕН\r\nТермос для еды,699,ЭФТЕРФРОГАД\r\nСитечко,59,ИДЕАЛИСК\r\nЧайник заварочный,499,РИКЛИГ\r\nКофе-пресс,699,УПХЕТТА\r\nЧашка с блюдцем,249,ИКЕА\r\nКружка,249,ЭМНТ\r\nСитечко,199,САККУННИГ\r\nКружка,199,ФИНСТИЛТ\r\nТарелка,269,ЭВЕРЕНС\r\n</strong>\r\n</pre>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport csv\r\n\r\nwith open('products.csv', encoding='utf-8') as file:\r\n    rows = csv.reader(file)                               # создаем reader объект\r\n    for row in rows:\r\n        print(row)\r\n</strong>\r\n</pre>\r\nчитает содержимое файла products.csv и выводит:\r\n<pre>\r\n<strong>\r\n['keywords', 'price', 'product_name']\r\n['Садовый стул', '1699', 'ВЭДДО']\r\n['Садовый стул', '2999', 'ЭПЛАРО']\r\n['Садовый табурет', '1699', 'ЭПЛАРО']\r\n['Садовый стол', '1999', 'ТЭРНО']\r\n['Складной стол', '7499', 'ЭПЛАРО']\r\n['Настил', '1299', 'РУННЕН']\r\n['Стеллаж', '1299', 'ХИЛЛИС']\r\n['Кружка', '39', 'СТЕЛЬНА']\r\n['Молочник', '299', 'ВАРДАГЕН']\r\n['Термос для еды', '699', 'ЭФТЕРФРОГАД']\r\n['Ситечко', '59', 'ИДЕАЛИСК']\r\n['Чайник заварочный', '499', 'РИКЛИГ']\r\n['Кофе-пресс', '699', 'УПХЕТТА']\r\n['Чашка с блюдцем', '249', 'ИКЕА']\r\n['Кружка', '249', 'ЭМНТ']\r\n['Ситечко', '199', 'САККУННИГ']\r\n['Кружка', '199', 'ФИНСТИЛТ']\r\n['Тарелка', '269', 'ЭВЕРЕНС']\r\n</strong>\r\n</pre>\r\nСамая важная строка кода в программе — это строка с созданием reader объекта:\r\n<pre>\r\n<strong>\r\nrows = csv.reader(file)\r\n</strong>\r\n</pre>\r\nОбъект reader дает доступ к построчному итератору, полностью аналогичному работе с файлом или списком.<br><br>\r\n\r\nПосле выполнения этой строки в переменную rows будет записан итератор, с помощью которого можно «пробежаться» циклом по файлу. В каждой итерации цикла при этом будет доступна соответствующая строка файла, уже разбитая по запятым и представляющая собой список. При этом автоматически будут учтены все нюансы с запятыми внутри кавычек и самими кавычками.<br><br>\r\n\r\nТак как каждая строка файла, полученная из итератора, является списком, к ней можно применять все способы работы со списками.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport csv\r\n\r\nwith open('products.csv', encoding='utf-8') as file:\r\n    rows = csv.reader(file)\r\n    for keywords, price, product_name in rows:\r\n        print(f'Ключевые слова: {keywords}, цена: {price}, название: {product_name}')\r\n</strong>\r\n</pre>\r\nиспользует распаковку списка и выводит:\r\n<pre>\r\n<strong>\r\nКлючевые слова: keywords, цена: price, название: product_name\r\nКлючевые слова: Садовый стул, цена: 1699, название: ВЭДДО\r\nКлючевые слова: Садовый стул, цена: 2999, название: ЭПЛАРО\r\nКлючевые слова: Садовый табурет, цена: 1699, название: ЭПЛАРО\r\nКлючевые слова: Садовый стол, цена: 1999, название: ТЭРНО\r\nКлючевые слова: Складной стол, цена: 7499, название: ЭПЛАРО\r\nКлючевые слова: Настил, цена: 1299, название: РУННЕН\r\nКлючевые слова: Стеллаж, цена: 1299, название: ХИЛЛИС\r\nКлючевые слова: Кружка, цена: 39, название: СТЕЛЬНА\r\nКлючевые слова: Молочник, цена: 299, название: ВАРДАГЕН\r\nКлючевые слова: Термос для еды, цена: 699, название: ЭФТЕРФРОГАД\r\nКлючевые слова: Ситечко, цена: 59, название: ИДЕАЛИСК\r\nКлючевые слова: Чайник заварочный, цена: 499, название: РИКЛИГ\r\nКлючевые слова: Кофе-пресс, цена: 699, название: УПХЕТТА\r\nКлючевые слова: Чашка с блюдцем, цена: 249, название: ИКЕА\r\nКлючевые слова: Кружка, цена: 249, название: ЭМНТ\r\nКлючевые слова: Ситечко, цена: 199, название: САККУННИГ\r\nКлючевые слова: Кружка, цена: 199, название: ФИНСТИЛТ\r\nКлючевые слова: Тарелка, цена: 269, название: ЭВЕРЕНС\r\n</strong>\r\n</pre>\r\nПри создании reader объекта мы можем его настраивать, указывая:<br><br>\r\n\r\n<li>аргумент delimiter — односимвольная строка, используемая для разделения полей, по умолчанию имеет значение ','</li>\r\n<li>аргумент quotechar — односимвольная строка, используемая для кавычек в полях, содержащих специальные символы, по умолчанию имеет значение '\"'.</li><br><br>\r\nПусть содержимое файла products.csv имеет вид (в качестве разделителя выбран символ ';'):\r\n<pre>\r\n<strong>\r\nkeywords;price;product_name\r\n\"Садовый стул, стул для дачи\";1699;ВЭДДО\r\nСадовый стул;2999;ЭПЛАРО\r\nСадовый табурет;1699;ЭПЛАРО\r\nСадовый стол;1999;ТЭРНО\r\n\"Складной стол, обеденный стол\";7499;ЭПЛАРО\r\nНастил;1299;РУННЕН\r\nСтеллаж;1299;ХИЛЛИС\r\n\"Кружка, сосуд, стакан с ручкой\";39;СТЕЛЬНА\r\nМолочник;299;ВАРДАГЕН\r\nТермос для еды;699;ЭФТЕРФРОГАД\r\nСитечко;59;ИДЕАЛИСК\r\nЧайник заварочный;499;РИКЛИГ\r\nКофе-пресс;699;УПХЕТТА\r\nЧашка с блюдцем;249;ИКЕА\r\n\"Кружка, стакан с ручкой\";249;ЭМНТ\r\nСитечко;199;САККУННИГ\r\nКружка;199;ФИНСТИЛТ\r\n\"Тарелка, блюдце\";269;ЭВЕРЕНС\r\n</strong>\r\n</pre>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport csv\r\n\r\nwith open('products.csv', encoding='utf-8') as file:\r\n    rows = csv.reader(file, delimiter=';', quotechar='\"')\r\n    for index, row in enumerate(rows):\r\n        if index > 5:\r\n            break\r\n        print(row)\r\n</strong>\r\n</pre>\r\nвыводит первые 6 строк файла, включая заголовок с названиями столбцов:\r\n<pre>\r\n<strong>\r\n['keywords', 'price', 'product_name']\r\n['Садовый стул, стул для дачи', '1699', 'ВЭДДО']\r\n['Садовый стул', '2999', 'ЭПЛАРО']\r\n['Садовый табурет', '1699', 'ЭПЛАРО']\r\n['Садовый стол', '1999', 'ТЭРНО']\r\n['Складной стол, обеденный стол', '7499', 'ЭПЛАРО']\r\n</strong>\r\n</pre>\r\nПри создании reader объекта мы указываем, что символ-разделитель записей delimiter в нашем файле — точка с запятой, а символ кавычек quotechar — двойные кавычки. Кроме того, мы используем встроенную функцию enumerate() для нумерации строк.<br><br>\r\n\r\nОбратите внимание на то, что для корректной обработки данных мы должны все еще исключить первую строку из обработки, которая содержит названия столбцов.<br><br>\r\n\r\n<strong>Чтение данных с помощью DictReader</strong><br><br>\r\nИcпользовать reader объект не всегда удобно, так как он возвращает сырые списки из строк файла, к тому же первой строкой является строка с названиями столбцов, которая практически всегда удаляется, так как мешает правильной обработке данных.<br><br>\r\n\r\nВ модуле csv есть специальный объект DictReader, который поддерживает создание объекта-словаря на основе названий столбцов. С помощью DictReader объекта мы можем обращаться к полям не по индексу, а по названию, что делает код более понятным.<br><br>\r\n\r\nПусть содержимое файла products.csv имеет вид (в качестве разделителя выбран символ ';'):\r\n<pre>\r\n<strong>\r\nkeywords;price;product_name\r\n\"Садовый стул, стул для дачи\";1699;ВЭДДО\r\nСадовый стул;2999;ЭПЛАРО\r\nСадовый табурет;1699;ЭПЛАРО\r\nСадовый стол;1999;ТЭРНО\r\n\"Складной стол, обеденный стол\";7499;ЭПЛАРО\r\nНастил;1299;РУННЕН\r\nСтеллаж;1299;ХИЛЛИС\r\n\"Кружка, сосуд, стакан с ручкой\";39;СТЕЛЬНА\r\nМолочник;299;ВАРДАГЕН\r\nТермос для еды;699;ЭФТЕРФРОГАД\r\nСитечко;59;ИДЕАЛИСК\r\nЧайник заварочный;499;РИКЛИГ\r\nКофе-пресс;699;УПХЕТТА\r\nЧашка с блюдцем;249;ИКЕА\r\n\"Кружка, стакан с ручкой\";249;ЭМНТ\r\nСитечко;199;САККУННИГ\r\nКружка;199;ФИНСТИЛТ\r\n\"Тарелка, блюдце\";269;ЭВЕРЕНС\r\n</strong>\r\n</pre>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport csv\r\n\r\nwith open('products.csv', encoding='utf-8') as file:\r\n    rows = csv.DictReader(file, delimiter=';', quotechar='\"')\r\n    for row in rows:\r\n        print(row)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n{'keywords': 'Садовый стул, стул для дачи', 'price': '1699', 'product_name': 'ВЭДДО'}\r\n{'keywords': 'Садовый стул', 'price': '2999', 'product_name': 'ЭПЛАРО'}\r\n{'keywords': 'Садовый табурет', 'price': '1699', 'product_name': 'ЭПЛАРО'}\r\n{'keywords': 'Садовый стол', 'price': '1999', 'product_name': 'ТЭРНО'}\r\n{'keywords': 'Складной стол, обеденный стол', 'price': '7499', 'product_name': 'ЭПЛАРО'}\r\n{'keywords': 'Настил', 'price': '1299', 'product_name': 'РУННЕН'}\r\n{'keywords': 'Стеллаж', 'price': '1299', 'product_name': 'ХИЛЛИС'}\r\n{'keywords': 'Кружка, сосуд, стакан с ручкой', 'price': '39', 'product_name': 'СТЕЛЬНА'}\r\n{'keywords': 'Молочник', 'price': '299', 'product_name': 'ВАРДАГЕН'}\r\n{'keywords': 'Термос для еды', 'price': '699', 'product_name': 'ЭФТЕРФРОГАД'}\r\n{'keywords': 'Ситечко', 'price': '59', 'product_name': 'ИДЕАЛИСК'}\r\n{'keywords': 'Чайник заварочный', 'price': '499', 'product_name': 'РИКЛИГ'}\r\n{'keywords': 'Кофе-пресс', 'price': '699', 'product_name': 'УПХЕТТА'}\r\n{'keywords': 'Чашка с блюдцем', 'price': '249', 'product_name': 'ИКЕА'}\r\n{'keywords': 'Кружка, стакан с ручкой', 'price': '249', 'product_name': 'ЭМНТ'}\r\n{'keywords': 'Ситечко', 'price': '199', 'product_name': 'САККУННИГ'}\r\n{'keywords': 'Кружка', 'price': '199', 'product_name': 'ФИНСТИЛТ'}\r\n{'keywords': 'Тарелка, блюдце', 'price': '269', 'product_name': 'ЭВЕРЕНС'}\r\n</strong>\r\n</pre>\r\nОбратите внимание на то, что переменная row имеет тип dict в Python 3.8+. В более ранних версиях переменная row имела тип OrderedDict, который мы изучим чуть позже.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport csv\r\n\r\nwith open('products.csv', encoding='utf-8') as file:\r\n    rows = csv.DictReader(file, delimiter=';', quotechar='\"')\r\n    expensive = sorted(rows, key=lambda item: int(item['price']), reverse=True)\r\n    for record in expensive[:5]:\r\n        print(record)\r\n</strong>\r\n</pre>\r\nвыводит5 самых дорогих товаров:\r\n<pre>\r\n<strong>\r\n{'keywords': 'Складной стол, обеденный стол', 'price': '7499', 'product_name': 'ЭПЛАРО'}\r\n{'keywords': 'Садовый стул', 'price': '2999', 'product_name': 'ЭПЛАРО'}\r\n{'keywords': 'Садовый стол', 'price': '1999', 'product_name': 'ТЭРНО'}\r\n{'keywords': 'Садовый стул, стул для дачи', 'price': '1699', 'product_name': 'ВЭДДО'}\r\n{'keywords': 'Садовый табурет', 'price': '1699', 'product_name': 'ЭПЛАРО'}\r\n</strong>\r\n</pre>\r\nПри создании DictReader объекта значениями по умолчанию для аргументов delimiter и quotechar являются ',' (символ запятой) и '\"' (символ двойной кавычки) соответственно.\r\n\r\nОбратите внимание на то, что при использовании DictReader мы не избавляемся от первой строки, содержащей названия столбцов. Они хранятся в атрибуте fieldnames объекта DictReader. При этом к элементам строк мы обращаемся теперь не по индексам (int(item[1])), а по их названиям (int(item['price'])), что намного удобнее.<br><br>\r\n\r\n<strong>Запись данных с помощью writer</strong><br><br>\r\nДля записи данных в csv файл можно использовать специальный writer объект.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport csv\r\n\r\ncolumns = ['first_name', 'second_name', 'class_number', 'class_letter']\r\ndata = [['Тимур', 'Гуев', 11, 'А'], ['Руслан', 'Чаниев', 9, 'Б'], ['Артур', 'Харисов', 10, 'В']]\r\n\r\nwith open('students.csv', 'w', encoding='utf-8', newline='') as file:\r\n    writer = csv.writer(file)\r\n    writer.writerow(columns)                 # запись заголовков\r\n    for row in data:                         # запись строк\r\n        writer.writerow(row)\r\n</strong>\r\n</pre>\r\nсоздает файл students.csv с содержимым:\r\n<pre>\r\n<strong>\r\nfirst_name,second_name,class_number,class_letter\r\nТимур,Гуев,11,А\r\nРуслан,Чаниев,9,Б\r\nАртур,Харисов,10,В\r\n</strong>\r\n</pre>\r\nОбратите внимание на необязательный параметр newline функции open(), который имеет значение '' (пустой строки). Он отвечает за переводы строк при чтении или записи в текстовый файл. По умолчанию имеет значение None, в этом случае все разделители строк преобразуются в '\\n'. Если в файле оказывается лишний перевод строки, то следует использовать этот параметр в режиме newline='', тогда '\\n' будет преобразован в пустую строку.<br><br>\r\n\r\nПри создании writer объекта мы так же можем его настраивать, задавая delimiter и многие другие параметры.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport csv\r\n\r\ncolumns = ['first_name', 'second_name', 'class_number', 'class_letter']\r\ndata = [['Тимур', 'Гуев', 11, 'А'], ['Руслан', 'Чаниев', 9, 'Б'], ['Роман', 'Белых', 10, 'В']]\r\n\r\nwith open('students.csv', 'w', encoding='utf-8', newline='') as file:\r\n    writer = csv.writer(file, delimiter=';', quoting=csv.QUOTE_NONNUMERIC)\r\n    writer.writerow(columns)\r\n    for row in data:\r\n        writer.writerow(row)\r\n</strong>\r\n</pre>\r\nсоздает файл с содержимым:\r\n<pre>\r\n<strong>\r\n\"first_name\";\"second_name\";\"class_number\";\"class_letter\"\r\n\"Тимур\";\"Гуев\";11;\"А\"\r\n\"Руслан\";\"Чаниев\";9;\"Б\"\r\n\"Роман\";\"Белых\";10;\"В\"\r\n</strong>\r\n</pre>\r\nЗначение аргумента quoting=csv.QUOTE_NONNUMERIC означает, что в кавычки будут браться все нечисловые значения. По умолчанию символом кавычки является \", если нужно поменять символ, то используйте уже знакомый нам именованный аргумент quotechar.<br><br>\r\n\r\nДля задания параметра quoting используются специальные константы из модуля csv:<br><br>\r\n\r\n<li>QUOTE_ALL: указывает объектам записи указывать все поля</li>\r\n<li>QUOTE_MINIMAL: указывает объектам записи заключать в кавычки только те поля, которые содержат специальные символы, такие как разделитель delimiter, кавычка quotechar или любой из символов в lineterminator</li>\r\n<li>QUOTE_NONNUMERIC: указывает объектам записи указывать все нечисловые поля</li>\r\n<li>QUOTE_NONE: указывает объектам записи никогда не заключать в кавычки поля</li><br><br>\r\nПомимо метода writerow() можно использовать и метод writerows(), чтобы записать сразу несколько строк. Единственным аргументом этого метода может быть коллекция коллекций. То есть, каждый элемент списка rows в нашем случае должен быть коллекцией. Если rows будет, например, списком чисел, программа завершится с ошибкой.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport csv\r\n\r\ncolumns = ['first_name', 'second_name', 'class_number', 'class_letter']\r\ndata = [['Тимур', 'Гуев', 11, 'А'], ['Руслан', 'Чаниев', 9, 'Б'], ['Роман', 'Белых', 10, 'В']]\r\n\r\nwith open('students.csv', 'w', encoding='utf-8', newline='') as file:\r\n    writer = csv.writer(file, delimiter=';', quoting=csv.QUOTE_NONNUMERIC)\r\n    writer.writerow(columns)\r\n    writer.writerows(data)\r\n</strong>\r\n</pre>\r\nсоздает файл students.csv с содержимым:\r\n<pre>\r\n<strong>\r\n\"first_name\";\"second_name\";\"class_number\";\"class_letter\"\r\n\"Тимур\";\"Гуев\";11;\"А\"\r\n\"Руслан\";\"Чаниев\";9;\"Б\"\r\n\"Роман\";\"Белых\";10;\"В\"\r\n</strong>\r\n</pre>\r\n\r\n<strong>Запись данных с помощью DictWriter</strong><br><br>\r\nДля записи данных в csv файл также можно использовать DictWriter объект, который позволяет записывать содержимое словаря в файл.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport csv\r\n\r\ndata = [{'first_name': 'Тимур', 'second_name': 'Гуев', 'class_number': 11, 'class_letter': 'А'},\r\n        {'first_name': 'Руслан', 'second_name': 'Чаниев', 'class_number': 9, 'class_letter': 'Б'},\r\n        {'first_name': 'Роман', 'second_name': 'Белых', 'class_number': 10, 'class_letter': 'В'}]\r\n\r\ncolumns = ['first_name', 'second_name', 'class_number', 'class_letter']\r\n\r\nwith open('students.csv', 'w', encoding='utf-8', newline='') as file:\r\n    writer = csv.DictWriter(file, fieldnames=columns, delimiter=';', quoting=csv.QUOTE_NONNUMERIC)\r\n    writer.writeheader()                 # запись заголовков\r\n    for row in data:                     # запись строк\r\n        writer.writerow(row)\r\n</strong>\r\n</pre>\r\nсоздает файл students.csv с содержимым:\r\n<pre>\r\n<strong>\r\n\"first_name\";\"second_name\";\"class_number\";\"class_letter\"\r\n\"Тимур\";\"Гуев\";11;\"А\"\r\n\"Руслан\";\"Чаниев\";9;\"Б\"\r\n\"Роман\";\"Белых\";10;\"В\"\r\n</strong>\r\n</pre>\r\nМы также можем использовать метод writerows() объекта DictWriter для записи сразу нескольких строк. Таким образом вместо строк кода:\r\n<pre>\r\n<strong>\r\nfor row in data:\r\n    writer.writerow(row)\r\n</strong>\r\n</pre>\r\nможно написать:\r\n<pre>\r\n<strong>\r\nwriter.writerows(data)\r\n</strong>\r\n</pre>\r\nОбратите внимание на то, что ключи словарей, которые записываются в файл, должны совпадать с названиями полей, которые переданы в качестве аргумента fieldnames, иначе будет возникать ошибка ValueError.",
    "slug": "csv-files"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 33,
  "fields": {
    "lesson": "Работа с json файлами",
    "content": "<strong>Формат json</strong><br><br>\r\nJSON (англ. JavaScript Object Notation) — текстовый формат обмена данными, основанный на языке программирования JavaScript. Как и многие другие текстовые форматы, JSON легко читается людьми. Несмотря на происхождение от JavaScript, формат считается независимым от языка и может использоваться практически с любым языком программирования. За счёт своей лаконичности формат JSON отлично подходит для сериализации сложных структур.<br><br>\r\n\r\n<strong>Синтаксис json формата</strong><br><br>\r\nВ отличие от формата csv, данные в формате json не просто разделены запятыми, а чаще всего имеют структуру ключ-значение. Это напоминает словарь Python, но в отличие от словаря, ключи в json могут быть только строками, заключенными в двойные кавычки:\r\n<pre>\r\n<strong>\r\n{\r\n   \"firstName\": \"Тимур\",\r\n   \"lastName\": \"Гуев\",\r\n   \"gender\": \"мужской\"\r\n}\r\n</strong>\r\n</pre>\r\nЗначениями в json формате могут быть не только строки. Это могут быть числа, списки значений, литералы true/false/null, а также вложенные объекты:\r\n<pre>\r\n<strong>\r\n{\r\n   \"firstName\": \"Тимур\",\r\n   \"lastName\": \"Гуев\",\r\n   \"age\": 29,\r\n   \"gender\": \"мужской\",\r\n   \"smoke\": false,\r\n   \"address\": {\r\n       \"streetAddress\": \"Часовая 25, кв. 127\",\r\n       \"city\": \"Москва\",\r\n       \"postalCode\": 125315\r\n   },\r\n   \"phoneNumbers\": [\"+7 (919) 424-84-34\", \"+7 (916) 928-92-34\"]\r\n}\r\n</strong>\r\n</pre>\r\nСписки значений, как видно из примера, напоминают списки Python. Они ограничены квадратными скобками, а значения списка указываются через запятую.<br><br>\r\n\r\nВложенность данных может быть бесконечной. То есть значением ключа может быть список, а элементом этого списка — объект и т.д.<br><br>\r\n\r\nОбратите внимание на то, что переносы строк и отступы в формате json необязательны. Они нужны только для удобства чтения. Таким образом, с точки зрения формата json следующие данные:\r\n<pre>\r\n<strong>\r\n{\r\n   \"firstName\": \"Тимур\",\r\n   \"lastName\": \"Гуев\",\r\n   \"gender\": \"мужской\"\r\n}\r\n</strong>\r\n</pre>\r\nи эти данные:\r\n<pre>\r\n<strong>\r\n{\"firstName\": \"Тимур\", \"lastName\": \"Гуев\", \"gender\": \"мужской\"}\r\n</strong>\r\n</pre>\r\nсовершенно одинаковые.<br><br>\r\n\r\n​​​   ​​​​Обратите внимание, в формате JSON используются только двойные кавычки.<br><br>\r\n\r\nИтак, в качестве значений в JSON могут быть использованы:<br><br>\r\n\r\nчисло (целое или вещественное)</li>\r\nлитералы true (истина), false (ложь), null (отсутствие значения)</li>\r\nстрока (последовательность символов, заключенная в двойные кавычки)</li>\r\nсписок (заключается в квадратные скобки [ ], значения разделяются запятыми). Список может быть пустым, значения в пределах одного списка могут иметь разный тип</li>\r\nвложенный объект (неупорядоченное множество пар ключ: значение, заключённое в фигурные скобки { }). Ключ описывается строкой, между ним и значением стоит символ :. Пары ключ-значение отделяются друг от друга запятыми.</li><br><br>\r\n   Пробелы могут быть вставлены между любыми двумя синтаксическими элементами.<br><br>\r\n\r\nСледующий пример показывает JSON-представление данных об объекте, описывающем человека. В данных присутствуют строковые поля имени и фамилии, информация об адресе (вложенный объект) и список телефонов.\r\n<pre>\r\n<strong>\r\n{\r\n   \"firstName\": \"Тимур\",\r\n   \"lastName\": \"Гуев\",\r\n   \"address\": {\r\n       \"streetAddress\": \"Часовая 25, кв. 127\",\r\n       \"city\": \"Москва\",\r\n       \"postalCode\": 125315\r\n   },\r\n   \"phoneNumbers\": [\"+7 (919) 424-84-34\", \"+7 (916) 928-92-34\"]\r\n}\r\n</strong>\r\n</pre>\r\nОбратите внимание на пару \"postalCode\": 125315. В качестве значений в JSON могут быть использованы как числа, так и строки. Поэтому запись \"postalCode\": \"125315\" содержит строку, а \"postalCode\": 125315 — уже числовое значение.<br><br>\r\n\r\nJSON — это текстовый формат, который может быть представлен не только в виде пар ключ-значение. Он так же может содержать список, строку, число и т.д. Но чаще всего используется структура ключ-значение.<br><br>\r\n\r\n<strong>Модуль json</strong><br><br>\r\nПреобразование переменных программы (Python-объектов) в формат для хранения называется «сериализацией», а обратное преобразование — «десериализацией». В Python для сериализации и десериализации в формат json есть модуль, который так и называется — json.<br><br>\r\n\r\n<strong>Функция dumps()</strong><br><br>\r\nДля сериализации данных в json строку используется функция dumps() из модуля json. Для того, чтобы сериализовать данные с ее помощью, достаточно передать в нее аргументом любой сериализуемый Python объект. <br><br>\r\n\r\n   Так как json — текстовый формат, то сериализация в него — это по сути преобразование данных в строку.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport json\r\n\r\ndata = {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'}\r\n\r\njson_data = json.dumps(data)            # сериализуем словарь data в json строку\r\n\r\nprint(type(json_data))\r\nprint(json_data)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nclass 'str'\r\n{\"name\": \"Russia\", \"phone_code\": 7, \"capital\": \"Moscow\", \"currency\": \"RUB\"}\r\n</strong>\r\n</pre>\r\nОбратите внимание на кавычки, независимо от того, что в Python-словаре мы использовали одинарные, в результирующую строку всегда попадают двойные.<br><br>\r\n\r\n<strong>Функция dump()</strong><br><br>\r\nВ отличие от функции dumps(), которая преобразует (сериализует) Python объект в json строку, функция dump() записывает переданный Python объект в файл.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport json\r\n\r\ndata = {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'}\r\n\r\nwith open('countries.json', 'w') as file:\r\n    json.dump(data, file)\r\n</strong>\r\n</pre>\r\nсоздает файл countries.json и сохраняет в него информацию из словаря data в json формате.<br><br>\r\n\r\nЕсли открыть файл countries.json, мы увидим, что json выведен в одну строку без форматирования:\r\n<pre>\r\n<strong>\r\n{\"name\": \"Russia\", \"phone_code\": 7, \"capital\": \"Moscow\", \"currency\": \"RUB\"}\r\n</strong>\r\n</pre>\r\n\r\n<strong>Необязательные аргументы indent, sort_keys и separators</strong><br><br>\r\nФункции записи dumps() и dump() имеют необязательные аргументы indent, sort_keys и separators, которые можно использовать для более удобного чтения человеком.<br><br>\r\n\r\n<strong>Аргумент indent</strong> задает отступ от левого края. По умолчанию имеет значение None для более компактного представления без отступов.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport json\r\n\r\ndata = {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'}\r\n\r\njson_data1 = json.dumps(data, indent=2)\r\njson_data2 = json.dumps(data, indent=10)\r\n\r\nprint(json_data1)\r\nprint(json_data2)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n{\r\n  \"name\": \"Russia\",\r\n  \"phone_code\": 7,\r\n  \"capital\": \"Moscow\",\r\n  \"currency\": \"RUB\"\r\n}\r\n{\r\n          \"name\": \"Russia\",\r\n          \"phone_code\": 7,\r\n          \"capital\": \"Moscow\",\r\n          \"currency\": \"RUB\"\r\n}\r\n</strong>\r\n</pre>\r\nЕсли значением indent является строка, то она используется в качестве отступа.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport json\r\n\r\ndata = {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'}\r\n\r\njson_data = json.dumps(data, indent='++++')\r\n\r\nprint(json_data)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n{\r\n++++\"name\": \"Russia\",\r\n++++\"phone_code\": 7,\r\n++++\"capital\": \"Moscow\",\r\n++++\"currency\": \"RUB\"\r\n}\r\n</strong>\r\n</pre>\r\n   Отступов также не будет, если значение аргумента indent равно 0, отрицательному числу или пустой строке.<br><br>\r\n\r\n<strong>Аргумент sort_keys</strong> задает сортировку ключей в результирующем json. По умолчанию имеет значение False для более быстрого создания json. Если установить значение аргумента в True, то ключи будут отсортированы в алфавитном порядке, что особенно удобно, когда ключей много.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport json\r\n\r\ndata = {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'}\r\n\r\njson_data1 = json.dumps(data, indent=3)\r\njson_data2 = json.dumps(data, indent=3, sort_keys=True)\r\n\r\nprint(json_data1)\r\nprint(json_data2)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n{\r\n   \"name\": \"Russia\",\r\n   \"phone_code\": 7,\r\n   \"capital\": \"Moscow\",\r\n   \"currency\": \"RUB\"\r\n}\r\n{\r\n   \"capital\": \"Moscow\",\r\n   \"currency\": \"RUB\",\r\n   \"name\": \"Russia\",\r\n   \"phone_code\": 7\r\n}\r\n</strong>\r\n</pre>\r\n<strong>Аргумент separators</strong> задает кортеж, состоящий из двух элементов (item_separator, key_separator), которые представляют разделители для элементов и ключей.  По умолчанию аргумент имеет значение (', ', ': ').\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport json\r\n\r\ndata = {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'}\r\n\r\njson_data = json.dumps(data, indent=3, separators=(';', ' = '))\r\n\r\nprint(json_data)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n{\r\n   \"name\" = \"Russia\";\r\n   \"phone_code\" = 7;\r\n   \"capital\" = \"Moscow\";\r\n   \"currency\" = \"RUB\"\r\n}\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция loads()</strong><br><br>\r\nДля десериализации данных нужно использовать функцию loads(). Ее аргумент — это строка с данными в формате json.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport json\r\n\r\njson_data = '{\"name\": \"Russia\", \"phone_code\": 7, \"capital\": \"Moscow\", \"currency\": \"RUB\"}'\r\n\r\ndata = json.loads(json_data)\r\nprint(type(data))\r\nprint(data)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nclass 'dict'\r\n{'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'}\r\n</strong>\r\n</pre>\r\nКак видно из примера, функция loads() десериализует json строку в словарь.<br><br>\r\n\r\nВ случае если строка для десериализации содержит данные с ошибкой, то модуль json не сможет правильно прочитать такую строку, и программа завершится с ошибкой.\r\n\r\nПриведенный ниже код (запятая стоит после двоеточия):\r\n<pre>\r\n<strong>\r\nimport json\r\n\r\njson_data = '{\"name\":, \"Russia\", \"phone_code\": 7, \"capital\": \"Moscow\", \"currency\": \"RUB\"}'  # строка\r\n\r\ndata = json.loads(json_data)\r\nprint(type(data))\r\nprint(data)\r\n</strong>\r\n</pre>\r\nприводит к возникновению ошибки (исключения):\r\n<pre>\r\n<strong>\r\njson.decoder.JSONDecodeError\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция load()</strong><br><br>\r\nВ отличие от функции loads(), которая в качестве аргумента принимает строку с данными в формате json, функция load() принимает файловый объект и возвращает его десериализованное содержимое.\r\n\r\nПусть файл data.json имеет следующее содержимое:\r\n<pre>\r\n<strong>\r\n{\r\n  \"name\": \"Russia\",\r\n  \"phone_code\": 7,\r\n  \"capital\": \"Moscow\",\r\n  \"cities\": [\"Abakan\", \"Almetyevsk\", \"Anadyr\", \"Anapa\", \"Arkhangelsk\", \"Astrakhan\"],\r\n  \"currency\": \"RUB\"\r\n}\r\n</strong>\r\n</pre>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport json\r\n\r\nwith open('data.json') as file:\r\n    data = json.load(file)                # передаем файловый объект\r\n    for key, value in data.items():\r\n        if type(value) == list:\r\n            print(f'{key}: {\", \".join(value)}')\r\n        else:\r\n            print(f'{key}: {value}')\r\n</strong>\r\n</pre>\r\nчитает содержимое data.json файла в словарь data и выводит его содержимое:\r\n<pre>\r\n<strong>\r\nname: Russia\r\nphone_code: 7\r\ncapital: Moscow\r\ncities: Abakan, Almetyevsk, Anadyr, Anapa, Arkhangelsk, Astrakhan\r\ncurrency: RUB\r\n</strong>\r\n</pre>\r\n\r\n<strong>Изменение типа данных</strong><br><br>\r\nЕще один важный аспект преобразования данных в формат JSON: данные не всегда будут того же типа, что исходные данные в Python. Например, кортежи при записи в JSON превращаются в списки.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport json\r\n\r\ndata = {\r\n        'name': 'Russia', \r\n        'phone_code': 7,\r\n        'latitude': 60.0,\r\n        'capital': 'Moscow',\r\n        'timezones': ('Anadyr', 'Barnaul', 'Moscow', 'Kirov')\r\n       }\r\n\r\njson_data = json.dumps(data)        # преобразуем dict в json\r\nnew_data = json.loads(json_data)    # преобразуем json в dict\r\n\r\nprint(data == new_data)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nFalse\r\n</strong>\r\n</pre>\r\nТак происходит из-за того, что в JSON используются другие типы данных, и не для всех типов данных Python есть соответствия.<br><br>\r\n\r\n<strong>Ограничение по типам данных</strong><br><br>\r\nВ формат JSON нельзя записать словарь, у которого ключи – кортежи.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport json\r\n\r\ndata = {\r\n        'beegeek': 2018,\r\n        ('Timur', 'Guev'): 29,\r\n        ('Arthur', 'Kharisov'): 20,\r\n        'stepik': 2013\r\n       }\r\n\r\njson_data = json.dumps(data)        # преобразуем dict в json\r\n\r\nprint(json_data)\r\n</strong>\r\n</pre>\r\nгенерирует ошибку:\r\n<pre>\r\n<strong>\r\nTypeError: keys must be str, int, float, bool or None, not tuple\r\n</strong>\r\n</pre>\r\nС помощью необязательного аргумента skipkeys можно игнорировать подобные ключи.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport json\r\n\r\ndata = {\r\n        'beegeek': 2018,\r\n        ('Timur', 'Guev'): 29,\r\n        ('Arthur', 'Kharisov'): 20,\r\n        'stepik': 2013\r\n       }\r\n\r\njson_data = json.dumps(data, skipkeys=True)        # преобразуем dict в json\r\n\r\nprint(json_data)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n{\"beegeek\": 2018, \"stepik\": 2013}\r\n</strong>\r\n</pre>\r\nКроме того, в JSON ключами словаря могут быть только строки. Но, если в словаре Python использовались числа, булевы значения или None, то ошибки не будет, вместо этого они будут преобразованы в строки.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport json\r\n\r\ndata = {1: 'Timur', False: 'Arthur', None: 'Ruslan'}\r\njson_data = json.dumps(data)\r\n\r\nprint(json_data)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n{\"1\": \"Timur\", \"false\": \"Arthur\", \"null\": \"Ruslan\"}\r\n</strong>\r\n</pre>\r\n\r\n<strong>Кириллические символы в json</strong><br><br>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport json\r\n\r\ndata = {'firstName': 'Тимур', 'lastName': 'Гуев'}\r\ns = json.dumps(data)\r\nprint(s)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n{\"firstName\": \"\\u0422\\u0438\\u043c\\u0443\\u0440\", \"lastName\": \"\\u0413\\u0443\\u0435\\u0432\"}\r\n</strong>\r\n</pre>\r\nРезультат, скорее всего, будет неожиданным. Каждая буква из строк Тимур и Гуев будет заменена на ее код. Эти коды стандартны, и код для каждой из букв индивидуален. Например. 0438 — код буквы и.  А на этой странице можно посмотреть полное описание этого кода и символа.<br><br>\r\n\r\nОбратное преобразование из строки в словарь вернет закодированное значение в первоначальный вид.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport json\r\n\r\ndata = {'firstName': 'Тимур', 'lastName': 'Гуев'}\r\ns = json.dumps(data)\r\nprint(s)\r\nresult = json.loads(s)\r\nprint(result)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n{\"firstName\": \"\\u0422\\u0438\\u043c\\u0443\\u0440\", \"lastName\": \"\\u0413\\u0443\\u0435\\u0432\"}\r\n{'firstName': 'Тимур', 'lastName': 'Гуев'}\r\n</strong>\r\n</pre>\r\nБлагодаря стандартным кодам, символы будут прочитаны и преобразованы в нужный вид любой программой на любом языке программирования.<br><br>\r\n\r\nС помощью необязательного аргумента ensure_ascii функций dumps() и dump() можно отказаться от такого кодирования.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport json\r\n\r\ndata = {'firstName': 'Тимур', 'lastName': 'Гуев'}\r\ns = json.dumps(data, ensure_ascii=False)\r\nprint(s)\r\nresult = json.loads(s)\r\nprint(result)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n{\"firstName\": \"Тимур\", \"lastName\": \"Гуев\"}\r\n{'firstName': 'Тимур', 'lastName': 'Гуев'}\r\n</strong>\r\n</pre>\r\nPython преобразует такую строку обратно в словарь без проблем (поскольку использует Unicode по умолчанию), но нужно помнить, что это может привести к проблемам с преобразованием в программах, написанных на других языках программирования.",
    "slug": "json-files"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 34,
  "fields": {
    "lesson": "Работа с zip файлами",
    "content": "<strong>Архивирование данных</strong><br><br>\r\nСжатие информации – это процесс преобразования информации, хранящейся в файле, при котором уменьшается избыточность в ее представлении и, соответственно, требуется меньший объем памяти для хранения.<br><br>\r\n\r\nСжатие информации в файлах производится за счет устранения избыточности различными способами, например, за счет упрощения кодов, исключения из них постоянных битов или представления повторяющихся символов или повторяющейся последовательности символов в виде коэффициента повторения и соответствующих символов.<br><br>\r\n\r\n<strong>Архивация файлов</strong> — упаковка нескольких файлов в один файл или поток — архив. Не следует путать архивацию со сжатием, которое далеко не всегда применяется при создании архива.<br><br>\r\n\r\n<strong>Архивный файл</strong> – это специальным образом организованный файл, содержащий в себе один или несколько файлов в сжатом или несжатом виде и служебную информацию об именах файлов, дате и времени их создания или модификации, размерах и т.д.\r\n<br><br>\r\n\r\nЦелью архивации (упаковки) файлов обычно являются обеспечение более компактного размещения информации на диске, сокращение времени и соответственно стоимости передачи информации по каналам связи в компьютерных сетях. Кроме того, упаковка в один архивный файл группы файлов существенно упрощает их перенос с одного компьютера на другой и сокращает время копирования файлов на диски.<br><br>\r\n\r\nСтепень сжатия зависит от используемой программы, метода сжатия и типа исходного файла. Наиболее хорошо сжимаются файлы графических образов, текстовые файлы и файлы данных, для которых степень сжатия может достигать 5−40%, меньше сжимаются файлы исполняемых программ и загрузочных модулей – 60−90%. Почти не сжимаются архивные файлы.<br><br>\r\n\r\n<strong>Архивация (упаковка)</strong> – помещение (загрузка) исходных файлов в архивный файл в сжатом или несжатом виде.<br><br>\r\n\r\n<strong>Разархивация (распаковка)</strong> – процесс восстановления файлов из архива точно в таком виде, какой они имели до загрузки в архив. При распаковке файлы извлекаются из архива и помещаются на диск или в оперативную память;<br><br>\r\n\r\nПрограммы, осуществляющие упаковку и распаковку файлов, называются программами – архиваторами.<br><br>\r\n\r\n<strong>Формат zip</strong><br><br>\r\nВ реальной жизни применяется большое количество различных форматов архивов: zip, 7z, rar и многие другие. В нашем уроке мы остановимся на zip архивах.<br><br>\r\n\r\n<strong>zip</strong> — это формат сжатия без потерь: после распаковки данные будут такими же, как перед сжатием. Алгоритм ищет избыточности в исходных данных и эффективнее представляет информацию.<br><br>\r\n\r\nФормат сжатия без потерь отличается от сжатия с потерями, который используется в таких форматах, как JPEG и MP3: при сжатии выбрасывается часть информации, которая менее заметна для человеческого глаза или уха.<br><br>\r\n\r\nФормат zip обладает следующими преимуществами:<br><br>\r\n\r\n<li>является полностью открытым</li>\r\n<li>является очень популярным (большинство архивов в Internet – это архивы zip)</li>\r\n<li>является очень быстрым</li><br><br>\r\n\r\n<strong>Работа с zip файлами в Python</strong><br><br>\r\nВ Python для работы с zip архивами используется встроенный модуль zipfile. Основное преимущество данного модуля заключается в том, что он позволяет работать с архивом, как с обычной папкой, содержащей файлы и другие каталоги.<br><br>\r\n\r\n   Не забывайте, что в архив может быть помещена целая структура каталогов.<br><br>\r\n\r\n<strong>Модуль zipfile</strong><br><br>\r\n\r\nДля того чтобы начать работать с zip архивами в Python, нам потребуется импортировать модуль zipfile, в частности нам потребуется создать объект ZipFile.<br><br>\r\n<pre>\r\n<strong>\r\nfrom zipfile import ZipFile\r\n</strong>\r\n</pre>\r\nОбъекты ZipFile похожи на файловые объекты, возвращаемые функцией open().<br><br>\r\n\r\n<strong>Метод printdir()</strong><br><br>\r\nВ начале работы мы создаем объект типа ZipFile, передавая ему имя архива (архив лежит в той же папке, что и программа).<br><br>\r\n\r\nМетод printdir() выводит таблицу с информацией о содержимом архива: полные названия файлов с указанием даты изменения и размера в байтах.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom zipfile import ZipFile\r\n\r\nwith ZipFile('test.zip') as zip_file:\r\n    zip_file.printdir()\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nFile Name                                             Modified             Size\r\ntest/                                          2021-11-27 12:47:10            0\r\ntest/Картинки/                                 2021-11-27 12:49:02            0\r\ntest/Картинки/1.jpg                            2021-09-02 12:30:20        90156\r\ntest/Картинки/avatar.png                       2021-08-20 09:38:44        19053\r\ntest/Картинки/certificate.png                  2021-10-23 09:46:36        43699\r\ntest/Картинки/py.png                           2021-07-28 17:55:56        33522\r\ntest/Картинки/World_Time_Zones_Map.png         2021-11-08 07:30:06      2324421\r\ntest/Картинки/Снимок экрана.png                2021-10-01 20:47:02        10878\r\ntest/Неравенства.djvu                          2021-08-19 08:39:06      5283010\r\ntest/Программы/                                2021-11-27 12:48:20            0\r\ntest/Программы/image_util.py                   2021-11-18 12:42:22         4955\r\ntest/Программы/sort.py                         2021-11-14 19:31:02           61\r\ntest/Разные файлы/                             2021-11-27 12:48:10            0\r\ntest/Разные файлы/astros.json                  2021-11-08 09:29:58          505\r\n</strong>\r\n</pre>\r\nПри создании объекта ZipFile мы также можем передать необязательный аргумент mode, который задает режим работы (по аналогии с обычными файлами):<br><br>\r\n\r\n<li>r — файл будет открыт для чтения</li>\r\n<li>w — если файл существует, то он будет уничтожен и вместо него будет создан новый файл</li>\r\n<li>a — существующий файл будет открыт в режиме добавления в конец</li>\r\n   По умолчанию параметр mode имеет значение mode='r', то есть архив открывается для чтения.<br><br>\r\n\r\n<strong>Метод infolist()</strong><br><br>\r\nМетод infolist() позволяет получить информацию о файлах из архива в виде списка специальных объектов (тип ZipInfo), которые содержат дополнительную информацию о каждом файле:\r\n\r\n<li>file_size</li>\r\n<li>compress_size</li>\r\n<li>filename</li>\r\n<li>date_time</li>\r\n<li>...</li><br>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom zipfile import ZipFile\r\n\r\nwith ZipFile('test.zip') as zip_file:\r\n    info = zip_file.infolist()\r\n    print(info[6].file_size)                # размер начального файла в байтах\r\n    print(info[6].compress_size)            # размер сжатого файла в байтах\r\n    print(info[6].filename)                 # имя файла\r\n    print(info[6].date_time)                # дата изменения файла\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n2324421\r\n2322032\r\ntest/Картинки/World_Time_Zones_Map.png\r\n(2021, 11, 8, 7, 30, 6)\r\n</strong>\r\n</pre>\r\nПомимо указанных атрибутов (свойств) file_size, compress_size, filename, date_time доступны и другие, о которых можно почитать в официальной документации.<br><br>\r\n\r\n   Обратите внимание на то, что атрибут date_time представляет из себя кортеж (год, месяц, день, час, минута, секунда).<br><br>\r\n\r\nТакже мы можем использовать метод is_dir(), чтобы проверить тип объекта: файл или папка. Он возвращает True, если объект является папкой, или False в противном случае.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom zipfile import ZipFile\r\n\r\nwith ZipFile('test.zip') as zip_file:\r\n    info = zip_file.infolist()\r\n    print(info[0].is_dir())\r\n    print(info[6].is_dir())\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTrue\r\nFalse\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод namelist()</strong><br><br>\r\nМетод namelist() возвращает список названий файлов и директорий, содержащихся в архиве.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom zipfile import ZipFile\r\n\r\nwith ZipFile('test.zip') as zip_file:\r\n    info = zip_file.namelist()\r\n    print(*info, sep='\\n')\r\n</strong>\r\n</pre>\r\nвыводит: \r\n<pre>\r\n<strong>\r\ntest/\r\ntest/Картинки/\r\ntest/Картинки/1.jpg\r\ntest/Картинки/avatar.png\r\ntest/Картинки/certificate.png\r\ntest/Картинки/py.png\r\ntest/Картинки/World_Time_Zones_Map.png\r\ntest/Картинки/Снимок экрана.png\r\ntest/Неравенства.djvu\r\ntest/Программы/\r\ntest/Программы/image_util.py\r\ntest/Программы/sort.py\r\ntest/Разные файлы/\r\ntest/Разные файлы/astros.json\r\n</strong>\r\n</pre>\r\n\r\n<strong>Метод getinfo()</strong><br><br>\r\n</strong>\r\n</pre>\r\nВ отличие от метода infolist(), который позволяет получить информацию о всех файлах из архива в виде списка специальных объектов (тип ZipInfo), метод getinfo() позволяет получить информацию о конкретном файле по его имени в архиве.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom zipfile import ZipFile\r\n\r\nwith ZipFile('test.zip') as zip_file:\r\n    info = zip_file.namelist()                # получаем названия всех файлов архива\r\n    last_file = zip_file.getinfo(info[-4])    # получаем информацию об отдельном файле\r\n    print(last_file.file_size)\r\n    print(last_file.compress_size)\r\n    print(last_file.filename)\r\n    print(last_file.date_time)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n4955\r\n1641\r\ntest/Программы/image_util.py\r\n(2021, 11, 18, 12, 42, 22)\r\n</strong>\r\n</pre>\r\n\r\n<strong>Работа с конкретными файлами из архива</strong><br><br>\r\nСтруктуру архива мы получили, «вытащим» теперь и конкретный файл.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom zipfile import ZipFile\r\n\r\nwith ZipFile('test.zip') as zip_file:\r\n    with zip_file.open('test/Разные файлы/astros.json') as file:\r\n        print(file.read())\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nb'{\"number\": 10, \"people\": [{\"craft\": \"ISS\", \"name\": \"Mark Vande Hei\"}, {\"craft\": \"ISS\", \"name\": \"Pyotr Dubrov\"}, {\"craft\": \"ISS\", \"name\": \"Thomas Pesquet\"}, {\"craft\": \"ISS\", \"name\": \"Megan McArthur\"}, {\"craft\": \"ISS\", \"name\": \"Shane Kimbrough\"}, {\"craft\": \"ISS\", \"name\": \"Akihiko Hoshide\"}, {\"craft\": \"ISS\", \"name\": \"Anton Shkaplerov\"}, {\"craft\": \"Shenzhou 13\", \"name\": \"Zhai Zhigang\"}, {\"craft\": \"Shenzhou 13\", \"name\": \"Wang Yaping\"}, {\"craft\": \"Shenzhou 13\", \"name\": \"Ye Guangfu\"}], \"message\": \"success\"}'\r\nОбратите внимание на символ b перед выводом. Это бинарная строка. Метод file.read() возвращает сырые байты (тип bytes). Для того чтобы преобразовать их в строку (тип str), нужно использовать метод decode(), указав нужную кодировку (файл astros.json имеет кодировку UTF-8).\r\n</strong>\r\n</pre>\r\n   Метод ZipFile.open() открывает файл именно в бинарном виде, не в текстовом.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom zipfile import ZipFile\r\n\r\nwith ZipFile('test.zip') as zip_file:\r\n    with zip_file.open('test/Разные файлы/astros.json') as file:\r\n        print(file.read().decode('utf-8'))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n{\"number\": 10, \"people\": [{\"craft\": \"ISS\", \"name\": \"Mark Vande Hei\"}, {\"craft\": \"ISS\", \"name\": \"Pyotr Dubrov\"}, {\"craft\": \"ISS\", \"name\": \"Thomas Pesquet\"}, {\"craft\": \"ISS\", \"name\": \"Megan McArthur\"}, {\"craft\": \"ISS\", \"name\": \"Shane Kimbrough\"}, {\"craft\": \"ISS\", \"name\": \"Akihiko Hoshide\"}, {\"craft\": \"ISS\", \"name\": \"Anton Shkaplerov\"}, {\"craft\": \"Shenzhou 13\", \"name\": \"Zhai Zhigang\"}, {\"craft\": \"Shenzhou 13\", \"name\": \"Wang Yaping\"}, {\"craft\": \"Shenzhou 13\", \"name\": \"Ye Guangfu\"}], \"message\": \"success\"}\r\n</strong>\r\n</pre>\r\nОбратите внимание на отсутствие символа b.<br><br>\r\n\r\n<strong>Запись в zip архив</strong><br><br>\r\nПо аналогии с чтением файлов из архива их можно туда и записывать, для этого необходимо создать объект ZipFile в режимах mode='w' или mode='a'.<br><br>\r\n\r\nДля записи файла в архив используется метод write(), который принимает имя существующего файла.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom zipfile import ZipFile\r\n\r\nwith ZipFile('archive.zip', mode='w') as zip_file:\r\n    zip_file.write('program.py')\r\n    zip_file.write('lse.jpeg')\r\n    print(zip_file.namelist())\r\n</strong>\r\n</pre>\r\ncоздает в папке с программой архив с именем archive.zip и записывает в него содержимое файлов program.py и lse.jpeg, которые так же находятся в папке с программой, а затем выводит список всех файлов данного архива:\r\n<pre>\r\n<strong>\r\n['program.py', 'lse.jpeg']\r\n</strong>\r\n</pre>\r\n   Если файлы для записи в архив не будут найдены, то возникнет ошибка (исключение) FileNotFoundError.\r\n\r\nМетод write() может принимать еще один строковый аргумент, задающий новое имя файла в архиве.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom zipfile import ZipFile\r\n\r\nwith ZipFile('archive.zip', mode='w') as zip_file:\r\n    zip_file.write('program.py', 'new_program.py')  # первый аргумент - это имя файла\r\n    zip_file.write('lse.jpeg', 'lse1.jpeg')         # второй аргумент - это имя файла в архиве\r\n    print(zip_file.namelist())\r\n</strong>\r\n</pre>                      \r\ncоздает в папке с программой архив с именем archive.zip и записывает в него содержимое файлов program.py и lse.jpeg, которые так же находятся в папке с программой, а затем выводит список всех файлов данного архива:\r\n<pre>\r\n<strong>\r\n['new_program.py', 'lse1.jpeg']\r\n</strong>\r\n</pre>\r\nДля добавления файлов в уже существующий архив необходимо создать объект ZipFile в режиме mode='a'.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom zipfile import ZipFile\r\n\r\nwith ZipFile('test.zip', mode='a') as zip_file:\r\n    zip_file.write('program.py', 'test/program.py')\r\n    zip_file.write('lse.jpeg')\r\n    print(*zip_file.namelist(), sep='\\n')\r\n</strong>\r\n</pre>\r\nдобавляет два новых файла program.py и lse.jpeg в уже существующий архив test.zip и выводит:\r\n<pre>\r\n<strong>\r\ntest/\r\ntest/Картинки/\r\ntest/Картинки/1.jpg\r\ntest/Картинки/avatar.png\r\ntest/Картинки/certificate.png\r\ntest/Картинки/py.png\r\ntest/Картинки/World_Time_Zones_Map.png\r\ntest/Картинки/Снимок экрана.png\r\ntest/Неравенства.djvu\r\ntest/Программы/\r\ntest/Программы/image_util.py\r\ntest/Программы/sort.py\r\ntest/Разные файлы/\r\ntest/Разные файлы/astros.json\r\ntest/program.py\r\nlse.jpeg\r\n</strong>\r\n</pre>\r\nОбратите внимание на то, что файл program.py добавлен в папку test, в то время как файл lse.jpeg добавлен в корень архива.<br><br>\r\n\r\n<strong>Извлечение содержимого zip-файла в каталог</strong><br><br>\r\nДля извлечения данных из архива в каталог используются методы extract() и extractall().<br><br>\r\n\r\nЕсли требуется извлечь отдельные файлы, то используется метод extract(), он принимает два аргумента: название файла и путь, по которому требуется извлечь файл. Если путь не указывать, то файл будет извлечен в папку, где находится файл с программой.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom zipfile import ZipFile\r\n\r\nwith ZipFile('test.zip') as zip_file:\r\n    zip_file.extract('test/Картинки/avatar.png')\r\n    zip_file.extract('test/Программы/image_util.py')\r\n    zip_file.extract('lse.jpeg')\r\n</strong>\r\n</pre>\r\nизвлекает файлы из обновленного архива test.zip.<br><br>\r\n\r\nЕсли требуется извлечь все содержимое архива, то используется метод extractall(), он принимает в качестве аргумента путь, по которому требуется извлечь все файлы. Если путь не указывать, то файл будет извлечен в папку, где находится файл с программой.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nfrom zipfile import ZipFile\r\n\r\nwith ZipFile('test.zip') as zip_file:\r\n    zip_file.extractall()\r\n</strong>\r\n</pre>\r\nизвлекает все содержимое файла test.zip в папку, где находится файл с программой, при этом структура каталогов архива сохраняется.",
    "slug": "zip-files"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 35,
  "fields": {
    "lesson": "Работа с pickle файлами",
    "content": "<strong>Сериализация и десериализация</strong><br><br>\r\nПри изучении формата данных (и одноименного модуля в Python) json мы говорили о сериализации объектов.<br><br>\r\n\r\nПреобразование переменных программы (Python-объектов) в формат для хранения называется «сериализацией», а обратное преобразование — «десериализацией».<br><br>\r\n\r\nСериализация объектов часто используется для:<br><br>\r\n\r\n<li>сохранения состояния программы (то есть некоторых её объектов) между запусками</li>\r\n<li>передачи данных между различными программами (например, по сети)</li><br><br>\r\nГлавная идея состоит в том, что сериализованный формат — набор байт или строка, которую можно легко сохранить на диск или передать другой программе, в отличие от самого объекта. А значит, задача сохранения объекта/группы объектов при этом сводится к простой задаче сохранения набора байт или строки.<br><br>\r\n\r\n<strong>Модуль pickle</strong><br><br>\r\nКак уже было сказано, JSON — один из популярных форматов для сериализации, он текстовый, легковесный и легко читается человеком. С помощью встроенного модуля json можно сериализовать только встроенные типы данных:<br><br>\r\n\r\n<li>bool</li>\r\n<li>dict</li>\r\n<li>int</li>\r\n<li>float</li>\r\n<li>list</li>\r\n<li>string</li>\r\n<li>tuple</li>\r\n<li>None</li><br><br>\r\nПомимо сериализации в формат json мы также можем использовать бинарную сериализацию, то есть сериализацию в байты. Для этого в Python используется модуль pickle. Интерфейс взаимодействия с модулем pickle абсолютно такой же, как и для модуля json. Мы будем использовать четыре основных функции:<br><br>\r\n\r\n<li>dump()</li>\r\n<li>load()</li>\r\n<li>dumps()</li>\r\n<li>loads()</li><br><br>\r\n\r\n<strong>Функции dump() и load()</strong><br><br>\r\n<strong>Функция dump()</strong> модуля pickle принимает сериализуемый Python объект, сериализует его в бинарный, Python-зависимый формат, используя протокол pickle, и сохраняет его в открытый для записи бинарный файл.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport pickle\r\n\r\nobj = {'Python': 1991, 'Java': 1995, 'C#': 2002}\r\n\r\nwith open('file.pkl', 'wb') as file:\r\n    pickle.dump(obj, file)\r\n</strong>\r\n</pre>\r\nсоздает файл file.pkl, содержащий бинарное представление объекта obj на основе протокола pickle.<br><br>\r\n\r\n<strong>Функция load()</strong> принимает файловый объект, читает из него сериализованные данные, десериализует их в Python-объект и возвращает полученный Python-объект.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport pickle\r\n\r\nwith open('file.pkl', 'rb') as file:     # используется файл полученный на предыдущем шаге\r\n    obj = pickle.load(file)\r\n    print(obj)\r\n    print(type(obj))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n{'Python': 1991, 'Java': 1995, 'C#': 2002}\r\nclass 'dict'\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функции dumps() и loads()</strong><br><br>\r\n<strong>Функция dumps()</strong> (обратите внимание на s в конце имени функции) выполняет такую же сериализацию, как и функция dump(). Но вместо того чтобы сохранять сериализованные данные в открытый для записи бинарный файл, она просто возвращает эти сериализованные данные.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport pickle\r\n\r\nobj = {'Python': 1991, 'Java': 1995, 'C#': 2002}\r\nbinary_obj = pickle.dumps(obj)\r\n\r\nprint(binary_obj)\r\nprint(type(binary_obj))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nb'\\x80\\x03}q\\x00(X\\x06\\x00\\x00\\x00Pythonq\\x01M\\xc7\\x07X\\x04\\x00\\x00\\x00Javaq\\x02M\\xcb\\x07X\\x02\\x00\\x00\\x00C#q\\x03M\\xd2\\x07u.'\r\nclass 'bytes'\r\n</strong>\r\n</pre>\r\nПоскольку протокол pickle использует бинарный формат данных, функция dumps() возвращает объект типа bytes.<br><br>\r\n\r\n<strong>Тип данных bytes</strong> — это неизменяемые последовательности отдельных байтов. Синтаксис для байтовых литералов в основном такой же, как и для строковых литералов, за исключением того, что добавляется префикс b.<br><br>\r\n\r\n<strong>Функция loads()</strong> (обратите внимание на s в конце имени функции) выполняет такую же десериализацию, как и функция load(). Но вместо того чтобы принимать файловый объект, она принимает объект типа bytes, содержащий сериализованные данные.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport pickle\r\n\r\nobj = {'Python': 1991, 'Java': 1995, 'C#': 2002}\r\nbinary_obj = pickle.dumps(obj)\r\n\r\nnew_obj = pickle.loads(binary_obj)\r\n\r\nprint(new_obj)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n{'Python': 1991, 'Java': 1995, 'C#': 2002}\r\n</strong>\r\n</pre>\r\nОбратите внимание, что объекты obj и new_obj равны, то есть имеют одинаковое содержимое, однако объекты не являются идентичными. Мы создали идеальную копию, но это всё же копия.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport pickle\r\n\r\nobj = {'Python': 1991, 'Java': 1995, 'C#': 2002}\r\nbinary_obj = pickle.dumps(obj)\r\nnew_obj = pickle.loads(binary_obj)\r\n\r\nprint(obj == new_obj)\r\nprint(obj is new_obj)       # проверка на идентичность\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTrue\r\nFalse\r\n</strong>\r\n</pre>",
    "slug": "pickle-files"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 36,
  "fields": {
    "lesson": "Модуль Os",
    "content": "<strong>Модуль os</strong><br><br>\r\n\r\nМодуль os из стандартной библиотеки языка программирования Python обычно используется для работы с установленной ОС, а также файловой системой ПК. Он содержит массу полезных методов для взаимодействия с файлами и папками на жестком диске. Программы, работающие с модулем os, не зависят от типа ОС и являются легко переносимыми на другую платформу.<br><br>\r\n\r\nМодуль os в Python — это библиотека функций для работы с операционной системой. Методы, включенные в неё, позволяют определять тип операционной системы, получать доступ к переменным окружения, управлять директориями и файлами:<br><br>\r\n\r\n<li>проверка существования объекта по заданному пути;</li>\r\n<li>определение размера в байтах;</li>\r\n<li>удаление;</li>\r\n<li> переименование и др.</li><br><br>\r\n\r\n<strong>Получение информации об ОС</strong><br><br>\r\n\r\nЧтобы узнать имя текущей ОС, достаточно воспользоваться методом name. В зависимости от установленной платформы, он вернет ее короткое наименование в строковом представлении.<br><br>\r\n\r\nПолучить сведения, которые касаются конфигурации компьютера, можно при помощи метода environ. Вызвав его через обращение к библиотеке os, пользователь получает большой словарь с переменными окружения, который выводится в консоль или строковую переменную. Таким образом, можно узнать название системного диска, адрес домашней директории, имя системы и массу другой информации.<br><br>\r\n\r\nПри помощи <strong>функции getenv</strong> можно получить доступ к различным переменным среды. Чтобы сделать это, достаточно передать в качестве аргумента необходимое название переменной.<br><br>\r\n\r\n<strong>Изменение рабочей директории</strong><br><br>\r\n\r\nПо умолчанию рабочей директорией программы является каталог, где содержится документ с ее исходным кодом. Благодаря этому, можно не указывать абсолютный путь к файлу, если тот находится именно в этой папке. Получить сведения о текущей директории позволяет <strong>функция getcwd</strong>, которая возвращает полный адрес рабочего каталога на жестком диске.<br><br>\r\n\r\nПри желании, рабочую директорию можно настроить по своему усмотрению, применив <strong>метод chdir</strong> из библиотеки os. Для этого необходимо передать ему в качестве параметра абсолютный адрес к новому каталогу. Если указанного пути на самом деле не существует, программа будет завершена в аварийном режиме из-за выброшенного исключения.\r\n<br><br>\r\n\r\n<strong>Проверка существования пути</strong>\r\n\r\nЧтобы избежать ошибок, связанных с отсутствием определенного файла или директории, которые должны быть обработаны программой, следует предварительно проверять их наличие с помощью <strong>метода exists</strong>. Передав ему в качестве аргумента путь к нужному файлу или папке, можно рассчитывать на лаконичный ответ в виде булевого значения true/false, сообщающего о наличии/отсутствии указанного объекта в памяти компьютера.<br><br>\r\n\r\nЕсли объект на диске реально существует, это не всегда значит, что он имеет подходящую для дальнейшей обработки форму. Проверить, является ли определенный объект файлом, поможет <strong>функция isfile</strong>, которая принимает его адрес.<br><br>\r\n\r\nАналогичные действия можно выполнить и для проверки объекта на принадлежность к классу директорий, вызвав для его адреса <strong>метод isdir</strong> из библиотеки os.<br><br>\r\n\r\n<strong>Создание директорий</strong><br><br>\r\n\r\nВозможности модуля os позволяют не только отображать информацию об уже существующих в памяти объектах, но и генерировать абсолютно новые. Например, с помощью <strong>метода mkdir</strong> довольно легко создать папку, просто указав для нее желаемый путь. Если директория существует, то возникнет ошибка, которую можно игнорировать с помощью аргумента exist_ok=True в pathlib.Path.<br><br>\r\n\r\nБлагодаря <strong>функции makedirs</strong> можно создавать сразу несколько новых папок в неограниченном количестве, если предыдущая директория является родительской для следующей.<br><br>\r\n\r\n<strong>Удаление файлов и директорий</strong>\r\n\r\n\r\nИзбавиться от ненужного в дальнейшей работе файла можно с помощью <strong>метода remove</strong>, отдав ему в качестве аргумента абсолютный либо относительный путь к объекту.<br><br>\r\n\r\nЧтобы стереть из памяти папку, следует воспользоваться встроенной <strong>функцией rmdir</strong>, указав ей адрес объекта. Однако здесь присутствуют определенные нюансы, поскольку программа не позволит беспрепятственно удалить директорию, в которой хранятся другие объекты. В таком случае на экране отобразится ошибка и будет выброшено исключение.\r\n<br><br>\r\n\r\nДля быстрого удаления множества пустых папок следует вызывать <strong>функцию removedirs</strong>. Она предоставляет возможность избавиться сразу от нескольких каталогов на диске, при условии, что все они вложены друг в друга. Таким образом, указав путь к конечной папке, можно легко удалить все родительские директории, но только если они в результате оказываются пустыми.<br><br>\r\n\r\n<strong>Запуск на исполнение</strong><br><br>\r\n\r\n \r\nВстроенные функции библиотеки os позволяют запускать отдельные файлы и папки прямиком из программы. С этой задачей прекрасно справляется <strong>метод startfile</strong>, которому стоит передать адрес необходимо объекта. Программное обеспечение, используемое для открытия документа, определяется средой автоматически. Например, при запуске обычного файла test.txt, задействуется стандартный блокнот. Если передать функции ссылку на директорию, она будет открыта при помощи встроенного менеджера файлов.<br><br>\r\n\r\n<strong>Получение имени файла и директории</strong><br><br>\r\n\r\nИногда для взаимодействия с документом необходимо получить его полное имя, включающее разрешение, но не абсолютный путь к нему на диске. Преобразовать адрес объекта в название позволяет <strong>функция basename</strong>, которая содержится в подмодуле path из библиотеки os.<br><br>\r\n\r\nОбратная ситуация возникает тогда, когда пользователю нужно получить только путь к файлу, без самого названия объекта. Это поможет сделать <strong>метод dirname</strong>, который возвращает путь к заданному документу в строковом представлении.<br><br>\r\n\r\n<strong>Вычисление размера</strong><br><br>\r\n\r\nЧтобы определить размер документа или папки, стоит воспользоваться <strong>функцией getsize</strong>. Функция возвращает размер данного документа в байтах. Воспользоваться getsize можно и для измерения объема директорий.<br><br>\r\n\r\n<strong>Переименование</strong><br><br>\r\n\r\nБиблиотека os предоставляет возможность быстрой смены названия для любого файла или же каталога при помощи <strong>метода rename</strong>. Данная функция принимает сразу два разных аргумента. Первый отвечает за путь к старому наименованию документа, в то время как второй отвечает за его новое название. Стоит помнить, что метод может генерировать исключение, если по указанному пути нет файла.<br><br>\r\n\r\nПереименовывать можно не только один каталог, но и несколько папок сразу, только если все они находятся в одной иерархической цепочке. Для этого достаточно вызвать <strong>метод renames</strong> и передать ему путь к конечной директории в качестве первого аргумента. В роли же второго параметра выступает аналогичный адрес к папке, но только с новыми именами всей цепочки.<br><br>\r\n\r\n<strong>Содержимое директорий</strong><br><br>\r\n\r\nПроверить наличие в каталоге определенных объектов позволяет <strong>функция listdir</strong>. С её помощью можно получить информацию о файлах и папках в виде списка.<br><br>\r\n\r\nАналогом функции listdir является <strong>функция scandir</strong>, которая возвращает итератор.<br><br>\r\n\r\nВоспользовавшись <strong>методом walk</strong>, можно получить доступ к названиям и путям всех подпапок и файлов, относящихся к заданному каталогу. Применив один внешний цикл for, а также два вложенных, несложно получить информацию об объектах в каталоге folder через специальные списки directories и files.<br><br>\r\n\r\n<strong>Информация о файлах и директориях</strong><br><br>\r\n\r\nВывести на экран или в любое другое место основные сведения об объекте можно через <strong>метод stat</strong>. Поместив ему в качестве параметра расположение файла или папки на диске компьютера, стоит ожидать небольшой массив информации. Здесь можно найти данные о размере объекта в байтах, а также некие числовые значения, отображающие доступ и режим его работы.<br><br>\r\n\r\n<strong>Обработка путей</strong><br><br>\r\n\r\nВозвращаясь к классу path из библиотеки os, стоит принять во внимание <strong>функцию split</strong>, позволяющую очень легко разъединять путь к файлу и имя файла в различные строки.<br><br>\r\n\r\nОбратное действие выполняет <strong>функция join</strong>, позволяя легко соединить путь к документу с его названием.",
    "slug": "module-os"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 37,
  "fields": {
    "lesson": "Механизм памяти в Python",
    "content": "<strong>Управление памятью</strong><br><br>\r\n<strong>Управление памятью</strong> — это процесс выделения, распределения и координации памяти таким образом, чтобы все программы работали правильно и могли оптимально получать доступ к различным системным ресурсам. Управление памятью также включает в себя и очистку памяти от объектов, которые больше не нужны.<br><br>\r\n\r\nСуществует два типа управления памятью:<br><br>\r\n\r\n<li>ручное управление памятью</li>\r\n<li>автоматическое управление памятью</li><br><br>\r\n<strong>Ручное управление</strong> памятью включает в себя, как правило, три этапа:<br><br>\r\n\r\n<li>запрос памяти у операционной системы</li>\r\n<li>работа с ней</li>\r\n<li>возвращение памяти обратно в операционную систему</li><br><br>\r\n<strong>Ручной подход</strong> управления позволяет работать с памятью максимально эффективно. Мы точно знаем, сколько памяти нам выделено, зачем мы ее используем, и т.д. Однако помимо преимуществ такой подход имеет и ряд недостатков. Ключевой из них — сложность. Управлять памятью вручную — сложно и тяжело, поскольку легко забыть вернуть память обратно операционной системе, в результате чего возникает утечка: программа держит неиспользуемую память просто так, не давая применять ее для решения других задач.<br><br>\r\n\r\n<strong>Автоматическое управление</strong> памятью берет на себя самый сложный этап — возвращение памяти обратно операционной системе, когда она уже не требуется. Восстановленная память может использоваться другими объектами. Это пусть и немного менее эффективно, но позволяет сильно сократить трудозатраты на управление памятью и повысить надежность этого процесса.<br><br>\r\n\r\nК языкам с ручным управлением памяти относятся: C, C++, Pascal и многие другие. <br><br>\r\n\r\nК языкам с автоматическим управлением памяти относятся: Python, C#, Java, Ruby, JavaScript и многие другие.<br><br>\r\n\r\n<strong>Механизм памяти в Python</strong><br><br>\r\nPython — это язык с автоматическим управлением памятью. Причем для управления ею он использует несколько механизмов. При запуске Python программы создается новый процесс, в рамках которого операционная система выделяет пул ресурсов, включая виртуальное адресное пространство. В эту память загружается интерпретатор Python вместе со всеми необходимыми ему для работы данными, включая код нашей программы.<br><br>\r\n\r\nОставшаяся свободная виртуальная память используется для хранения Python объектов. Для управления этой памятью в Python используется специальный механизм, который называется аллокатор. Он используется каждый раз, когда нам нужно создать новый объект.<br><br>\r\n\r\nОбычно мы в своих программах не оперируем большими объектами. Большая часть наших данных — это числа, строки и т.д., они занимают не такой уж большой объем в расчёте на одно значение. Но зато мы создаем их достаточно часто. И это приводило бы к проблемам, если бы Python абсолютно все такие вызовы транслировал в операционную систему. Системный вызов на выделение памяти — штука трудозатратная, зачастую связанная с переходом в контекст ядра операционной системы. Поэтому одна из главных задач аллокатора Python — оптимизация количества системных вызовов.<br><br>\r\n\r\nДля больших объектов (больше 512 байт) Python выделяет память напрямую у ОС. Обычно таких объектов не очень много в рамках программы, и создаются они нечасто. Поэтому накладные расходы на создание таких объектов напрямую в оперативную память не так высоки.<br><br>\r\n\r\n<strong>Аллокатор</strong> для малых объектов (не больше 512 байт) использует три уровня абстракции:<br><br>\r\n\r\n<li>блок — кусок памяти, используемый для хранения одного объекта</li>\r\n<li>пул — кусок памяти, содержащий блоки (обычно одна страница виртуальной памяти размером 4 килобайта)</li>\r\n<li>арена — большой непрерывный кусок памяти, содержащий пулы (обычно содержит несколько страниц виртуальной памяти и имеет размер 256 килобайт)</li><br><br>\r\n\r\n\r\n<strong>Блок</strong><br><br>\r\n<strong>Блок</strong> — это кусок памяти, который может содержать только один Python объект фиксированного размера. Размер блока может варьироваться от 8 до 512 байт и должен быть кратен восьми. Все блоки в конкретном пуле имеют одинаковый размер и находятся в одном классе размера, который и определяет размер блока. <br><br>\r\n<pre>\r\n<strong>\r\nРазмер блока в байтах\tИндекс класса размера\r\n1-8\t8\t0\r\n9-16\t16\t1\r\n17-24\t24\t2\r\n25-32\t32\t3\r\n33-40\t40\t4\r\n41-48\t48\t5\r\n...\t...\t...\r\n505-512\t512\t63\r\n</strong>\r\n</pre>\r\n\r\n<strong>Пул</strong><br><br>\r\nПулы состоят из блоков одного размера. Каждый пул работает по принципу двухсвязного списка с другими пулами того же размера. Поэтому алгоритм может с легкостью найти необходимое место для требуемого размера блока даже среди множества пулов. Размер пула равен 4 килобайта.<br><br>\r\n\r\nОграничение пула фиксированным размером блоков помогает с фрагментацией. Если объект уничтожается, аллокатор может заполнить это пространство новым объектом того же размера.<br><br>\r\n\r\nДля эффективного управления пулами Python использует дополнительный список, который называется usedpools. Он хранит указатели на пулы, сгруппированные по классам. Как мы уже знаем, все пулы с одинаковым размером блока связаны между собой с помощью двухсвязного списка. Чтобы перебрать их, нам просто нужно знать начало списка. Если пулов такого размера нет, то при первом запросе памяти будет создан новый пул.<br><br>\r\n\r\nПулы находятся в трех состояниях:<br><br>\r\n\r\n<li>используемый (used) — частично заполненный, какие-то блоки заняты, какие-то свободны</li>\r\n<li>полный (full) — полностью заполненный, все блоки заняты </li>\r\n<li>пустой (empty) — все блоки свободны и доступны для записи (хранятся в списке пустых пулов freepools)</li><br><br>\r\n\r\nИспользуемый пул содержит блоки, в которые можно записать какую-то информацию. Блоки полного пула все распределены и уже содержат данные. Пустые пулы не содержат данных и могут быть разбиты на какие угодны классы размера при необходимости.<br><br>\r\n\r\nДопустим, нашему коду необходимо \r\n8 байт. Если в списке используемых пулов нет пулов с классом размера в 8 байт, то новый пустой пул инициализируется, как хранящий блоки по 8 байт. Затем пустой пул добавляется в список используемых пулов и может быть использован при следующих запросах.<br><br>\r\n\r\nЗаполненный пул освобождает некоторые блоки, когда эта информация в них уже не нужна. Этот пул добавится в список используемых в соответствии со своим классом размера.<br><br>\r\n\r\nОбратите внимание, что пулы и блоки не выделяют память напрямую, вместо этого они используют уже выделенное пространство в аренах.<br><br>\r\n\r\n<strong>Арена</strong><br><br>\r\n<strong>Арена</strong> – это кусок памяти размером в 256 килобайт, который обеспечивает память для 64 пулов.<br><br>\r\n\r\nАрены, в отличие от пулов, не имеют явных разделений на состояния. Они сами по себе организованы в двухсвязный список usable_arenas. Этот список отсортирован по количеству свободных пулов. Чем меньше свободных пулов, тем ближе арена к началу списка.<br><br>\r\n\r\nЭто означает, что наиболее полная арена будет выбрана для записи еще большего количества данных. Такое расположение арен позволяет снизить объем потребляемой программой памяти. Дело в том, что в некоторых случаях, когда память освобождается, она все еще остается недоступной операционной системе. Процесс Python держит ее распределенной и использует ее позже для новых данных. Полное освобождение памяти возвращает память в пользование операционной системе.<br><br>\r\n\r\nАрены — единственные области, которые могут быть полностью освобождены. Таким образом мы понимаем, что те арены, которые находятся в списке ближе к пустому состоянию, должны быть освобождены. В таком случае, область памяти может быть действительно полностью освобождена, и соответственно общий объем памяти Python программы будет уменьшен.",
    "slug": "memory-mechanism-in-python"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 38,
  "fields": {
    "lesson": "Работа переменных в Python",
    "content": "<strong>Переменные в C и C++</strong><br><br>\r\nВозьмём код, который определяет переменную num:\r\n<pre>\r\n<strong>\r\nint num = 101;\r\n</strong>\r\n</pre>\r\nИсполнение этой строки кода проходит через несколько этапов:<br><br>\r\n\r\n<li>выделение достаточного количества памяти для числа</li>\r\n<li>присвоение этому месту в памяти значения 101</li>\r\n<li>отображение, что num указывает на это значение</li><br><br>\r\n\r\nЗдесь переменная num имеет виртуальный адрес 0x7f1 и значение 101. Если позднее нам захочется изменить значение num, это можно сделать так:\r\n<pre>\r\n<strong>\r\nnum = 102;\r\n</strong>\r\n</pre>\r\nЭтот код присваивает переменной num новое значение 102, тем самым перезаписывая предыдущее значение. Это означает, что переменная num изменяема.<br><br>\r\n\r\n\r\nОбратите внимание, что расположение num в памяти не поменялось, только само значение. Это говорит о том, что num — это место в памяти, а не просто имя. Можно сказать, что переменная num владеет местом в памяти. По сути, num — это пустая коробка, которая может содержать лишь одно целое число (тип int).<br><br>\r\n\r\nКогда мы присваиваем num какое-то значение, мы тем самым помещаем значение в коробку, принадлежащую num. При этом создать новую переменную num1 можно следующим образом:\r\n<pre>\r\n<strong>\r\nint num1 = num;\r\n</strong>\r\n</pre>\r\nЭтот код создаёт новую коробку под названием num1 и копирует в неё значение из num.<br><br>\r\n\r\nОбратите внимание на местоположение num1 — 0x7f5. Хотя в num1 и было скопировано значение num, однако переменная num1 владеет новым адресом в памяти. Следовательно, мы можем перезаписывать значение num1, не влияя на num:\r\n<pre>\r\n<strong>\r\nnum1 = 103;\r\n</strong>\r\n</pre>\r\n\r\nТаким образом мы изменили значение переменной num1, но не ее местоположение. Кроме того, мы никак не повлияли на исходную переменную num.<br><br>\r\n\r\n<strong>Переменные в Python</strong><br><br>\r\nВ Python нет переменных, как таковых, вместо них имена. Мы можем использовать термин переменные, однако важно понимать разницу между переменными и именами.<br><br>\r\n\r\nДавайте возьмём эквивалентный код из вышеприведённого примера на С (С++) и напишем его на Python:\r\n<pre>\r\n<strong>\r\nnum = 101\r\n</strong>\r\n</pre>\r\nКак и в C (С++), исполнение этой строки кода проходит через несколько этапов:<br><br>\r\n\r\n<li>создаётся специальный объект PyObject</li>\r\n<li>заполняется его поле Type, которое указывает на тип</li>\r\n<li>заполняется его поле Value, которое указывает на значение</li>\r\n<li>создаётся имя num</li>\r\n<li>имя num начинает указывать на созданный PyObject</li>\r\n<li>счётчик ссылок (поле Reference Count) объекта PyObject увеличивается на 1</li><br><br>\r\n\r\n\r\nКак мы видим, схема памяти в Python отличается от схемы в С (С++), показанной выше. Вместо того чтобы num владел блоком памяти, в котором хранится значение 101, этой памятью владеет PyObject объект.<br><br>\r\n\r\nТаким образом, в Python имя num не владеет напрямую каким-либо адресом в памяти.<br><br>\r\n\r\nДля присвоения нового значения имени num мы используем следующий код:\r\n<pre>\r\n<strong>\r\nnum = 101\r\nnum = 102\r\n</strong>\r\n</pre>\r\nИсполнение этой строки кода проходит через несколько этапов:<br><br>\r\n\r\n<li>создаётся новый PyObject</li>\r\n<li>заполняется его поле Type, которое указывает на тип</li>\r\n<li>заполняется его поле Value, которое указывает на значение</li>\r\n<li>имя num указывает на новый PyObject</li>\r\n<li>счётчик ссылок (поле Reference Count) нового PyObject увеличивается на 1</li>\r\n<li>счётчик ссылок (поле Reference Count) старого PyObject уменьшается на 1</li><br><br>\r\n\r\nnum указывает на объект и не владеет областью памяти напрямую. Также мы видим, что строка кода num = 101 является не присваиванием, а, скорее, привязкой (binding) имени num к объекту.\r\n\r\nКроме того, предыдущий объект (содержавший значение 101) теперь находится в памяти со счётчиком ссылок, равным 0, и подлежит удалению с помощью сборщика мусора.<br><br>\r\n\r\nМы можем ввести новое имя num1:\r\n<pre>\r\n<strong>\r\nnum = 101\r\nnum = 102\r\nnum1 = num\r\n</strong>\r\n</pre>\r\nВ памяти появится новое имя num1, но не новый объект:<br><br>\r\n\r\nМы видим, что новый Python объект не создан, создано только новое имя, которое указывает на тот же объект. Кроме того, счётчик ссылок объекта увеличился на 1.\r\n\r\n   В Python мы не присваиваем переменные, а привязываем имена к объектам.<br><br>\r\n\r\n<strong>Встроенная функция id()</strong><br><br>\r\nУ каждого объекта в Python есть собственный идентификатор, который устанавливается только один раз при его создании. Идентификатор объекта – это целое и постоянное число, которое никогда не изменяется после его создания. В стандартной реализации Python (CPython) идентификатор объекта ассоциируется с адресом объекта в памяти. Для того чтобы получить идентификатор объекта, используется встроенная функция id().\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nname = 'Timur'\r\nage = 29\r\nis_teacher = True\r\n\r\nprint(id(name))\r\nprint(id(age))\r\nprint(id(is_teacher))\r\n</strong>\r\n</pre>\r\nможет выводить:\r\n<pre>\r\n<strong>\r\n2017717924208\r\n2017661682800\r\n140729045662568\r\n</strong>\r\n</pre>\r\n\r\nИмейте в виду, что при каждом новом запуске программы идентификаторы будут разные. Таким образом, объекты, периоды существования которых не пересекаются, могут иметь одинаковый идентификатор.\r\n\r\nВажно понимать, что равные объекты в большинстве случаев имеют разные идентификаторы.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnums1 = [1, 2, 3]\r\nnums2 = [1, 2, 3]\r\n\r\nprint(nums1 == nums2)\r\nprint(id(nums1))\r\nprint(id(nums2))\r\n</strong>\r\n</pre>\r\nможет выводить:\r\n<pre>\r\n<strong>\r\nTrue\r\n2303843075456\r\n2303886617792\r\n</strong>\r\n</pre>\r\n\r\nПричем значение True будет напечатано при любом запуске программы, так как списки nums1 и nums2 равны, а оператор сравнения == проверяет поэлементное равенство списков. Таким образом, переменные nums1 и nums2 указывают на разные адреса памяти, хоть и имеют одинаковое содержимое.<br><br>\r\n\r\nНужно также помнить, что оператор присваивания =, никогда не создает копию данных, а, скорее, привязывает имя к объекту.<br><br>\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnums1 = [1, 2, 3]\r\nnums2 = nums1\r\n\r\nprint(id(nums1))\r\nprint(id(nums2))\r\n</strong>\r\n</pre>\r\nвсегда выводит одинаковые числа (числа могут отличаться от запуска к запуску программы):\r\n<pre>\r\n<strong>\r\n2002273207680\r\n2002273207680\r\n</strong>\r\n</pre>\r\n\r\n\r\n<strong>Оператор is</strong><br><br>\r\nС помощью оператора is можно сравнивать значение объектов на идентичность. Под идентичностью объектов подразумевается равенство их идентификаторов.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnums1 = [1, 2, 3]\r\nnums2 = [1, 2, 3]\r\nnums3 = nums1\r\n\r\nprint(nums1 is nums2, nums1 == nums2)\r\nprint(nums1 is nums3, nums1 == nums3)\r\nprint(nums2 is nums3, nums2 == nums3)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nFalse True\r\nTrue True\r\nFalse True\r\n</strong>\r\n</pre>\r\nМы также можем использовать оператор not в связке с оператором is для проверки того, что два объекта не являются идентичными.<br><br>",
    "slug": "variables-in-python"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 39,
  "fields": {
    "lesson": "Изменяемые и неизменяемые типы",
    "content": "<strong>Изменяемые и неизменяемые типы данных</strong><br><br>\r\nТипы данных в Python делятся на две категории:<br><br>\r\n\r\n<li>изменяемые (list, set, dict, ...)</li>\r\n<li>неизменяемые (int, float, bool, tuple, str, ...)</li><br><br>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndata = 'beegeek'\r\ndata[0] = 'B'\r\n\r\nprint(data)\r\n</strong>\r\n</pre>\r\nприводит к возникновению ошибки:\r\n<pre>\r\n<strong>\r\nTypeError: 'str' object does not support item assignment\r\n</strong>\r\n</pre>\r\nпоскольку строки (тип str) являются неизменяемыми.<br><br>\r\n\r\nНе забывайте, что все строковые методы возвращают новые объекты, а не изменяют исходные. Аналогичным образом работают методы других неизменяемых типов данных.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndata = ['b', 'e', 'e', 'g', 'e', 'e', 'k']\r\ndata[0] = 'B'\r\n\r\nprint(data)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n['B', 'e', 'e', 'g', 'e', 'e', 'k']\r\n</strong>\r\n</pre>\r\nпоскольку списки (тип list) являются изменяемыми.<br><br>\r\n\r\n<strong>Изменение объектов VS оператор присваивания</strong><br><br>\r\nВ Python существует два типа изменения:<br><br>\r\n\r\n<li>присвоение переменной нового значения</li>\r\n<li>непосредственное изменение объекта</li><br>\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnums = [1, 2, 3]\r\n\r\nprint(nums)\r\nprint(id(nums))\r\n\r\nnums = [1, 2, 3] + [4]\r\n\r\nprint(nums)\r\nprint(id(nums))\r\n</strong>\r\n</pre>\r\nвсегда выводит различные идентификаторы (числа могут отличаться от запуска к запуску программы):\r\n<pre>\r\n<strong>\r\n[1, 2, 3]\r\n2130653012352\r\n[1, 2, 3, 4]\r\n2130653007680\r\n</strong>\r\n</pre>\r\nтак как мы не изменяем исходный список, а создаем новый и присваиваем его прежней переменной.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnums = [1, 2, 3]\r\n\r\nprint(id(nums))\r\nprint(nums)\r\n\r\nnums.append(4)\r\n\r\nprint(id(nums))\r\nprint(nums)\r\n</strong>\r\n</pre>\r\nвсегда выводит равные идентификаторы (числа могут отличаться от запуска к запуску программы):\r\n<pre>\r\n<strong>\r\n2675065348480\r\n[1, 2, 3]\r\n2675065348480\r\n[1, 2, 3, 4]\r\n</strong>\r\n</pre>\r\nтак как мы единожды создаем список, а после изменяем его, добавляя в него новый элемент.<br><br>\r\n\r\nТаким образом, в первом случае мы изменяем переменную, то есть изменяем то, на какой объект она ссылается. Во втором случае мы изменяем сам объект, на который может ссылаться любое количество переменных.<br><br>\r\n\r\nВажно понимать, что во время изменения объекта, мы изменяем именно объект, а не переменные. Другими словами, если какая-либо другая переменная указывает на объект, который мы изменили, эта переменная также отразит это изменение, но не потому что изменилась переменная, а потому что изменился объект, на который она ссылается.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnums1 = [1, 2, 3]\r\nnums2 = nums1\r\n\r\nnums1.append(4)\r\n\r\nprint(nums1)\r\nprint(nums2)\r\n</strong>\r\n</pre>\r\nвыводит\r\n<pre>\r\n<strong>\r\n[1, 2, 3, 4]\r\n[1, 2, 3, 4]\r\n</strong>\r\n</pre>\r\nОператор присваивания в Python не создает копию объекта, он лишь связывает имя переменной с объектом. Для неизменяемых объектов это обычно не имеет значения, но для работы с изменяемыми объектами часто требуется создавать реальные копии.",
    "slug": "mutable-immutable-types"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 40,
  "fields": {
    "lesson": "Поверхностное и глубокое копирование",
    "content": "<strong>Создание копий объектов</strong><br><br>\r\nКак мы уже знаем, оператор присваивания в Python не создает копию объекта, он лишь связывает имя переменной с объектом. Для неизменяемых объектов это обычно не имеет значения, но для работы с изменяемыми объектами часто требуется создавать реальные копии.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ndata1 = [1, 2, 3]\r\ndata2 = data1\r\ndata1.append(4)\r\n\r\nprint(id(data1), data1)\r\nprint(id(data2), data2)\r\n</strong>\r\n</pre>\r\nвсегда выводит равные идентификаторы (числа могут отличаться от запуска к запуску программы):\r\n<pre>\r\n<strong>\r\n2371294168448 [1, 2, 3, 4]\r\n2371294168448 [1, 2, 3, 4]\r\n</strong>\r\n</pre>\r\nПоскольку списки (тип list) являются изменяемыми, то изменения в data1, также видны в data2.<br><br>\r\n\r\nДля создания реальных копий объектов в Python используют модуль copy.<br><br>\r\n\r\n<strong>Модуль copy</strong><br><br>\r\nМодуль copy содержит две функции:<br><br>\r\n\r\n<li>copy(): копирует объект и возвращает его поверхностную копию</li>\r\n<li>deepcopy(): копирует объект и возвращает его глубокую копию</li><br><br>\r\n\r\n<strong>Поверхностное копирование</strong><br><br>\r\nПоверхностное копирование создает отдельный новый объект, но вместо копирования дочерних элементов в новый объект, оно просто копирует ссылки на их адреса памяти.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport copy\r\n\r\ndata1 = [1, 2, 3]\r\ndata2 = copy.copy(data1)\r\ndata1.append(4)\r\n\r\nprint(id(data1), data1)\r\nprint(id(data2), data2)\r\n</strong>\r\n</pre>\r\nвсегда выводит разные идентификаторы (числа могут отличаться от запуска к запуску программы):\r\n<pre>\r\n<strong>\r\n2072210867584 [1, 2, 3, 4]\r\n2072250543808 [1, 2, 3]\r\n</strong>\r\n</pre>\r\nтак как переменная data2 ссылается на новый объект, который представляют копию списка [1, 2, 3]. В данном примере элементами списка являются целые числа (неизменяемый тип int), поэтому изменение одного списка не отражается на другом. Если бы элементами списка были бы изменяемые типы, то поверхностное копирование скопировало бы лишь ссылки на их адреса памяти. Следовательно, любое изменение элементов одного объекта отразилось бы также и на элементах другого объекта.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport copy\r\n\r\ndata1 = [[1, 2, 3], [4, 5, 6]]\r\ndata2 = copy.copy(data1)\r\n\r\ndata1.append([7, 8, 9])\r\n\r\nprint(id(data1), data1)\r\nprint(id(data2), data2)\r\n</strong>\r\n</pre>\r\nвыводит (числа могут отличаться от запуска к запуску программы):\r\n<pre>\r\n<strong>\r\n2320743120512 [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\r\n2320753594368 [[1, 2, 3], [4, 5, 6]]\r\n</strong>\r\n</pre>\r\nВ то время как приведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport copy\r\n\r\ndata1 = [[1, 2, 3], [4, 5, 6]]\r\ndata2 = copy.copy(data1)\r\n\r\ndata1[0].append(7)\r\ndata2[1].append(8)\r\n\r\nprint(id(data1), data1)\r\nprint(id(data2), data2)\r\n</strong>\r\n</pre>\r\nвыводит (числа могут отличаться от запуска к запуску программы):\r\n<pre>\r\n<strong>\r\n2088862020160 [[1, 2, 3, 7], [4, 5, 6, 8]]\r\n2088872808384 [[1, 2, 3, 7], [4, 5, 6, 8]]\r\n</strong>\r\n</pre>\r\nИзменения затронули оба списка, потому что оба они содержат ссылки на один и тот же вложенный объект. Так работает поверхностное копирование.<br><br>\r\n\r\nПоверхностное копирование создает отдельный новый объект, но вместо того чтобы копировать дочерние элементы в новый объект, оно просто копирует ссылки на их адреса памяти.<br><br>\r\n\r\n<strong>Глубокое копирование</strong><br><br>\r\nГлубокое копирование создает новую и отдельную копию всего объекта со своим уникальным адресом памяти. Это означает, что любые изменения, внесенные вами в новую копию объекта, не будут отражаться в исходной, и наоборот.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport copy\r\n\r\ndata1 = [[1, 2, 3], [4, 5, 6]]\r\ndata2 = copy.deepcopy(data1)\r\n\r\ndata1[0].append(7)\r\ndata2[1].append(8)\r\n\r\nprint(id(data1), data1)\r\nprint(id(data2), data2)\r\n</strong>\r\n</pre>\r\nвыводит (числа могут отличаться от запуска к запуску программы):\r\n<pre>\r\n<strong>\r\n2001097388608 [[1, 2, 3, 7], [4, 5, 6]]\r\n2001108045760 [[1, 2, 3], [4, 5, 6, 8]]\r\n</strong>\r\n</pre>\r\nПри глубоком копировании временные затраты на создание копии, очевидно выше чем при создании поверхностной копии. Если копируемый объект имеет сложную вложенную структуру, то глубокое копирование может тратить много времени.",
    "slug": "shallow-deep-copying"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 41,
  "fields": {
    "lesson": "Механизмы очистки памяти",
    "content": "<strong>Механизмы очистки памяти</strong><br><br>\r\nКак мы уже знаем, язык Python является языком с автоматически управляемой памятью, то есть программисту, пишущему код на Python, не нужно беспокоиться о работе с памятью, в частности заниматься ее освобождением. Как только данные программы (объекты в Python) больше не нужны, Python автоматически освобождает память, которую они занимали. Несмотря на это, понимание того, как работает механизм очистки памяти, может помочь писать более качественный и производительный код.<br><br>\r\n\r\nСтандартный интерпретатор Python использует сразу два механизма очистки памяти:<br><br>\r\n\r\n<li>подсчет ссылок</li>\r\n<li>сборщик мусора (Garbage Collector, GC)</li><br><br>\r\n\r\n<strong>Подсчет ссылок</strong><br><br>\r\n<strong>Алгоритм подсчета ссылок</strong> — это один из самых простых механизмов очистки памяти. Объекты удаляются как только на них больше нет ссылок.<br><br>\r\n\r\nКаждый объект в Python унаследован от базового класса PyObject, который содержит специальное поле Reference Count (ob_refcnt), в котором хранится количество ссылок на данный объект. Как только кто-то начинает ссылаться на объект, значение этого поля увеличивается на единицу. Если по какой-то причине ссылка пропадает, то это поле уменьшается на один. При этом если счетчик ссылок для определенного объекта достигает нуля, то интерпретатор запускает процесс уничтожения объекта. Если удаленный объект содержал ссылки на другие объекты, то эти ссылки также удаляются. Таким образом, удаление одного объекта может повлечь за собой удаление других.<br><br>\r\n\r\n   Механизм подсчета ссылок работает в режиме реального времени.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnums = [1, 2, 3]\r\n</strong>\r\n</pre>\r\nсоздает объект, у которого поле Reference Count (ob_refcnt) равно 1.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnums = [1, 2, 3]\r\nnums1 = nums\r\n</strong>\r\n</pre>\r\nсоздает объект, у которого поле Reference Count (ob_refcnt) равно 2.<br><br>\r\n\r\nЧетыре основных сценария, увеличивающих количество ссылок на объект:<br><br>\r\n\r\n<li>создание нового объекта и присвоение его переменной</li>\r\n<li>присвоение уже существующего объекта переменной</li>\r\n<li>передача объекта в функцию в качестве аргумента</li>\r\n<li>добавление объекта в список, множество, словарь и т.д.</li><br><br>\r\nЧетыре основных сценария, уменьшающих количество ссылок на объект:<br><br>\r\n\r\n<li>удаление объекта из области видимости функции после ее завершения</li>\r\n<li>удаление переменной с помощью оператора del</li>\r\n<li>переприсваивание переменной нового значения</li>\r\n<li>удаление объекта из списка, множества, словаря и т.д.</li><br><br>\r\nДля получения количества ссылок на заданный объект используется <strong>функция getrefcount()</strong> из модуля sys.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport sys\r\n\r\nnums = [1, 2, 3] \r\n\r\nprint(sys.getrefcount(nums))\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\n2\r\n</strong>\r\n</pre>\r\nКогда мы вызываем <strong>функцию getrefcount()</strong> для получение количества ссылок на объект, мы увеличиваем количество ссылок на объект на один, так как передаем nums в качестве аргумента в функцию. Поэтому счетчик ссылок равен 2. Это означает, что и переменная nums, и функция getrefcount() ссылаются на один и тот же список [1, 2, 3].<br><br>\r\n\r\nМожно поэкспериментировать и написать такой код:\r\n<pre>\r\n<strong>\r\nimport sys\r\n\r\nnums = [1, 2, 3]                            # ссылка 1\r\nnums1 = nums                                # ссылка 2\r\nnums2 = nums1                               # ссылка 3\r\ntemp = [4, 5, 6, nums, nums1, nums2]        # ссылка 4, 5, 6\r\nprint(sys.getrefcount(nums))                # ссылка 7\r\n</strong>\r\n</pre>\r\nкоторый выводит число 7.<br><br>\r\n\r\nАлгоритм подсчета ссылок очень простой и эффективный, но у него есть один большой недостаток. Он не умеет определять циклические ссылки.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnums1 = [1, 2, 3]\r\nnums2 = [4, 5]\r\n\r\nnums1.append(nums2)\r\nnums2.append(nums1) \r\n</strong>\r\n</pre>\r\nсоздает циклические ссылки, так как nums1 содержит ссылку на nums2, в то время как nums2 содержит ссылку на nums1. Таким образом, счетчики ссылок у nums1 и nums2 никогда не будут равны нулю.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnums = [1, 2, 3]\r\nnums.append(nums)\r\n</strong>\r\n</pre>\r\nтакже создает циклическую ссылку, так как nums содержит ссылку на себя самого.<br><br>\r\n\r\nИменно из-за этого в Python существует дополнительный механизм очистки памяти — <strong>сборщик мусора (Garbage Collector, GC)</strong>, который следит за объектами с потенциальными циклическими ссылками.<br><br>\r\n\r\nВ Python алгоритм подсчета ссылок является фундаментальным и не может быть отключен, тогда как сборщик мусора (GC) опционален и может быть отключен.<br><br>\r\n\r\n<strong>Сборщик мусора</strong><br><br>\r\nВ отличие от алгоритма подсчета ссылок, сборщик мусора не работает в режиме реального времени и запускается периодически. Каждый запуск сборщика создаёт микропаузы в работе программы, поэтому Python использует различные эвристики для определения частоты запуска сборщика мусора.<br><br>\r\n\r\nСборщик мусора разделяет все объекты на 3 поколения (нулевое, первое и второе). Новые объекты попадают в <strong>нулевое поколение</strong>. Если новый объект выживает в процессе сборки мусора, то он перемещается в <strong>следующее поколение</strong>. Чем старше поколение, тем реже оно сканируется на сборку мусора. Так как новые объекты зачастую имеют очень маленький срок жизни (являются временными), то имеет смысл проверять их чаще, чем те, которые уже прошли через несколько этапов сборки мусора.<br><br>\r\n\r\nВ каждом поколении есть специальный порог срабатывания, при достижении которого срабатывает процесс сборки мусора. Если сразу несколько поколений преодолели порог, то выбирается наиболее старшее поколение, так как сборка мусора в старших поколениях включает в себя также сборку мусора и в младших поколениях.<br><br>\r\n\r\nДля взаимодействия со сборщиком мусора используется модуль gc.<br><br>\r\n\r\nНаиболее полезные функции модуля:<br><br>\r\n\r\n<li>gc.enable(): включает сборщика мусора (по умолчанию он включен)</li>\r\n<li>gc.disable(): отключает сборщика мусора</li>\r\n<li>gc.isenabled(): возвращает True, если сборщик мусора включен, или False в противном случае</li>\r\n<li>gc.collect(): запускает сборщика мусора на всех трех поколениях. Функция имеет необязательный аргумент generation (целое число от 0 до 2), указывающий номер поколения, в котором нужно запустить сборщика мусора</li><br><br>\r\n\r\nСчетчик ссылок подвержен проблемам в многопоточной среде, которые могут приводить к некорректности обновления этого счетчика из разных потоков и, следовательно, к удалению объектов, на которые еще существуют ссылки. Чтобы этого избежать, CPython использует GIL — Global Interpreter Lock. Каждый раз, когда происходит работа с памятью, GIL — как глобальная блокировка — препятствует выполнению этих действий одновременно из двух потоков. Он гарантирует, что сначала отработает один, потом другой.",
    "slug": "memory-cleaning"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 42,
  "fields": {
    "lesson": "Конструкция try-except",
    "content": "",
    "slug": "try-except-construct"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 43,
  "fields": {
    "lesson": "Необязательный блок else, finally",
    "content": "",
    "slug": "else-finally-construct"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 44,
  "fields": {
    "lesson": "Возбуждение исключений",
    "content": "",
    "slug": "raising-exceptions"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 45,
  "fields": {
    "lesson": "Пользовательские исключения",
    "content": "",
    "slug": "custom-exceptions"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 46,
  "fields": {
    "lesson": "Оператор assert",
    "content": "",
    "slug": "assert-statement"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 47,
  "fields": {
    "lesson": "Рекурсивный обход коллекций",
    "content": "",
    "slug": "recursive-traversal-of-collections"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 48,
  "fields": {
    "lesson": "Особенности итераторов",
    "content": "",
    "slug": "features-of-iterators"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 49,
  "fields": {
    "lesson": "Протокол итерируемых объектов и итераторов",
    "content": "",
    "slug": "protocol-iterator-iterable"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 50,
  "fields": {
    "lesson": "Модуль itertools",
    "content": "",
    "slug": "module-iterools"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 51,
  "fields": {
    "lesson": "Конструкция yield from",
    "content": "",
    "slug": "construct-yield-from"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 52,
  "fields": {
    "lesson": "Генераторные выражения",
    "content": "",
    "slug": "generator-expressions"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 53,
  "fields": {
    "lesson": "Конвейеры генераторов",
    "content": "",
    "slug": "generator-conveyors"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 54,
  "fields": {
    "lesson": "Поиск символов",
    "content": "",
    "slug": "search-symbols"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 55,
  "fields": {
    "lesson": "Соответствие одному из нескольких символов",
    "content": "",
    "slug": "match-one-of-several-characters"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 56,
  "fields": {
    "lesson": "Повторение совпадений",
    "content": "",
    "slug": "repeat-matches"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 57,
  "fields": {
    "lesson": "Использование границ",
    "content": "",
    "slug": "using-borders"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 58,
  "fields": {
    "lesson": "Подвыражения",
    "content": "",
    "slug": "subexpressions-s"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 59,
  "fields": {
    "lesson": "Ссылки назад",
    "content": "",
    "slug": "links-back"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 60,
  "fields": {
    "lesson": "Модуль re",
    "content": "",
    "slug": "module-re"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 61,
  "fields": {
    "lesson": "Модуль decimal",
    "content": "",
    "slug": "module-decimal"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 62,
  "fields": {
    "lesson": "Модуль math",
    "content": "",
    "slug": "module-math"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 63,
  "fields": {
    "lesson": "Модуль fractions",
    "content": "",
    "slug": "module-fractions"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 64,
  "fields": {
    "lesson": "Модуль random",
    "content": "",
    "slug": "module-random"
  }
},
{
  "model": "developer.subdeveloper",
  "pk": 65,
  "fields": {
    "lesson": "Интернирование объектов",
    "content": "<strong>Интернирование объектов</strong><br><br>\r\nКак мы знаем, в Python целые числа (тип int) и строки (тип str) являются неизменяемыми. Это значит, что после того как строковые и целочисленные объекты были созданы, мы не можем изменить или обновить их. Даже если кажется, что строка изменяется, например, после использования метода, на самом деле создается новая строка, а исходная остается прежней.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ns1 = 'beegeek'\r\n\r\ns2 = s1.lower()\r\ns3 = s1.upper()\r\n\r\nprint(s1)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nbeegeek\r\n</strong>\r\n</pre>\r\nУчитывая неизменяемость строковых и целочисленных объектов, Python использует специальную оптимизацию, которая называется интернированием. Интернирование – это процесс хранения в памяти только одной копии объекта. Это означает, что, когда мы создаем две строки (два целых числа) с одинаковыми значениями, то вместо выделения памяти для них обоих, только одна строка (целое число) фактически фиксируется в памяти. Другая же просто указывает на то же самое место в памяти. Для реализации данной оптимизации Python использует специальную таблицу, которая называется пул интернирования. Эта таблица содержит одну уникальную ссылку на каждый объект строкового типа, либо целого числа.<br><br>\r\n\r\n<strong>Интернирование целых чисел</strong><br><br>\r\nПоскольку небольшие целые числа встречаются достаточно часто в нашем коде, Python интернирует их в диапазоне от −5 до 256.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnum1 = 100\r\nnum2 = 100\r\n\r\nnum3 = 1000\r\nnum4 = 1000\r\n\r\nprint(num1 is num2, num1 == num2)\r\nprint(num3 is num4, num3 == num4)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTrue True\r\nFalse True\r\n</strong>\r\n</pre>\r\n\r\nВажно отметить, что среда, в которой выполняется код, влияет на то, как работает интернирование. Поведение может отличаться при использовании различных IDE (PyCharm, Thonny и т.д.), так как все они имеют собственные уровни оптимизации. Все примеры в данном конспекте, а также в задачах, предполагают, что код выполняется в IDLE Python 3.10.<br><br>\r\n\r\nIDLE (Integrated Development and Learning Environment) — это интегрированная среда для разработки (и обучения), которая поставляется вместе с Python.<br><br>\r\n\r\nОбратите внимание на то, что независимо от того, каким образом мы создаем целочисленный объект, если он находится в диапазоне от −5 до 256, он будет интернирован.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\nnum1 = 100 \r\nnum2 = int(100)\r\nnum3 = int('100')\r\nnum4 = 1 + 2 + 97\r\n\r\nprint(id(num1))\r\nprint(id(num2))\r\nprint(id(num3))\r\nprint(id(num4))\r\n</strong>\r\n</pre>\r\nвсегда выводит одинаковые числа (числа могут отличаться от запуска к запуску программы):\r\n<pre>\r\n<strong>\r\n1979656244560\r\n1979656244560\r\n1979656244560\r\n1979656244560\r\n</strong>\r\n</pre>\r\n\r\n<strong>Интернирование строк</strong><br><br>\r\nВ Python 3.7 интернируются строки, содержащие не более 20 символов и состоящие только из ASCII-букв, цифр и знаков подчёркивания. Данный набор символов был выбран потому, что он часто используется в нашем коде.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ns1 = 'beegeek'\r\ns2 = 'beegeek'\r\ns3 = 'bee' + 'geek'\r\n\r\nprint(id(s1))\r\nprint(id(s2))\r\nprint(id(s3))\r\n</strong>\r\n</pre>\r\nвсегда выводит одинаковые числа (числа могут отличаться от запуска к запуску программы):\r\n<pre>\r\n<strong>\r\n2846528331184\r\n2846528331184\r\n2846528331184\r\n</strong>\r\n</pre>\r\n\r\nВ то время как приведенный ниже код:\r\n<pre>\r\n<strong>\r\ns1 = 'beegeek!'\r\ns2 = 'beegeek!'\r\n\r\nprint(id(s1))\r\nprint(id(s2))\r\n</strong>\r\n</pre>\r\nвсегда выводит разные числа (числа могут отличаться от запуска к запуску программы):\r\n<pre>\r\n<strong>\r\n2846528331312\r\n2846528331440\r\n</strong>\r\n</pre>\r\n\r\nВ этом примере использован восклицательный знак, поэтому строки не интернируются и представляют собой разные объекты.<br><br>\r\n\r\nНачиная с Python 3.8 длина интернируемых строк была увеличена до 4096 символов.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ns1 = 'b' * 4096\r\ns2 = 'b' * 4096\r\n\r\ns3 = 'b' * 5000\r\ns4 = 'b' * 5000\r\n\r\nprint(s1 is s2)\r\nprint(s3 is s4)\r\n</strong>\r\n</pre>\r\nв Python 3.8+ выводит:\r\n<pre>\r\n<strong>\r\nTrue\r\nFalse\r\n</strong>\r\n</pre>\r\n\r\n<strong>Функция sys.intern()</strong><br><br>\r\nКак мы уже знаем, Python интернирует лишь строки, содержащие не более 4096 символов и состоящие только из ASCII-букв, цифр и знаков подчёркивания. Однако функция intern() из модуля sys позволяет интернировать любую строку, например, содержащую 5000 символов или состоящую из букв русского алфавита. Данная функция принимает в качестве аргумента строку, добавляет ее в пул интернирования (если ее там нет) и возвращает интернированную строку.\r\n\r\nПриведенный ниже код:\r\n<pre>\r\n<strong>\r\ns1 = 'степик!'\r\ns2 = 'степик!'\r\n\r\nprint(s1 is s2)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nFalse\r\n</strong>\r\n</pre>\r\nВ то время как приведенный ниже код:\r\n<pre>\r\n<strong>\r\nimport sys\r\n\r\ns1 = sys.intern('степик!')\r\ns2 = sys.intern('степик!')\r\n\r\nprint(s1 is s2)\r\n</strong>\r\n</pre>\r\nвыводит:\r\n<pre>\r\n<strong>\r\nTrue\r\n</strong>\r\n</pre>\r\nОсновные преимущества интернирования:<br><br>\r\n\r\n<li>экономия памяти: мы не храним копии одинаковых объектов</li>\r\n<li>быстрые сравнения: сравнение интернированных строк происходит намного быстрее, чем неинтернированных строк. Это происходит потому, что для сравнения интернированных строк нужно только сравнить, совпадают ли их адреса в памяти, а не сравнивать их содержимое</li>",
    "slug": "intern-objects"
  }
},
{
  "model": "developer.category",
  "pk": 1,
  "fields": {
    "direction": "Python",
    "slug": "python"
  }
},
{
  "model": "developer.category",
  "pk": 2,
  "fields": {
    "direction": "Python ООП",
    "slug": "python-oop"
  }
},
{
  "model": "developer.category",
  "pk": 3,
  "fields": {
    "direction": "Ассинхронный Python",
    "slug": "python-async"
  }
},
{
  "model": "developer.category",
  "pk": 4,
  "fields": {
    "direction": "Алгоритмы и структуры данных",
    "slug": "python-algoritm"
  }
},
{
  "model": "developer.categoryoop",
  "pk": 1,
  "fields": {
    "lesson": "Основы и принципы ООП",
    "content": "Здесь будет текст",
    "time_create": "2024-09-10T01:22:27.874Z",
    "time_update": "2024-09-10T01:22:27.874Z",
    "is_published": true,
    "slug": "basic-oop"
  }
}
]
